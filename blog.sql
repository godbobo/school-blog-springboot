/*
 Navicat Premium Data Transfer

 Source Server         : 本地数据库
 Source Server Type    : MySQL
 Source Server Version : 50558
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50558
 File Encoding         : 65001

 Date: 19/03/2019 16:49:07
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `hide` int(11) NOT NULL,
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `top` int(11) NOT NULL,
  `upt` datetime NOT NULL,
  `view` bigint(20) NOT NULL,
  `author` bigint(20) NOT NULL,
  `topic_id` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKdw5d9vdw43e3nvtpqk8l4iitp`(`author`) USING BTREE,
  INDEX `FK6x3cr4vpqhjktvuju4u1f77q1`(`topic_id`) USING BTREE,
  CONSTRAINT `FK6x3cr4vpqhjktvuju4u1f77q1` FOREIGN KEY (`topic_id`) REFERENCES `topic` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKdw5d9vdw43e3nvtpqk8l4iitp` FOREIGN KEY (`author`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, '# 认识 Flex 布局\n\nFlex 是 Flexible Box 的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。\n\n任何一个元素都可以指定为 Flex 布局。\n\n行内元素使用 Flex 布局的方式为： `display: inline-flex;`\n\nFlex 主要用于管理**容器**和**子元素**之间的位置关系。\n\n容器默认存在两个轴：水平的**主轴**和垂直的**交叉轴**，子元素默认沿主轴排列。\n\n> 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。\n\n## 一、容器的属性\n\n> 以下列举的第一个候选值均为默认值。\n\n### 1、flex-direction 属性\n\n用以决定主轴的方向，即子元素的排列方向，它有四个候选值：\n\n- row：水平，起点在左端。\n- row-reverse：水平，起点在右端。\n- column：垂直，起点在上沿。\n- column-reverse：垂直，起点在下沿。\n\n### 2、flex-wrap 属性\n\n当子元素在一条轴线上排不下时，控制换行方式。\n\n- nowrap：不换号。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n### 3、flex-flow 属性\n\n是`flex-direction`和`flex-wrap`的简写形式。\n\n```css\nflex-flow: <flex-direction> <flex-wrap>;\n```\n\n### 4、justify-content 属性\n\n定义了子元素在主轴上的对齐方式。\n\n- flex-start:左对齐。\n- flex-end：右对齐。\n- center：居中。\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。因此导致项目之间的间隔比项目与边框的间隔大一倍。\n\n![](http://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png)\n\n### 5、align-items 属性\n\n- stretch：如果项目未设置高度或设为 auto，将占满整个容器的高度。\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- basseline：项目的第一行文字的基线对齐。\n\n![](http://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png)\n\n### 6、align-content 属性\n\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n![](http://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png)\n\n## 二、子元素（项目）的属性\n\n### 1、order 属性\n\n定义项目的排列顺序，数值越小，排列越靠前，默认为0.\n\n```css\norder: <integer>;\n```\n\n### 2、flex-grow 属性\n\n定义项目的放大比例，默认为0，即如果存在剩余空间也不放大。\n\n```css\nflex-grow: <number>; /* default 0 */\n```\n\n> 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### 3、flex-shrink 属性\n\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n> 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n### 4、flex-basis 属性\n\n定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n> 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间\n\n### 5、flex 属性\n\n是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n\n```css\nflex: none | [ <\'flex-grow\'> <\'flex-shrink\'>? || <\'flex-basis\'> ]\n```\n\n> 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n>\n> 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n### 6、align-self 属性\n\n允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n## 三、使用问题\n\n#### 在容器中使用`position:fixed`会导致 flex 布局失效\n\n解决办法：\n\n在容器外面套一个`<div>`并使其具有`position:fixed`属性。', 0, '介绍了 CSS3 中最新的 Flex 布局方式，该布局方式十分灵活且好用，能够胜任各种复杂的布局情况，十分推荐学习。', 'Flex 布局', 0, '2019-03-16 15:00:47', 0, 100, NULL);
INSERT INTO `article` VALUES (2, '## Less 原理及使用方式\n\n本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。\n\nLESS 可以直接在客户端使用，也可以在服务器端使用。在实际项目开发中，我们更推荐使用第三种方式，**将 LESS 文件编译生成静态 CSS 文件，并在 HTML 文档中应用**。\n\n### 一、在客户端使用\n\nLESS 源文件一定要在 less.js 引入之前引入，这样才能保证 LESS 源文件正确编译解析。\n\n```html\n<link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\">\n```\n\n### 二、服务器端使用\n\nLESS 在服务器端的使用主要是借助于 LESS 的编译器，将 LESS 源文件编译生成最终的 CSS 文件，目前常用的方式是利用 node 的包管理器 (npm) 安装 LESS，安装成功后就可以在 node 环境中对 LESS 源文件进行编译。\n\n## 语法\n\n### 一、变量\n\nLESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单。\n\n**less 文件**\n\n```less\n@border-color : #b5bcc7; \n \n.mythemes tableBorder{ \n  border : 1px solid @border-color; \n}\n```\n\n**css 文件**\n\n```css\n.mythemes tableBorder { \n ``border: 1px solid #b5bcc7; \n}\n```\n\n该特性适用于**定义主题**，我们可以将背景颜色、字体颜色、边框属性等常规样式进行统一定义，这样**不同的主题只需要定义不同的变量文件**就可以了。当然该特性也同样适用于 CSS RESET（重置样式表），在 Web 开发中，我们往往需要屏蔽浏览器默认的样式行为而需要重新定义样式表来覆盖浏览器的默认行为，这里可以使用 LESS 的变量特性，这样就可以在不同的项目间重用样式表，我们仅需要在不同的项目样式表中，根据需求重新给变量赋值即可.\n\n#### 作用域\n\n查找变量的顺序是先在局部定义中找，如果找不到，则查找上级定义，直至全局。\n\n```less\n@width : 20px; \n#homeDiv { \n  @width : 30px; \n  #centerDiv{ \n      width : @width;// 此处应该取最近定义的变量 width 的值 30px \n             } \n} \n#leftDiv { \n    width : @width; // 此处应该取最上面定义的变量 width 的值 20px \n \n}\n```\n\n### 二、Mixins（混入）\n\nMixins（混入）功能对用开发者来说并不陌生，很多动态语言都支持 Mixins（混入）特性，它是**多重继承的一种实现**，在 LESS 中，混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样。\n\n#### 1、混入示例及使用默认值\n\n```less\n// 定义一个样式选择器\n.roundedCorners(@radius:5px) {// @radius:5px是定义的默认值\n    -moz-border-radius: @radius;\n    -webkit-border-radius: @radius;\n    border-radius: @radius;\n}\n// 在另外的样式选择器中使用\n#header {\n    .roundedCorners;\n}\n#footer {\n    .roundedCorners(10px);\n}\n```\n\n#### 2、使用全部变量\n\n像 JavaScript 中 **arguments**一样，Mixins 也有这样一个变量：**@arguments**。@arguments 在 Mixins 中具是一个很特别的参数，当 Mixins 引用这个参数时，**该参数表示所有的变量**，很多情况下，这个参数可以省去你很多代码。\n\n```less\n.boxShadow(@x:0,@y:0,@blur:1px,@color:#000){ \n-moz-box-shadow: @arguments; \n-webkit-box-shadow: @arguments; \nbox-shadow: @arguments; \n} \n#header { \n.boxShadow(2px,2px,3px,#f36); \n}\n```\n\n#### 3、避免重名问题\n\n采用了命名空间的方法来避免重名问题\n\n```less\n// 定义\n#mynamespace { \n.home {...} \n.user {...} \n}\n// 使用\n#mynamespace > .user\n```\n\n#### 4、嵌套\n\nLESS 的嵌套规则的写法是 HTML 中的 DOM 结构相对应的，这样使我们的样式表书写更加简洁和更好的可读性。同时，嵌套规则使得对伪元素的操作更为方便。\n\n```less\na {\n    color: red;\n    text-decoration: none;\n    &:hover {\n        // 有 & 时解析的是同一个元素或此元素的伪类，没有 & 解析是后代元素\n        color: black;\n        text-decoration: underline;\n    }\n}\n```\n\n#### 5、运算及函数\n\n**less 文件**\n\n```less\n@init: #111111;\n @transition: @init*2;\n .switchColor {\n    color: @transition;\n}\n```\n\n**css 文件**\n\n```css\n.switchColor { \n	color: #222222; \n}\n```\n\n上面的例子中使用 LESS 的 operation  特性，其实简单的讲，就是**对数值型的 value（数字、颜色、变量等）进行加减乘除四则运算**。同时 LESS 还有一个专门针对 color 的操作提供一组函数。下面是 LESS 提供的针对颜色操作的函数列表：\n\n```less\nlighten(@color, 10%); // return a color which is 10% *lighter* than @color \ndarken(@color, 10%); // return a color which is 10% *darker* than @color \nsaturate(@color, 10%); // return a color 10% *more* saturated than @color \ndesaturate(@color, 10%);// return a color 10% *less* saturated than @color \nfadein(@color, 10%); // return a color 10% *less* transparent than @color \nfadeout(@color, 10%); // return a color 10% *more* transparent than @color \nspin(@color, 10); // return a color with a 10 degree larger in hue than @color \nspin(@color, -10); // return a color with a 10 degree smaller hue than @color\n```\n\n使用这些函数和 JavaScript 中使用函数一样。\n\n#### 6、注释\n\nless 中可以使用单行注释`//`及多行注释`/**/`，但单行注释在编译后的 css 文件中并不会出现。\n\n## 最佳实践\n\n1. 变量常用于配置主题，单独放在一个文件中，如`var.less`\n2. `common.less`中放基本元素的重置样式、语义化的颜色、文字、背景、间距配置\n3. `layout.less`中以嵌套结构存放每个页面的样式', 0, 'Less 是对 CSS 语言的一种拓展，使用 Less 进行编写的布局代码结构更加类似 Html 的结构，易于理解，且支持使用变量，可以与 JavaScript 中的变量进行联动，是一种十分值得学习的语言。', 'Less 基础知识', 0, '2019-03-16 15:05:06', 0, 100, NULL);
INSERT INTO `article` VALUES (3, '## 初步运行\n\n使用Spring Data JPA 时**只需要预先创建数据库，不需要预先创建数据表**。如果应用在运行时检查到定义的实体类和数据表结构不对应就会报错。\n\n### 1、添加依赖\n\n**pom.xml**\n\n```xml\n<dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n</dependency>\n<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n```\n\n### 2、创建实体对象\n\n**domain/Customer.java**\n\n```java\n// 导包时全部都是 javax.persistence 包下面的类\n@Entity\npublic class Customer {\n    @Id\n    @GeneratedValue(strategy=GenerationType.AUTO)\n    private Long id;\n    private String firstName;\n    private String lastName;\n    protected Customer() {}\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n    @Override\n    public String toString() {\n        return String.format(\n                \"Customer[id=%d, firstName=\'%s\', lastName=\'%s\']\",\n                id, firstName, lastName);\n    }\n}\n```\n\n### 3、创建操作数据的 Repository 对象\n\n**domain/CustomerRepository.java**\n\n```java\n// CustomerRepository 在继承了 JpaRepository 后就拥有了CrudRepository、QueryByExampleExecutor、PagingAndSortingRepository的基本能力了，包括基本的增删改查都有了。\npublic interface CustomerRepository extends JpaRepository<Customer, Long> {\n}\n```\n\n### 4、数据库配置\n\n**application.properties**\n\n```properties\nspring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.properties.hibernate.hbm2ddl.auto=update\n```\n\n或**application.yml**\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/testjpa?serverTimezone=GMT%2B8\n    username: root\n    password: root\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  jpa:\n    properties:\n      hibernate:\n        hbm2ddl:\n          auto: update\n```\n\n关于`spring.jpa.properties.hibernate.hbm2ddl.auto`，一般有四个值可供选择：\n\n```Txt\nvalidate               加载hibernate时，验证创建数据库表结构\ncreate                  每次加载hibernate，重新创建数据库表结构，这就是导致数据库表数据丢失的原因。\ncreate-drop        加载hibernate时创建，退出是删除表结构\nupdate                 加载hibernate自动更新数据库结构，即不会删除原有数据，因此我采用该模式\n```\n\n### 5、运行测试\n\n用 Spring Initialar 创建的 Spring Boot 应用会有 Test 目录，使用该包下面的测试类进行测试。\n\n```java\n@Autowired\nprivate CustomerRepository repository;\n\n@Test\npublic void contextLoads() {\n	// save a couple of customers\n	repository.save(new Customer(\"Jac5\", \"Bauer\"));\n	repository.save(new Customer(\"Chloe\", \"O\'Brian\"));\n	repository.save(new Customer(\"Kim\", \"Bauer\"));\n	repository.save(new Customer(\"David\", \"Palmer\"));\n	repository.save(new Customer(\"Michelle\", \"Dessler\"));\n	repository.save(new Customer(\"Bauer\", \"Dessler\"));\n}\n```\n\n可以看到运行后自动创建了两个表，由于我运行了两次，所以customer 表中一共有12条数据。若我将`spring.jpa.properties.hibernate.hbm2ddl.auto`改为create，则不论运行几次，都是只有6条数据。\n\n![](https://i.loli.net/2019/02/22/5c6fb755da6cb.jpg)\n\n## 深入理解\n\n### 一、继承的方法列表\n\n#### 1、PagingAndSortingRepository 的方法\n\n1. findAll()\n\n#### 2、CrudRepository 的方法\n\n1. find()\n2. delete()\n3. deleteAll()\n4. exists()\n5. findOne()\n6. save()\n\n#### 3、QueryByExampleExecutor 的方法\n\n1. count\n2. exists\n3. findAll\n4. findOne\n\n### 二、创建查询\n\nJPA 的查询通常会按照方法名去推断查询方式，下面是一个例子：\n\n**CustomerRepository.java**\n\n```java\nList<Customer> findByLastName(String lastName);\n// 通过参数lastName去解析，并将查询结果返回，\n// 语义相当于`select * from customer where last_name=${lastName}`\n```\n\n#### 创建查询的命名方法准则\n\n**page1**\n\n![](http://springforall.ufile.ucloud.com.cn/static/img/9a32bc484cda2b7d89371d909296b81d1515160)\n\n**page2**\n\n![](http://springforall.ufile.ucloud.com.cn/static/img/a0af26b59b775a77cf5d5702ce0597a21515160)\n\n**page3**\n\n![](http://springforall.ufile.ucloud.com.cn/static/img/99481fa01fabba86843fb2422b9e85771515160)\n\n### 三、预定义查询\n\n预定义查询是将查询语句定义在实体类的注解上，比较笨重，一般不会使用。\n\n**Customer.java**\n\n```java\n@Entity\n// sql 表达式中的表名要和当前 Entity 一致，查询参数也要和实体属性对应，采用驼峰法命名\n@NamedQuery(name = \"Customer.findByFirstName\", query = \"select c from Customer c where c.firstName = ?1\")\npublic class Customer {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String firstName;\n    private String lastName;\n    protected Customer() {}\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n    @Override\n    public String toString() {\n        return String.format(\n            \"Customer[id=%d, firstName=\'%s\', lastName=\'%s\']\",\n            id, firstName, lastName);\n    }\n}\n```\n\n**CustomerRepository.java**\n\n```java\n// 增加方法：\n  /**\n   * 查询FirstName为指定用户昵称\n   */\n  @RequestMapping(\"/findByFirstName\")\n  public void findByFirstName() {\n      Customer customer = repository.findByFirstName(\"Bauer\");\n      if (customer != null) {\n          System.out.println(customer.toString());\n      }\n      System.out.println(\"-------------------------------------------\");\n  }\n```\n\n### 四、使用@Query 注解\n\n`@Query`注解用于 Repository 接口中，可以定义 sql 查询表达式。\n\n**示例**\n\n```java\n/**\n * 模糊匹配\n */\n@Query(\"select c from Customer c where c.firstName=?1\")\nCustomer findByFirstName2(String bauer);\n\n@Query(\"select c from Customer c where c.lastName=?1 order by c.id desc\")\nList <Customer> findByLastName2(String lastName);\n\n/**\n * 一个参数，匹配两个字段\n * 这里Param的值和=:后面的参数匹配，但不需要和方法名对应的参数值对应\n */\n@Query(\"select c from Customer c where c.firstName=:name or c.lastName=:name  order by c.id desc\")\nList <Customer> findByName(@Param(\"name\") String name2);\n\n/**\n * 一个参数，匹配两个字段\n * 这里的%只能放在占位的前面，后面不行\n */\n@Query(\"select c from Customer c where c.firstName like %?1\")\nList <Customer> findByName2(@Param(\"name\") String name);\n\n/**\n * 一个参数，匹配两个字段\n * 开启nativeQuery=true，在value里可以用原生SQL语句完成查询\n */\n@Query(nativeQuery = true, value = \"select * from Customer c where c.first_name like concat(\'%\' ,?1,\'%\') \")\nList <Customer> findByName3(@Param(\"name\") String name);\n```\n\n### 五、使用 Sort 进行排序\n\n使用 sql 语句同样可以完成排序，但灵活度不够，因此可以使用 Sort 对结果进行排序。\n\n**CustomerRepository.java**\n\n```java\n @Query(\"select c from Customer c where c.firstName=:name or c.lastName=:name\")\n List <Customer> findByName4(@Param(\"name\") String name2,Sort sort);\nSort 类所在的包为 org.springframework.data.domain.Sort\n\n/* 以下为测试方法 */\n\nSystem.out.println(\"直接创建sort对象，通过排序方法和属性名\");\nSort sort = new Sort(Sort.Direction.DESC, \"id\");\nList <Customer> result = repository.findByName4(\"Bauer\", sort);\nfor (Customer customer: result) {\n    System.out.println(customer.toString());\n}\n\nSystem.out.println(\"通过Sort.Order对象创建sort对象\");\nSort sortx = new Sort(new Sort.Order(Sort.Direction.DESC, \"id\"));\nList<Customer> resultx = repository.findByName4(\"Bauer\", sort);\nfor (Customer customer: result) {\n    System.out.println(customer.toString());\n}\n\nSystem.out.println(\"通过排序方法和属性List创建sort对象\");\nList<String> sortProperties = new ArrayList <>();\nsortProperties.add(\"id\");\nsortProperties.add(\"firstName\");\nSort sort2 = new Sort(Sort.Direction.DESC, sortProperties);\nList <Customer> result2 = repository.findByName4(\"Bauer\", sort2);\nfor (Customer customer: result2) {\n    System.out.println(customer.toString());\n}\n\nSystem.out.println(\"通过创建Sort.Order对象的集合创建sort对象\");\nList<Sort.Order> orders = new ArrayList <>();\norders.add(new Sort.Order(Sort.Direction.DESC, \"id\"));\norders.add(new Sort.Order(Sort.Direction.ASC, \"firstName\"));\nList <Customer> result3 = repository.findByName4(\"Bauer\", new Sort(orders));\nfor (Customer customer: result3) {\n    System.out.println(customer.toString());\n}\n```\n\n### 六、使用@Modifying 更新数据\n\n**CustomerRepository.java**\n\n```java\n/**\n * 根据lastName去更新firstName，返回结果是更改数据的行数\n */\n@Modifying //更新查询\n@Transactional //开启事务\n@Query(\"update Customer c set c.firstName = ?1 where c.lastName = ?2\")\nint setFixedFirstnameFor(String firstName, String lastName);\n// 在使用@Modifying注解的时候，一定要加上事务注解@Transactional\n```\n\n### 七、应用查询提示\n\n**CustomerRepository.java**\n\n```java\nimport static org.hibernate.jpa.QueryHints.HINT_COMMENT;\n\n@QueryHints(value = {\n        @QueryHint(name = HINT_COMMENT, value = \"a query for pageable\")\n    }, forCounting = false)\nPage<User> findByLastname(String lastname, Pageable pageable);\n// 这里增加了@QueryHints注解，是给查询添加一些额外的提示\n// 比如当前的name值为HINT_COMMENT是在查询的时候带上一些备注信息\n```\n\n### 八、分页\n\n在JPA中提供了很方便的分页功能，那就是`Pageable（org.springframework.data.domain.Pageable）`以及它的实现类`PageRequest（org.springframework.data.domain.PageRequest）`\n\n```java\n@QueryHints(value = {\n    @QueryHint(name = HINT_COMMENT, value = \"a query for pageable\")\n})\n@Query(\"select c from Customer c where c.firstName=:name or c.lastName=:name\")\nPage<Customer> findByName(@Param(\"name\") String name2, Pageable pageable);\n```\n\n**CustomerController.java**\n\n```java\n@RequestMapping(\"/pageable\")\npublic void pageable() {\n    //Pageable是接口，PageRequest是接口实现\n    //PageRequest的对象构造函数有多个，page是页数，初始值是0，size是查询结果的条数，后两个参数参考Sort对象的构造方法\n    Pageable pageable = new PageRequest(0, 3, Sort.Direction.DESC, \"id\");\n    Page<Customer> page = repository.findByName(\"bauer\", pageable);\n    //查询结果总行数\n    System.out.println(page.getTotalElements());\n    //按照当前分页大小，总页数\n    System.out.println(page.getTotalPages());\n    //按照当前页数、分页大小，查出的分页结果集合\n    for (Customer customer: page.getContent()) {\n        System.out.println(customer.toString());\n    }\n}\n```\n\n### 九、投影查询\n\n#### 1、增加 CustomerProjection 接口类\n\n```java\npublic interface CustomerProjection {\n    @Value(\"#{target.firstName + \' \' + target.lastName}\")\n    String getFullName();\n\n    String getFirstName();\n\n    String getLastName();\n}\n\n```\n\n这里声明的方式是可以直接通过`get+属性名`，这是普通的，另外也可以通过`@Value`注解来实现指定字段，除了指定字段也可以做**聚合展示**，比如有些地方需要展示客户的全名，这里定义的 getFullName() 方法及注解@Value 即完成这一操作。需要**注意这里的@Value 中的 target 表达式写法及拼接方法**。\n\n#### 2、增加 CustomerRepository 方法\n\n```java\n@Query(\"SELECT c.firstName as firstName,c.lastName as lastName from Customer  c\")\nCollection<CustomerProjection> findAllProjectedBy();\n\n```\n\n#### 3、增加 CustomerController 方法\n\n```java\nCollection<CustomerProjection> projections = repository.findAllProjectedBy();\nSystem.out.println(projections);\nSystem.out.println(projections.size());\nfor (CustomerProjection projection: projections) {\n    System.out.println(\"FullName:\" + projection.getFullName());\n    System.out.println(\"FirstName:\" + projection.getFirstName());\n    System.out.println(\"LastName:\" + projection.getLastName());\n}\n\n```\n\n> [spring-data-examples](https://github.com/spring-projects/spring-data-examples/tree/master/jpa) 中有一些 JPA 的例子可以加强理解。\n\n### 十、数据更新\n\n使用 @Modifying 进行数据更新的方式，这种更新会很不方便，写的时候也比较麻烦，可以为更新密码、更新用户名等一些特殊的更新单独定义，但是对大多数数据操作是不方便的，比如我要更新一条有一百个字段的数据，这时候如果要通过 Modifying 方式就非常的不方便，因此，我们需要一种新的方式来解救。通过阅读 Spring-Data-JPA 相关的文档和博客，找到了对应的解决方案，就是使用`save()`方法，经过测试，可用。\n\n我们平时对`save()`方法的理解，大多是等同于`insert()`，主要是指新增一条数据，而JPA的`save()`方法包含了`merge()`的概念，就是说，如果save的对象不存在primary key或者primary key值在database内不存在的时候会新添加一条数据，如果primary key 存在并且primary key已经在database中存在，那就会依据primary key对该条数据进行更新，这是我们乐意见到的。\n\n### 十一、数据查询(基于 Criteria)\n\n#### 1、定义一个继承 JpaSpecificationExecutor 的接口\n\n```java\npublic interface CustomerSpecificationRepository extends JpaRepository<Customer,Long>, JpaSpecificationExecutor<Customer> {}\n\n```\n\n这里只是为了继承接口声明的方法，包含了常用的查询单个对象，查询数据集合，查询分页数据集合，查询带排序参数的数据集合，查询数据的大小，这些都是常用的数据结果集，因此可以不用做其他定义即可直接使用。\n\n#### 2、创建 SpecificationFactory 工具类\n\n```java\npublic final class SpecificationFactory {\n    public static Specification containsLike(String attribute, String value) {\n        return (root, query, cb) -> cb.like(root.get(attribute), \"%\" + value + \"%\");\n    }\n    public static Specification isBetween(String attribute, int min, int max) {\n        return (root, query, cb) -> cb.between(root.get(attribute), min, max);\n    }\n    public static Specification isBetween(String attribute, double min, double max) {\n        return (root, query, cb) -> cb.between(root.get(attribute), min, max);\n    }\n    public static <T extends Enum <T>> Specification enumMatcher(String attribute, T queriedValue) {\n        return (root, query, cb) - > {\n            Path <T> actualValue = root.get(attribute);\n            if (queriedValue == null) {\n                return null;\n            }\n            return cb.equal(actualValue, queriedValue);\n        };\n    }\n}\n\n```\n\n这个工具类定义了一些基本的查询，包括模糊匹配（containsLike）,数值区间（isBetween）以及枚举类参数匹配（enumMatcher），这些也是在查询中常用的方法，在查询的时候，通过Specifications进行调用组织参数，即可获得接口Specification的实例，然后用于查询。\n\n#### 3、在 CustomerController 中添加方法\n\n```java\n@Autowired\nprivate CustomerSpecificationRepository csr;\n\n// 单一条件查询\nSpecification < Customer > spec = SpecificationFactory.containsLike(\"lastName\", \"bau\");\nPageable pageable = new PageRequest(0, 5, Sort.Direction.DESC, \"id\");\nPage < Customer > page = csr.findAll(spec, pageable);\nSystem.out.println(page);\nSystem.out.println(page.getTotalElements());\nSystem.out.println(page.getTotalPages());\nfor (Customer c: page.getContent()) {\n    System.out.println(c.toString());\n}\n\n// 复合条件查询\nSpecification <Customer> spec2 = Specifications\n    .where(SpecificationFactory.containsLike(\"firstName\", \"bau\"))\n    .or(SpecificationFactory.containsLike(\"lastName\", \"bau\"));\nPageable pageable = new PageRequest(0, 5, Sort.Direction.DESC, \"id\");\nPage <Customer> page = csr.findAll(spec2, pageable);\nSystem.out.println(page);\nSystem.out.println(page.getTotalElements());\nSystem.out.println(page.getTotalPages());\nfor (Customer c: page.getContent()) {\n    System.out.println(c.toString());\n}\n\n```\n\n### 十二、关联对象查询\n\n#### 1、更改 Customer 类\n\n添加 Lombok 依赖（简化对象定义）\n\n```java\n@Entity\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@NamedQuery(name = \"Customer.findByFirstName\", query = \"select c from Customer c where c.firstName = ?1\")\npublic class Customer {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String firstName;\n    private String lastName;\n\n    //一对多，一个客户对应多个订单，关联的字段是订单里的cId字段\n    @OneToMany\n    @JoinColumn(name = \"cId\")\n    private List < MyOrder > myOrders;\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n    @Override\n    public String toString() {\n        return String.format(\n            \"Customer[id=%d, firstName=\'%s\', lastName=\'%s\']\",\n            id, firstName, lastName);\n    }\n}\n\n```\n\n#### 2、增加 MyOrder 类\n\n```java\n@Entity\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class MyOrder {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String code;\n    private Long cId;\n    private BigDecimal total;\n    //实体映射重复列必须设置：insertable = false,updatable = false\n    @OneToOne\n    @JoinColumn(name = \"cId\", insertable = false, updatable = false)\n    private Customer customer;\n    @Override\n    public String toString() {\n        return \"MyOrder{\" +\n            \"id=\" + id +\n            \", code=\'\" + code + \'\\\'\' +\n            \", cId=\" + cId +\n            \", total=\" + total +\n            \", customer=\" + customer +\n            \'}\';\n    }\n}\n\n```\n\n#### 3、增加 MyOrderRepository 类\n\n```java\n// 主要是继承JpaSpecificationExecutor接口，进行Specification查询\npublic interface MyOrderRepository extends JpaSpecificationExecutor<MyOrder>,CrudRepository<MyOrder,Long> {}\n\n\n```\n\n#### 4、新增 ShoppingController 类\n\n```java\n @Controller\n @RequestMapping(\"/shop\")\n public class ShoppingController {\n     @Autowired\n     private MyOrderRepository myOrderRepository;\n     /**\n      * 内连接查询\n      */\n     @RequestMapping(\"/q1\")\n     public void specification1() {\n         //根据查询结果，声明返回值对象，这里要查询用户的订单列表，所以声明返回对象为MyOrder\n         Specification < MyOrder > spec = new Specification < MyOrder > () {\n             //Root<X>  根查询，默认与声明相同\n             @Override\n             public Predicate toPredicate(Root < MyOrder > root, CriteriaQuery < ? > query, CriteriaBuilder cb) {\n                 //声明并创建MyOrder的CriteriaQuery对象\n                 CriteriaQuery < MyOrder > q1 = cb.createQuery(MyOrder.class);\n                 //连接的时候，要以声明的根查询对象（这里是root，也可以自己创建）进行join\n                 //Join<Z,X>是Join生成的对象，这里的Z是被连接的对象，X是目标对象，\n                 //  连接的属性字段是被连接的对象在目标对象的属性，这里是我们在MyOrder内声明的customer\n                 //join的第二个参数是可选的，默认是JoinType.INNER(内连接 inner join)，也可以是JoinType.LEFT（左外连接 left join）\n                 Join < Customer, MyOrder > myOrderJoin = root.join(\"customer\", JoinType.INNER);\n                 //用CriteriaQuery对象拼接查询条件，这里只增加了一个查询条件，cId=1\n                 q1.select(myOrderJoin).where(cb.equal(root.get(\"cId\"), 1));\n                 //通过getRestriction获得Predicate对象\n                 Predicate p1 = q1.getRestriction();\n                 //返回对象\n                 return p1;\n             }\n         };\n         resultPrint(spec);\n     }\n     /**\n      * 增加查询条件，关联的对象Customer的对象值\n      */\n     @RequestMapping(\"/q2\")\n     public void specification2() {\n         Specification < MyOrder > spec = new Specification < MyOrder > () {\n             @Override\n             public Predicate toPredicate(Root < MyOrder > root, CriteriaQuery < ? > query, CriteriaBuilder cb) {\n                 CriteriaQuery < MyOrder > q1 = cb.createQuery(MyOrder.class);\n                 Join < Customer, MyOrder > myOrderJoin = root.join(\"customer\");\n                 q1.select(myOrderJoin)\n                     .where(\n                         cb.equal(root.get(\"cId\"), 1), //cId=1\n                         cb.equal(root.get(\"customer\").get(\"firstName\"), \"Jack\") //对象customer的firstName=Jack\n                     );\n                 Predicate p1 = q1.getRestriction();\n                 return p1;\n             }\n         };\n         resultPrint(spec);\n     }\n     /**\n      * in的条件查询\n      * 需要将对应的结果集以root.get(\"attributeName\").in(Object.. values)的方式传入\n      * values支持多个参数，支持对象（Object），表达式Expression<?>，集合Collection以及Expression<Collection<?>>\n      */\n     @RequestMapping(\"/q3\")\n     public void specification3() {\n         Specification < MyOrder > spec = new Specification < MyOrder > () {\n             @Override\n             public Predicate toPredicate(Root < MyOrder > root, CriteriaQuery < ? > query, CriteriaBuilder cb) {\n                 CriteriaQuery < MyOrder > q1 = cb.createQuery(MyOrder.class);\n                 Join < Customer, MyOrder > myOrderJoin = root.join(\"customer\");\n                 q1.select(myOrderJoin)\n                     .where(\n                         cb.equal(root.get(\"cId\"), 1), root.get(\"id\").in(1, 2, 4)\n                     );\n\n                 Predicate p1 = q1.getRestriction();\n                 return p1;\n             }\n         };\n         resultPrint(spec);\n     }\n     /**\n      * 左外链接查询，对比inner join，\n      * 这里只是改了一个参数，将JoinType.INNER改成JoinType.LEFT\n      *\n      * 注意，当前示例不支持JoinType.RIGHT，用的比较少，没有探究\n      */\n     @RequestMapping(\"/q4\")\n     public void specification4() {\n         Specification < MyOrder > spec = new Specification < MyOrder > () {\n             @Override\n             public Predicate toPredicate(Root < MyOrder > root, CriteriaQuery < ? > query, CriteriaBuilder cb) {\n                 CriteriaQuery < MyOrder > q1 = cb.createQuery(MyOrder.class);\n                 Join < Customer, MyOrder > myOrderJoin = root.join(\"customer\", JoinType.LEFT);\n                 q1.select(myOrderJoin).where(cb.equal(root.get(\"cId\"), 1));\n                 Predicate p1 = q1.getRestriction();\n                 return p1;\n             }\n         };\n         resultPrint(spec);\n     }\n     /***\n      *输出分页信息\n      **/\n     private void resultPrint(Specification < MyOrder > spec) {\n         //分页查询\n         Pageable pageable = new PageRequest(0, 10, Sort.Direction.DESC, \"id\");\n         //查询的分页结果\n         Page < MyOrder > page = myOrderRepository.findAll(spec, pageable);\n         System.out.println(page);\n         System.out.println(page.getTotalElements());\n         System.out.println(page.getTotalPages());\n         for (MyOrder c: page.getContent()) {\n             System.out.println(c.toString());\n         }\n     }\n\n }\n\n```\n\n## 实践\n\n### 一、配置实体类\n\n#### 1、字段类型对应 text\n\n```java\n// 该注解表示该字段是长数据类型的，且默认为 longtext \n@Lob\n// 通过该注解更改字段类型，但一定要是可以映射到 Java 的 String 类型的 sql 类型\n@Column(columnDefinition = \"meduimtext\")\n\n```\n\n#### 2、设置默认值\n\n```java\n// 直接赋值即可。。。\nprivate Integer id = 0;\n\n```\n\n\n\n### 二、配置关系映射\n\n#### 1、一对一配置\n\n#### 2、一对多和多对一配置\n\n以文章和用户的关系为例，用户为一端，文章为多端，一般由多端管理一端。\n\n**User.java**\n\n```java\n// 拥有 mappedBy 的实体类为被维护类\n// mappedBy = \"author\" 中的 author 指的是 article 类中的 author 属性\n// cascade = CascadeType.ALL 表示同步方式为级联保存、更新、删除、刷新\n// fetch = FetchType.LAZY 表示懒加载，默认设置，因此在此处省略\n@OneToMany(mappedBy = \"author\", cascade = CascadeType.ALL)\nprivate List<Article> articles; // 文章列表\n\n```\n\n**Article.java**\n\n```java\n// optional = false 表示该字段不可被忽略\n// JoinColumn 设置 article 表中的外键\n@ManyToOne(cascade = {CascadeType.ALL}, optional = false)\n@JoinColumn(name=\"author\")\nprivate User author;\n\n```\n\n#### 3、多对多配置\n\n以用户和权限的关系为例，一个用户可以有多个权限，一个权限可以属于多个用户。\n\n使用一个关联表来维护多对多关系，关联表的表明默认是：主表名+下划线+从表名（主表是指关系维护端，从表是被维护端）。这个关联表只有两个外键字段，分别指向主表ID和从表ID。字段的名称默认为：主表名+下划线+主表中的主键列名，从表名+下划线+从表中的主键列名。\n\n**注意点：**\n\n1. 多对多关系中一般不设置级联保存、级联删除、级联更新等操作。\n2. 可以随意指定一方为关系维护端，在这个例子中，我指定 User 为关系维护端，所以生成的关联表名称为： `user_authority`，关联表的字段为：`user_id` 和 `authority_id`。\n3. 多对多关系的绑定由关系维护端来完成，即由 `User.setAuthorities(authorities)` 来绑定多对多的关系。关系被维护端不能绑定关系，即Game不能绑定关系。\n4. 多对多关系的解除由关系维护端来完成，即由`Player.getGames().remove(game)`来解除多对多的关系。关系被维护端不能解除关系，即Game不能解除关系。\n5. **如果 User 和 Authority 已经绑定了多对多的关系，那么不能直接删除 Authority**，需要由 User 解除关系后，才能删除 Authority。但是可以直接删除 User，因为 User 是关系维护端，删除 User 时，会先解除 User 和 Authority 的关系，再删除 Authority。\n\n', 0, 'Spring Data JPA 是根据JPA规范而编写的基于Hibernate框架的一个整合。使用它之后，程序员只需要创建数据库的实体类并配置数据库连接，然后通过创建它的数据库实体操作对象dao即可使用。它使用方法名判定的方式自动识别并生成sql语句，极大地简化了常用数据操作。', 'Spring Data JPA', 0, '2019-03-16 15:21:28', 4, 100, 1);
INSERT INTO `article` VALUES (4, '# Vue Router 学习\n\n在我看来，单页面应用中如果框架是一个项目的灵魂的话，那么路由就是它的骨架。\n\n## 一、起步\n\n使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。\n\n#### HTML\n\n```html\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n\n#### JS\n\n```js\n// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\n\n// 1. 定义 (路由) 组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: \'<div>foo</div>\' }\nconst Bar = { template: \'<div>bar</div>\' }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: \'/foo\', component: Foo },\n  { path: \'/bar\', component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // (缩写) 相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  router\n}).$mount(\'#app\')\n\n// 现在，应用已经启动了！\n```\n\n通过注入路由器，我们可以**在任何组件内**通过`this.$router`访问路由器，通过`this.$route`访问当前路由。\n\n一个返回上一级的方法：\n\n```js\nmethods: {\n    goBack () {\n      window.history.length > 1\n        ? this.$router.go(-1)\n        : this.$router.push(\'/\')\n    }\n}\n```\n\n## 二、动态路由匹配\n\n### 1、设置动态路由\n\n一个“路径参数”使用冒号 `:` 标记。当匹配到一个路由时，参数值会被设置到`this.$route.params`，可以在每个组件内使用。\n\n```js\nconst User = {\n  template: \'<div>User {{ $route.params.id }}</div>\'\n}\n\nconst router = new VueRouter({\n  routes: [\n    // 动态路径参数 以冒号开头\n    { path: \'/user/:id\', component: User }\n  ]\n})\n```\n\n> 可以在一个路由中设置多个“路径参数”，对应的值都会映射到`$route.params`中。\n\n### 2、响应路由参数变化\n\n当使用路由参数时，例如从 `/user/foo` 导航到 `/user/bar`，**原来的组件实例会被复用**。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。**不过，这也意味着组件的生命周期钩子不会再被调用**。\n\n复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) `$route` 对象：\n\n```js\nconst User = {\n  template: \'...\',\n  watch: {\n    \'$route\' (to, from) {\n      // 对路由变化作出响应...\n    }\n  }\n}\n\n// 或者使用 beforeRouteUpdate 导航守卫\nconst User = {\n  template: \'...\',\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don\'t forget to call next()\n  }\n}\n```\n\n### 3、通配符路由\n\n使用通配符`*`匹配所有路径:\n\n```js\n{\n  // 会匹配所有路径,常用于客户端 404 错误\n  path: \'*\'\n}\n{\n  // 会匹配以 `/user-` 开头的任意路径\n  path: \'/user-*\'\n}\n```\n\n使用*通配符*路由时，请确保**路由的顺序**是正确的，也就是说含有*通配符*的路由应该放在最后。\n\n> 当使用一个*通配符*时，`$route.params` 内会自动添加一个名为 `pathMatch` 参数。它包含了 URL 通过*通配符*被匹配的部分.\n\n## 三、嵌套路由\n\n一个被渲染组件同样可以包含自己的嵌套 `<router-view>`。\n\n要在嵌套的出口中渲染组件，需要在 `VueRouter` 的参数中使用 `children` 配置：\n\n```js\nconst router = new VueRouter({\n  routes: [\n    { path: \'/user/:id\', component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 <router-view> 中\n          path: \'profile\',\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 <router-view> 中\n          path: \'posts\',\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n```\n\n> 以 / 开头的嵌套路径会被当作根路径。\n\n若在有参数的子路由中配置默认路由，应该定义一个空的子路由。\n\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: \'/user/:id\', component: User,\n      children: [\n        // 当 /user/:id 匹配成功，\n        // UserHome 会被渲染在 User 的 <router-view> 中\n        { path: \'\', component: UserHome },\n\n        // ...其他子路由\n      ]\n    }\n  ]\n})\n```\n\n## 四、编程式导航\n\n#### router.push()\n\n想要导航到不同的 URL，则使用 `router.push` 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。\n\n该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：\n\n```js\n// 字符串\nrouter.push(\'home\')\n\n// 对象\nrouter.push({ path: \'home\' })\n\n// 命名的路由\nrouter.push({ name: \'user\', params: { userId: \'123\' }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: \'register\', query: { plan: \'private\' }})\n\n```\n\n> 如果提供了` path`，`params` 会被忽略，上述例子中的 `query` 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 `name` 或手写完整的带有参数的 `path`：\n\n```js\nconst userId = \'123\'\nrouter.push({ name: \'user\', params: { userId }}) // -> /user/123\nrouter.push({ path: `/user/${userId}` }) // -> /user/123\n// 这里的 params 不生效\nrouter.push({ path: \'/user\', params: { userId }}) // -> /user\n\n```\n\n#### router.replace()\n\n跟 `router.push` 很像，唯一的不同就是，它不会向 history 添加新记录.\n\n#### router.go(n)\n\n这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`。\n\n正数为前进 n 步，负数为后退 n 步。如果 history 记录不够用，就会失败且没有提示。\n\n## 五、命名路由\n\n要链接到一个命名路由，可以给 `router-link` 的 `to` 属性传一个对象：\n\n```html\n<router-link :to=\"{ name: \'user\', params: { userId: 123 }}\">User</router-link>\n\n```\n\n## 六、命名视图\n\n有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 `sidebar` (侧导航) 和 `main` (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 `router-view` 没有设置名字，那么默认为 `default`。\n\n```html\n<router-view class=\"view one\"></router-view>\n<router-view class=\"view two\" name=\"a\"></router-view>\n<router-view class=\"view three\" name=\"b\"></router-view>\n\n```\n\n一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 `components` 配置 (带上 s)：\n\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: \'/\',\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n\n```\n\n## 七、重定向和别名\n\n### 1、重定向\n\n重定向也是通过 `routes` 配置来完成，下面例子是从 `/a` 重定向到 `/b`：\n\n```js\nconst router = new VueRouter({\n  routes: [\n    { path: \'/a\', redirect: \'/b\' }\n  ]\n})\n\n```\n\n重定向的目标也可以是一个命名的路由：\n\n```js\nconst router = new VueRouter({\n  routes: [\n    { path: \'/a\', redirect: { name: \'foo\' }}\n  ]\n})\n\n```\n\n甚至是一个方法，动态返回重定向目标：\n\n```js\nconst router = new VueRouter({\n  routes: [\n    { path: \'/a\', redirect: to => {\n      // 方法接收 目标路由 作为参数\n      // return 重定向的 字符串路径/路径对象\n    }}\n  ]\n})\n\n```\n\n### 3、别名\n\n/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。\n\n```js\nconst router = new VueRouter({\n  routes: [\n    { path: \'/a\', component: A, alias: \'/b\' }\n  ]\n})\n\n```\n\n## 八、路由组件传参\n\n在组件中使用 `$route` 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。\n\n原来：\n\n```js\nconst User = {\n  template: \'<div>User {{ $route.params.id }}</div>\'\n}\nconst router = new VueRouter({\n  routes: [\n    { path: \'/user/:id\', component: User }\n  ]\n})\n\n```\n\n**通过 props 解耦**\n\n```js\nconst User = {\n  props: [\'id\'],\n  template: \'<div>User {{ id }}</div>\'\n}\nconst router = new VueRouter({\n  routes: [\n    { path: \'/user/:id\', component: User, props: true },\n\n    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：\n    {\n      path: \'/user/:id\',\n      components: { default: User, sidebar: Sidebar },\n      props: { default: true, sidebar: false }\n    }\n  ]\n})\n\n```\n\n如果 `props` 被设置为 `true`，`route.params` 将会被设置为组件属性。\n\n## 九、HTML5 History 模式\n\n`vue-router` 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。\n\n当你使用 history 模式时，URL 就像正常的 url。\n\n不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 `http://oursite.com/user/id`就会返回 404，这就不好看了。\n\n所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 `index.html` 页面，这个页面就是你 app 依赖的页面。\n\n#### 后端配置示例\n\n**Apache**\n\n```text\n<IfModule mod_rewrite.c>\n  RewriteEngine On\n  RewriteBase /\n  RewriteRule ^index\\.html$ - [L]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteRule . /index.html [L]\n</IfModule>\n\n```\n\n**nginx**\n\n```nginx\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n\n```\n\n**原生 nodejs**\n\n```js\nconst http = require(\'http\')\nconst fs = require(\'fs\')\nconst httpPort = 80\n\nhttp.createServer((req, res) => {\n  fs.readFile(\'index.htm\', \'utf-8\', (err, content) => {\n    if (err) {\n      console.log(\'We cannot open \"index.htm\" file.\')\n    }\n\n    res.writeHead(200, {\n      \'Content-Type\': \'text/html; charset=utf-8\'\n    })\n\n    res.end(content)\n  })\n}).listen(httpPort, () => {\n  console.log(\'Server listening on: http://localhost:%s\', httpPort)\n})\n\n```\n\n**IIS**\n\n1. 安装 [IIS UrlRewrite](https://www.iis.net/downloads/microsoft/url-rewrite)\n2. 在你的网站根目录中创建一个 `web.config` 文件，内容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n  <system.webServer>\n    <rewrite>\n      <rules>\n        <rule name=\"Handle History Mode and custom 404/500\" stopProcessing=\"true\">\n          <match url=\"(.*)\" />\n          <conditions logicalGrouping=\"MatchAll\">\n            <add input=\"{REQUEST_FILENAME}\" matchType=\"IsFile\" negate=\"true\" />\n            <add input=\"{REQUEST_FILENAME}\" matchType=\"IsDirectory\" negate=\"true\" />\n          </conditions>\n          <action type=\"Rewrite\" url=\"/\" />\n        </rule>\n      </rules>\n    </rewrite>\n  </system.webServer>\n</configuration>\n\n```\n\n#### 前端应做的事\n\n这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 `index.html` 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。\n\n```js\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [\n    { path: \'*\', component: NotFoundComponent }\n  ]\n})\n\n```\n\n或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。更多详情请查阅 [Vue 服务端渲染文档](https://ssr.vuejs.org/zh/)\n\n## 十、导航守卫\n\n`vue-router` 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。\n\n> 参数或查询的改变并不会触发进入/离开的导航守卫。\n\n### 1、全局前置守卫\n\n使用 `router.beforeEach` 注册一个全局前置守卫：\n\n```js\nconst router = new VueRouter({ ... })\n\nrouter.beforeEach((to, from, next) => {\n  // ...\n})\n\n```\n\n当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 **等待中**。\n\n每个守卫方法接收三个参数：\n\n- **to: Route**: 即将要进入的目标 [路由对象](https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1)\n- **from: Route**: 当前导航正要离开的路由\n- **next: Function**: 一定要调用该方法来 **resolve** 这个钩子。执行效果依赖 `next`方法的调用参数。\n  - **next()**: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 **confirmed** (确认的)。\n  - **next(false)**: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。\n  - **next(\'/\') 或者 next({ path: \'/\' })**: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 `next` 传递任意位置对象，且允许设置诸如 `replace: true`、`name: \'home\'` 之类的选项以及任何用在 [`router-link` 的 `to` prop](https://router.vuejs.org/zh/api/#to) 或 [`router.push`](https://router.vuejs.org/zh/api/#router-push) 中的选项。\n  - **next(error)**: (2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 [`router.onError()`](https://router.vuejs.org/zh/api/#router-onerror) 注册过的回调。\n\n**确保要调用 next 方法，否则钩子就不会被 resolved。**\n\n### 2、全局后置钩子\n\n可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身：\n\n```js\nrouter.afterEach((to, from) => {\n  // ...\n})\n\n```\n\n### 3、路由独享的守卫\n\n可以在路由配置上直接定义 `beforeEnter` 守卫：\n\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: \'/foo\',\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n\n```\n\n### 4、组件内守卫\n\n你可以在路由组件内直接定义以下路由导航守卫：\n\n- `beforeRouteEnter`\n- `beforeRouteUpdate` (2.2 新增)\n- `beforeRouteLeave`\n\n```js\nconst Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}\n\n```\n\n`beforeRouteEnter` 守卫 **不能** 访问 `this`，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。\n\n不过，你可以通过传一个回调给 `next`来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。\n\n```js\nbeforeRouteEnter (to, from, next) {\n  next(vm => {\n    // 通过 `vm` 访问组件实例\n  })\n}\n\n```\n\n注意 `beforeRouteEnter` 是支持给 `next` 传递回调的唯一守卫。对于 `beforeRouteUpdate` 和 `beforeRouteLeave` 来说，`this` 已经可用了，所以**不支持**传递回调，因为没有必要了。\n\n```js\nbeforeRouteUpdate (to, from, next) {\n  // just use `this`\n  this.name = to.params.name\n  next()\n}\n\n```\n\n这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 `next(false)` 来取消。\n\n```js\nbeforeRouteLeave (to, from , next) {\n  const answer = window.confirm(\'Do you really want to leave? you have unsaved changes!\')\n  if (answer) {\n    next()\n  } else {\n    next(false)\n  }\n}\n\n```\n\n### 5、完整的导航解析流程\n\n1. 导航被触发。\n2. 在失活的组件里调用离开守卫。\n3. 调用全局的 `beforeEach` 守卫。\n4. 在重用的组件里调用 `beforeRouteUpdate` 守卫 (2.2+)。\n5. 在路由配置里调用 `beforeEnter`。\n6. 解析异步路由组件。\n7. 在被激活的组件里调用 `beforeRouteEnter`。\n8. 调用全局的 `beforeResolve` 守卫 (2.5+)。\n9. 导航被确认。\n10. 调用全局的 `afterEach` 钩子。\n11. 触发 DOM 更新。\n12. 用创建好的实例调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数。\n\n## 十一、路由元信息\n\n定义路由的时候可以配置 `meta` 字段：\n\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: \'/foo\',\n      component: Foo,\n      children: [\n        {\n          path: \'bar\',\n          component: Bar,\n          // a meta field\n          meta: { requiresAuth: true }\n        }\n      ]\n    }\n  ]\n})\n\n```\n\n那么如何访问这个 `meta` 字段呢？\n\n首先，我们称呼 `routes` 配置中的每个路由对象为 **路由记录**。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录\n\n例如，根据上面的路由配置，`/foo/bar` 这个 URL 将会匹配父路由记录以及子路由记录。\n\n一个路由匹配到的所有路由记录会暴露为 `$route` 对象 (还有在导航守卫中的路由对象) 的 `$route.matched` 数组。因此，我们需要遍历 `$route.matched` 来检查路由记录中的 `meta` 字段。\n\n下面例子展示在全局导航守卫中检查元字段：\n\n```js\nrouter.beforeEach((to, from, next) => {\n  if (to.matched.some(record => record.meta.requiresAuth)) {\n    // this route requires auth, check if logged in\n    // if not, redirect to login page.\n    if (!auth.loggedIn()) {\n      next({\n        path: \'/login\',\n        query: { redirect: to.fullPath }\n      })\n    } else {\n      next()\n    }\n  } else {\n    next() // 确保一定要调用 next()\n  }\n})\n\n```\n\n## 十二、过渡动效\n\n`<router-view>` 是基本的动态组件，所以我们可以用 `<transition>` 组件给它添加一些过渡效果：\n\n```html\n<transition>\n  <router-view></router-view>\n</transition>\n\n```\n\n[Transition 的所有功能](https://cn.vuejs.org/guide/transitions.html) 在这里同样适用。\n\n### 1、单个路由的过渡\n\n上面的用法会给所有路由设置一样的过渡效果，如果你想让每个路由组件有各自的过渡效果，可以在各路由组件内使用 `<transition>` 并设置不同的 name。\n\n```js\nconst Foo = {\n  template: `\n    <transition name=\"slide\">\n      <div class=\"foo\">...</div>\n    </transition>\n  `\n}\n\nconst Bar = {\n  template: `\n    <transition name=\"fade\">\n      <div class=\"bar\">...</div>\n    </transition>\n  `\n}\n\n```\n\n### 2、基于路由的动态过渡\n\n还可以基于当前路由与目标路由的变化关系，动态设置过渡效果：\n\n```html\n<!-- 使用动态的 transition name -->\n<transition :name=\"transitionName\">\n  <router-view></router-view>\n</transition>\n// 接着在父组件内\n// watch $route 决定使用哪种过渡\nwatch: {\n  \'$route\' (to, from) {\n    const toDepth = to.path.split(\'/\').length\n    const fromDepth = from.path.split(\'/\').length\n    this.transitionName = toDepth < fromDepth ? \'slide-right\' : \'slide-left\'\n  }\n}\n\n```\n\n## 十三、数据获取\n\n有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：\n\n- **导航完成之后获取**：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。\n- **导航完成之前获取**：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。\n\n从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。\n\n### 1、导航完成之后获取\n\n当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 `created` 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。\n\n假设我们有一个 `Post` 组件，需要基于 `$route.params.id` 获取文章数据：\n\n```js\n<template>\n  <div class=\"post\">\n    <div class=\"loading\" v-if=\"loading\">\n      Loading...\n    </div>\n\n    <div v-if=\"error\" class=\"error\">\n      {{ error }}\n    </div>\n\n    <div v-if=\"post\" class=\"content\">\n      <h2>{{ post.title }}</h2>\n      <p>{{ post.body }}</p>\n    </div>\n  </div>\n</template>\nexport default {\n  data () {\n    return {\n      loading: false,\n      post: null,\n      error: null\n    }\n  },\n  created () {\n    // 组件创建完后获取数据，\n    // 此时 data 已经被 observed 了\n    this.fetchData()\n  },\n  watch: {\n    // 如果路由有变化，会再次执行该方法\n    \'$route\': \'fetchData\'\n  },\n  methods: {\n    fetchData () {\n      this.error = this.post = null\n      this.loading = true\n      // replace getPost with your data fetching util / API wrapper\n      getPost(this.$route.params.id, (err, post) => {\n        this.loading = false\n        if (err) {\n          this.error = err.toString()\n        } else {\n          this.post = post\n        }\n      })\n    }\n  }\n}\n\n```\n\n### 2、导航完成前获取\n\n通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的`beforeRouteEnter` 守卫中获取数据，当数据获取成功后只调用 `next` 方法。\n\n```js\nexport default {\n  data () {\n    return {\n      post: null,\n      error: null\n    }\n  },\n  beforeRouteEnter (to, from, next) {\n    getPost(to.params.id, (err, post) => {\n      next(vm => vm.setData(err, post))\n    })\n  },\n  // 路由改变前，组件就已经渲染完了\n  // 逻辑稍稍不同\n  beforeRouteUpdate (to, from, next) {\n    this.post = null\n    getPost(to.params.id, (err, post) => {\n      this.setData(err, post)\n      next()\n    })\n  },\n  methods: {\n    setData (err, post) {\n      if (err) {\n        this.error = err.toString()\n      } else {\n        this.post = post\n      }\n    }\n  }\n}\n\n```\n\n在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。\n\n## 十四、滚动行为\n\n> 这个功能只在支持 history.pushState 的浏览器中可用。\n\n当创建一个 Router 实例，你可以提供一个 `scrollBehavior` 方法：\n\n```js\nconst router = new VueRouter({\n  routes: [...],\n  scrollBehavior (to, from, savedPosition) {\n    // return 期望滚动到哪个的位置\n  }\n})\n\n```\n\n`scrollBehavior` 方法接收 `to` 和 `from` 路由对象。第三个参数 `savedPosition`当且仅当 `popstate` 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。\n\n这个方法返回滚动位置的对象信息，长这样：\n\n- `{ x: number, y: number }`\n- `{ selector: string, offset? : { x: number, y: number }}` (offset 只在 2.6.0+ 支持)\n\n如果返回一个 falsy (译者注：falsy 不是 `false`，[参考这里](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy))的值，或者是一个空对象，那么不会发生滚动。\n\n举例：\n\n```js\nscrollBehavior (to, from, savedPosition) {\n  return { x: 0, y: 0 }\n}\n\n```\n\n对于所有路由导航，简单地让页面滚动到顶部。\n\n返回 `savedPosition`，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：\n\n```js\nscrollBehavior (to, from, savedPosition) {\n  if (savedPosition) {\n    return savedPosition\n  } else {\n    return { x: 0, y: 0 }\n  }\n}\n\n```\n\n如果你要模拟“滚动到锚点”的行为：\n\n```js\nscrollBehavior (to, from, savedPosition) {\n  if (to.hash) {\n    return {\n      selector: to.hash\n    }\n  }\n}\n\n```\n\n我们还可以利用[路由元信息](https://router.vuejs.org/zh/guide/advanced/meta.html)更细颗粒度地控制滚动。查看完整例子请[移步这里](https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js)。\n\n## 十五、路由懒加载\n\n结合 Vue 的[异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6)和 Webpack 的[代码分割功能](https://doc.webpack-china.org/guides/code-splitting-async/#require-ensure-/)，轻松实现路由组件的懒加载。\n\n首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：\n\n```js\nconst Foo = () => Promise.resolve({ /* 组件定义对象 */ })\n\n```\n\n第二，在 Webpack 2 中，我们可以使用[动态 import](https://github.com/tc39/proposal-dynamic-import)语法来定义代码分块点 (split point)：\n\n```js\nimport(\'./Foo.vue\') // 返回 Promise\n\n```\n\n> 如果您使用的是 Babel，你将需要添加 [`syntax-dynamic-import`](https://babeljs.io/docs/plugins/syntax-dynamic-import/) 插件，才能使 Babel 可以正确地解析语法。\n\n结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。\n\n```js\nconst Foo = () => import(\'./Foo.vue\')\n\n```\n\n在路由配置中什么都不需要改变，只需要像往常一样使用 `Foo`：\n\n```js\nconst router = new VueRouter({\n  routes: [\n    { path: \'/foo\', component: Foo }\n  ]\n})\n\n```', 0, 'Vue Router 是基于 Vuejs 的前端路由框架，在开发大型应用中比较常用。', 'Vue Router 学习', 0, '2019-03-16 15:28:43', 5, 100, 2);
INSERT INTO `article` VALUES (5, '# Markdig库使用记录\n\n众里寻他千百度，我是一个喜欢用他人的轮子的人。最近准备写一个Windows平台的Markdown编辑器，技术上选择了wpf平台，但在寻找markdown解析器的路上真的是纠结了好久，因为没有找到合适的Markdown编辑器的库，只能退而求其次使用Markdown解析库，于是乎找到了Markdig这个库，看到上面与其他解析器的对比后决定使用该库。\n\n因为这只是一个将Markdown格式解析为HTML格式的库，因此还需要一个显示HTML格式的控件，但在wpf上的选择似乎并不多。我尝试去安装了`Jumony Core`库，结果发现根本不知道要怎么使用。那么剩余的方案也并没有太多了，wpf的WebBrowser不支持直接导入HTML以及使用CSS和js，而使用WinForm的控件的话也不知道后续会有什么问题，于是我暂时看中了专门为Markdig设计的`Markdig-wpf`这个库，下载后试运行发现显示效果还可以，因此打算先使用这两个库来开发，下面记录将这两个库导入到我的项目的过程。\n\n## 安装\n\n在Visual Studio中安装库文件真的是非常简单的事情，右键解决方案下面的引用，选择管理Nuget程序包，然后搜索需要的库并安装即可。\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-4/56736446.jpg)\n\n## 使用\n\nMarkdig-wpf共有两个控件，目前我只理解了第一种方式的显示方法，在此只演示第一种的使用方法。\n\n在Xaml文件中，我只将必须的内容写出来以供参考。\n\n```\n<!--命名空间中导入Markdig.Wpf控件-->\n<Window xmlns:markdig=\"clr-namespace:Markdig.Wpf;assembly=Markdig.Wpf\"\n  Title=\"MainWindow\">\n  <FrameworkElement.CommandBindings>\n  <!--打开超链接的命令-->\n    <CommandBinding Command=\"{x:Static markdig:Commands.Hyperlink}\" Executed=\"OpenHyperlink\" />\n  </FrameworkElement.CommandBindings>\n  <DockPanel>\n  <!--该按钮不是必须的，默认即打开拓展功能-->\n    <Button x:Name=\"ToggleExtensionsButton\" DockPanel.Dock=\"Top\" HorizontalAlignment=\"Center\"\n            Content=\"Toggle supported extensions\" Click=\"ToggleExtensionsButton_OnClick\" />\n    <!--该控件为显示Markdown的组件，必须要声明-->\n    <markdig:MarkdownViewer x:Name=\"Viewer\"/>\n  </DockPanel>\n</Window>\n```\n\n在CS文件中从文件中加载Markdown格式的文本并处理打开超链接的操作。\n\n```\npublic partial class MainWindow : Window\n    {\n      // 若不切换拓展状态，则可以删掉该字段\n        private bool useExtensions = true;\n\n        public MainWindow()\n        {\n            InitializeComponent();\n            Loaded += OnLoaded; // 设置界面加载完毕后的处理程序\n        }\n\n        private void OnLoaded(object sender, RoutedEventArgs e)\n        {\n          // 为显示Markdown的组件赋值Markdown格式的内容\n            Viewer.Markdown = File.ReadAllText(\"Documents/Markdig-readme.md\");\n        }\n\n        private void OpenHyperlink(object sender, System.Windows.Input.ExecutedRoutedEventArgs e)\n        {\n          // 监听打开超链接的动作，打开浏览器\n            Process.Start(e.Parameter.ToString());\n        }\n\n\n        // 该步骤不是必须的\n        private void ToggleExtensionsButton_OnClick(object sender, RoutedEventArgs e)\n        {\n            useExtensions = !useExtensions;\n            Viewer.Pipeline = useExtensions ? new MarkdownPipelineBuilder().UseSupportedExtensions().Build() : new MarkdownPipelineBuilder().Build();\n        }\n    }\n```\n\n中间的内容即为Markdown显示的内容，自此表示已成功应用两个库。\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-4/31951843.jpg)', 0, '.NET开发中使用的Markdown 解析器。', 'Markdig 使用', 0, '2019-03-16 15:30:45', 0, 100, NULL);
INSERT INTO `article` VALUES (6, '# MS/WPF-Samples/Clipboard源码分析\n\n最近打算自己开发一款Windows平台的软件，但查看相关文档之后仍对一些功能不够熟练，偶然间发现Github上有微软官方发布的实例代码，故打算研究研究这些代码弄懂WPF平台上开发的一些细节问题。\n\n我决定随缘研究这些代码，毕竟有这么多，就先挑自己觉得有用的、用得上的示例来研究好了。\n\n> 附上项目下载地址，大家可以下载后参照着来看：[WPF-Samples](https://github.com/Microsoft/WPF-Samples)\n\n## ClipboardViewer\n\n在Clipboard目录下共有两个示例项目，先分析这个剪切板查看器，运行后的界面如下：\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-5/36863276.jpg)\n\n可以看到界面中大体上就是显示及设置剪切板内容和格式的功能，Xaml代码看了看有些冗长，而且基本上就是普通的布局，甚至连数据绑定都没有，因此直接对c#代码进行分析。\n\n```\npublic partial class MainWindow : Window\n{\n    public MainWindow()\n    {\n        InitializeComponent();\n    }\n\n    // This is called when UI is laid out, rendered and ready for interaction.\n    private void WindowLoaded(object sender, RoutedEventArgs args)\n    {\n        // Check the current Clipboard data format status\n        RefreshClipboardDataFormat();\n\n        // Set the text copy information on RichTextBox\n        SetTextOnRichTextBox(\"Please type clipboard copy data here!\");\n    }\n\n	// Update the data format status and describe all available data formats\n    private void RefreshClipboardDataFormat()\n    {\n        clipboardInfo.Clear();\n\n        lbPasteDataFormat.Items.Clear();\n\n        var dataObject = GetDataObjectFromClipboard();\n\n        if (dataObject == null)\n        {\n            clipboardInfo.Text = \"Can\'t access clipboard now! Please click Refresh button again.\";\n        }\n        else\n        {\n            // Check the data format whether it is on Clipboard or not\n            cbAudio.IsChecked = dataObject.GetDataPresent(DataFormats.WaveAudio);\n            cbFileDropList.IsChecked = dataObject.GetDataPresent(DataFormats.FileDrop);\n            cbImage.IsChecked = dataObject.GetDataPresent(DataFormats.Bitmap);\n            cbText.IsChecked = dataObject.GetDataPresent(DataFormats.Text);\n            cbRtf.IsChecked = dataObject.GetDataPresent(DataFormats.Rtf);\n            cbXaml.IsChecked = dataObject.GetDataPresent(DataFormats.Xaml);\n\n            // Update the data format into the information panel\n            UpdateAvailableDataFormats(dataObject);\n        }\n    }\n\n	// Set the plain text on RichTextBox\n    private void SetTextOnRichTextBox(string text)\n    {\n        var document = richTextBox.Document;\n        var textRange = new TextRange(document.ContentStart, document.ContentEnd) {Text = text};\n        richTextBox.Focus();\n        richTextBox.SelectAll();\n    }\n}\n```\n\n以上代码中，构造函数没什么说的。但是`WindowLoaded`函数则让我有些疑惑，我明明没有在构造函数中添加Loaded事件，而且在`Window`类中也并无与Load相关的事件。于是我在这个方法内部加了断点发现果然在窗口加载完毕也就是弹出窗口但内容却一片空白的情况下执行到了断点处，那么这应该就涉及到窗口的生命周期的问题了。\n\n![Window生命周期图](https://docs.microsoft.com/en-us/dotnet/framework/wpf/app-development/media/windowlifetimeevents.png)\n\n看了一下官方文档，又回头看了看Window类的方法，这个Loaded方法到底去哪儿了呢？\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-5/67863246.jpg)\n\n终于，查阅API文档，发现它是继承了`FrameworkElement`,在该类的Loaded方法描述中我发现了同样的一句话:\n\n> Occurs when the element is laid out, rendered, and ready for interaction.\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-5/85443311.jpg)\n\n那么就是它了，但还有一个问题，不同名的函数为什么可以调用呢？\n\n首先我注意到了`RoutedEventArgs`这个类型的参数，我想是不是参数不同导致系统可以直接识别这个方法就是执行到Loaded之后用户想要运行的方法呢？但我观察其他事件接收函数也同样是这个类型的参数，那系统还怎么识别呢？但我还抱有侥幸心理，于是。。。\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-5/4782830.jpg)\n\n我只是改了一下名字而已，三个错误。。那也就排除了系统可以识别参数的选项，同时似乎也说明了这是系统内置的方法名，但我又一次翻看系统API，还是没有找到该方法名。\n\n再次阅读该错误，说是MainWindow没有WindowLoaded的定义，那就是说有这个声明了。果然，在Xaml中发现了这个声明。。。哎，自作聪明。。\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-5/49473160.jpg)\n\n好了，虽然绕了一大圈，但终究解决了疑问并且学到了知识不是么，下面正式进入主题。可以看到在Loaded方法中首先检查了剪切板中数据的格式，然后在富文本编辑框中输入提示信息，下面先分析`RefreshClipboardDataFormat`方法。\n\n1、`clipboardInfo`是界面中右上方的显示剪切板内容的一大块文本框的name，清空它的内容。\n\n2、`lbPasteDataFormat`是Paste(Get) Format:下面显示剪切板所含对象的列表，清空所有项目。\n\n3、`GetDataObjectFromClipboard`方法从剪切版中获取所含数据的对象\n\n```\n// Get DataObject from the system clipboard\nprivate IDataObject GetDataObjectFromClipboard()\n{\n    IDataObject dataObject;\n\n    try\n    {\n        dataObject = Clipboard.GetDataObject();\n    }\n    catch (COMException)\n    {\n        // Clipboard.GetDataObject can be failed by opening the system clipboard \n        // from other or processing clipboard operation like as setting data on clipboard\n        dataObject = null;\n    }\n\n    return dataObject;\n}\n```\n\n该方法从剪切板获取数据并返回。注意到该方法的返回值为`IDataObject`,该接口为Windows下面的，那应该是系统为我们定义接口。\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-5/76418524.jpg)\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-5/11588511.jpg)\n\n4、根据从剪切板获取的数据设置界面中左上角多选框的状态，其中`DataFormates`类提供了一组预定义数据格式名\n\n|        字段         |          字段值           | 描述                                            |\n| :-----------------: | :-----------------------: | :---------------------------------------------- |\n|       Bitmap        |         \"Bitmap\"          | 指定 Microsoft Windows 位图数据格式。           |\n| CommaSeparatedValue |           \"CSV\"           | 指定以逗号分隔的值 (CSV) 数据格式。             |\n|         Dib         | \"DeviceIndependentBitmap\" | 指定与设备无关位图 (DIB) 数据格式。             |\n|         Dif         |  \"DataInterchangeFormat\"  | 指定 Windows 数据交换格式 (DIF) 数据格式。      |\n|  EnhancedMetafile   |    \"EnhancedMetafile\"     | 指定 Windows 增强型图元文件格式。               |\n|      FileDrop       |        \"FileDrop\"         | 指定 Windows 文件放置格式。                     |\n|        Html         |       \"HTML Format\"       | 指定 HTML 数据格式。                            |\n|       Locale        |        \"区域设置\"         | 指定 Windows 区域设置（区域性）数据格式。       |\n|   MetafilePicture   |      \"MetaFilePict\"       | 指定 Windows 图元文件图片数据格式。             |\n|       OemText       |         \"OEMText\"         | 指定标准 Windows OEM 文本数据格式。             |\n|       Palette       |         \"Palette\"         | 指定 Windows 调色板数据格式。                   |\n|       PenData       |         \"PenData\"         | 指定 Windows 钢笔数据格式。                     |\n|        Riff         |        \"RiffAudio\"        | 指定 资源交换文件格式 (RIFF) 音频数据格式。     |\n|         Rtf         |      \"丰富文本格式\"       | 指定 RTF 格式 (RTF) 数据格式。                  |\n|    Serializable     |    \"PersistentObject\"     | 指定封装任何类型的可序列化数据对象的数据格式。  |\n|    StringFormat     |      \"System.String\"      | 指定 公共语言运行时 (CLR) 字符串类数据格式。    |\n|    SymbolicLink     |      \"SymbolicLink\"       | 指定 Windows 符号链接数据格式。                 |\n|        Text         |          \"Text\"           | 指定 ANSI 文本数据格式。                        |\n|        Tiff         |  \"TaggedImageFileFormat\"  | 指定 标记图像文件格式 (TIFF) 数据格式。         |\n|     UnicodeText     |       \"UnicodeText\"       | 指定 Unicode 文本数据格式。                     |\n|      WaveAudio      |        \"WaveAudio\"        | 指定波形音频数据格式。                          |\n|        Xaml         |          \"Xaml\"           | 指定 可扩展应用程序标记语言 (XAML) 数据格式。   |\n|     XamlPackage     |       \"XamlPackage\"       | 指定 可扩展应用程序标记语言 (XAML) 包数据格式。 |\n\n5、更新格式信息到信息面板当中，此时调用了`UpdateAvailableDataFormats`方法，方法很简单，没有需要说明的地方。\n\n```\n// Update and describe all available data formats\nprivate void UpdateAvailableDataFormats(IDataObject dataObject)\n{\n    clipboardInfo.AppendText(\"Clipboard DataObject Type: \");\n    clipboardInfo.AppendText(dataObject.GetType().ToString());\n\n    clipboardInfo.AppendText(\"\\n\\n****************************************************\\n\\n\");\n\n    var formats = dataObject.GetFormats();\n\n    clipboardInfo.AppendText(\n        \"The following data formats are present in the data object obtained from the clipboard:\\n\");\n\n    if (formats.Length > 0)\n    {\n        foreach (var format in formats)\n        {\n            bool nativeData;\n            if (dataObject.GetDataPresent(format, false))\n            {\n                nativeData = true;\n                clipboardInfo.AppendText(\"\\t- \" + format + \" (native)\\n\");\n            }\n            else\n            {\n                nativeData = false;\n                clipboardInfo.AppendText(\"\\t- \" + format + \" (autoconvertable)\\n\");\n            }\n\n            if (nativeData)\n            {\n                lbPasteDataFormat.Items.Add(format);\n            }\n            else if ((bool) cbAutoConvertibleData.IsChecked)\n            {\n                lbPasteDataFormat.Items.Add(format);\n            }\n        }\n\n        lbPasteDataFormat.SelectedIndex = 0;\n    }\n    else\n    {\n        clipboardInfo.AppendText(\"\\t- no data formats are present\\n\");\n    }\n}\n```\n\nLoaded的第一步分析完了，第二步就是把提示文字（纯文本）设置到富文本框并全选方便用户直接粘贴。\n\n```\n// Set the plain text on RichTextBox\nprivate void SetTextOnRichTextBox(string text)\n{\n    var document = richTextBox.Document;\n    var textRange = new TextRange(document.ContentStart, document.ContentEnd) {Text = text};\n    richTextBox.Focus();\n    richTextBox.SelectAll();\n}\n```\n\n### 小结\n\n以上操作中与剪切板有关的操作只有`Clipboard.GetDataObject`，该方法返回的`IDataObject`对象我们需要有一定的了解。\n\n剩下的代码我针对较为重要的进行分析。\n\n```\nClipboard.Clear();	// 清空剪切板\n\nprivate object GetDataFromDataObject(IDataObject dataObject, string dataFormat, bool autoConvert)\n{\n    object data = null;\n\n    try\n    {\n        data = dataObject.GetData(dataFormat, autoConvert);\n     }\n    catch (COMException)\n    {\n        // Fail to get the data by the invalid value like tymed(DV_E_TYMED) \n        // or others(Aspect, Formatetc).\n        // It depends on application\'s IDataObject::GetData implementation.\n        clipboardInfo.AppendText(\"Fail to get data!!! ***COMException***\");\n    }\n    catch (OutOfMemoryException)\n    {\n        // Fail by the out of memory from getting data on Clipboard. \n        // Occurs with the low memory.\n        clipboardInfo.AppendText(\"Fail to get data!!! ***OutOfMemoryException***\");\n    }\n\n    return data;\n}\n```\n\n上面的方法是从`IDataObject`接口的对象中获取真正的对象，可能会，方法为`dataObject.GetData(dataFormat, autoConvert);`,可能会因为值不合法或者内存过低而引发异常，因此需要对其捕获异常。\n\n```\nclipboardInfo.AppendText(data?.ToString() ?? \"null\");\n```\n\n上面的代码是某个方法里面的一句，这种写法引起了我的关注。\n\n> 可空类型修饰符（？）：引用类型可以使用空引用表示一个不存在的值，而值类型通常不能表示为空。\n>\n> 例如：string str=null; 是正确的，int i=null; 编译器就会报错。\n> 为了使值类型也可为空，就可以使用可空类型，即用可空类型修饰符\"？\"来表示，表现形式为\"T？\"\n> 例如：int? 表示可空的整形，DateTime? 表示可为空的时间。\n>\n> T? 其实是System.Nullable(泛型结构）的缩写形式，也就意味着当你用到T？时编译器编译 时会把T？编译成System.Nullable的形式。\n> 例如：int?,编译后便是System.Nullable的形式。\n\n> 空合并运算符(??)：\n> 用于定义可空类型和引用类型的默认值。如果此运算符的左操作数不为null，则此运算符将返回左操作数，否则返回右操作数。\n>\n> 例如：a??b 当a为null时则返回b，a不为null时则返回a本身。\n> 空合并运算符为右结合运算符，即操作时从右向左进行组合的。如，“a??b??c”的形式按“a??(b??c)”计算。\n\n```\n// Get text data string from RichTextBox content which encoded as UTF8\nprivate string GetTextStringFromRichTextBox(string dataFormat)\n{\n    var document = richTextBox.Document;\n    var textRange = new TextRange(document.ContentStart, document.ContentEnd);\n\n    if (dataFormat == DataFormats.Text)\n    {\n         return textRange.Text;\n    }\n    Stream contentStream = new MemoryStream();\n    textRange.Save(contentStream, dataFormat);\n\n    if (contentStream.Length > 0)\n    {\n        var bytes = new byte[contentStream.Length];\n\n        contentStream.Position = 0;\n        contentStream.Read(bytes, 0, bytes.Length);\n\n        var utf8Encoding = Encoding.UTF8;\n\n        return utf8Encoding.GetString(bytes);\n    }\n\n    return null;\n}\n```\n\n以上代码的功能是从将富文本格式的内容转换为纯文本内容，逻辑上分为两个部分，如果需要转换的内容已经是纯文本，就直接返回，否则进行转换后返回。\n\n第一部分需要记住的点是从富文本框中获取纯文本使用的`TextRange.Text`属性。第二部分就是真正的转换纯文本的操作了，先用指定格式将富文本框中的内容转换为流，然后以UTF-8的格式读取字符并返回。\n\n```\n// Set the selected data format\'s data from RichTextBox\'s content \n// into DataObject for copying data on the system clipboard\nprivate void CopyDataFromRichTextBox(IDataObject dataObject)\n{\n    if ((bool) cbCopyTextDataFormat.IsChecked)\n    {\n        var textData = GetTextStringFromRichTextBox(DataFormats.Text);\n        if (textData != string.Empty)\n        {\n            dataObject.SetData(DataFormats.Text, textData);\n        }\n    }\n\n    if ((bool) cbCopyXamlDataFormat.IsChecked)\n    {\n        var textData = GetTextStringFromRichTextBox(DataFormats.Xaml);\n        if (textData != string.Empty)\n        {\n            dataObject.SetData(DataFormats.Xaml, textData);\n        }\n    }\n\n    if ((bool) cbCopyRtfDataFormat.IsChecked)\n    {\n        var textData = GetTextStringFromRichTextBox(DataFormats.Rtf);\n        if (textData != string.Empty)\n        {\n            dataObject.SetData(DataFormats.Rtf, textData);\n        }\n    }\n\n    // Finally, consider a custom, application defined format.\n    // We use an arbitrary encoding here, for demonstration purposes.\n    if ((bool) cbCustomSampleDataFormat.IsChecked)\n    {\n        Stream customStream = new MemoryStream();\n\n        var textData = \"This is Custom Sample Data Start\\n\\n\" +\n                       GetTextStringFromRichTextBox(DataFormats.Text) +\n                       \"\\nCustom Sample Data End.\";\n\n        var bytesUnicode = Encoding.Unicode.GetBytes(textData);\n        var bytes = Encoding.Convert(Encoding.Unicode, Encoding.UTF8, bytesUnicode);\n\n        if (bytes.Length > 0)\n        {\n            customStream.Write(bytes, 0, bytes.Length);\n            dataObject.SetData(\"CustomSample\", customStream);\n        }\n    }\n}\n\n// Set the selected data format\'s data from the file content \n// into DataObject for copying data on the system clipboard\nprivate void CopyDataFromFile(IDataObject dataObject)\n{\n    string fileName = null;\n\n    var dialog = new OpenFileDialog {CheckFileExists = true};\n\n    if ((bool) cbCopyTextDataFormat.IsChecked)\n    {\n        dialog.Filter = \"Plain Text (*.txt)|*.txt\";\n        dialog.ShowDialog();\n        fileName = dialog.FileName;\n\n        if (string.IsNullOrEmpty(fileName))\n        {\n            return;\n        }\n\n        var fileEncoding = Encoding.Default;\n        var textData = GetTextStringFromFile(fileName, fileEncoding);\n        if (!string.IsNullOrEmpty(textData))\n        {\n            dataObject.SetData(DataFormats.Text, textData);\n        }\n    }\n\n    if ((bool) cbCopyRtfDataFormat.IsChecked)\n    {\n        fileName = null;\n        dialog.Filter = \"RTF Documents (*.rtf)|*.rtf\";\n        dialog.ShowDialog();\n        fileName = dialog.FileName;\n\n        if (string.IsNullOrEmpty(fileName))\n        {\n            return;\n        }\n\n        var fileEncoding = Encoding.ASCII;\n        var textData = GetTextStringFromFile(fileName, fileEncoding);\n        if (!string.IsNullOrEmpty(textData))\n        {\n            dataObject.SetData(DataFormats.Rtf, textData);\n        }\n    }\n\n    if ((bool) cbCopyXamlDataFormat.IsChecked)\n    {\n        fileName = null;\n        dialog.Filter = \"XAML Flow Documents (*.xaml)|*.xaml\";\n        dialog.ShowDialog();\n        fileName = dialog.FileName;\n\n        if (string.IsNullOrEmpty(fileName))\n        {\n            return;\n        }\n\n        var fileEncoding = Encoding.UTF8;\n        var textData = GetTextStringFromFile(fileName, fileEncoding);\n        if (!string.IsNullOrEmpty(textData))\n        {\n            dataObject.SetData(DataFormats.Xaml, textData);\n        }\n    }\n\n    // Finally, consider a custom, application defined format.\n    // We use an arbitrary encoding here, for demonstartion purposes.\n    if ((bool) cbCustomSampleDataFormat.IsChecked)\n    {\n        fileName = null;\n        dialog.Filter = \"All Files (*.*)|*.*\";\n        dialog.ShowDialog();\n        fileName = dialog.FileName;\n\n        if (string.IsNullOrEmpty(fileName))\n        {\n            return;\n        }\n\n        var fileEncoding = Encoding.UTF8;\n        var textData = GetTextStringFromFile(fileName, fileEncoding);\n        if (string.IsNullOrEmpty(textData)) return;\n        var bytesUnicode = Encoding.Unicode.GetBytes(textData);\n        var bytes = Encoding.Convert(Encoding.Unicode, Encoding.UTF8, bytesUnicode);\n\n        if (bytes.Length > 0)\n        {\n            var customStream = new MemoryStream();\n            customStream.Write(bytes, 0, bytes.Length);\n            dataObject.SetData(\"CustomSample\", customStream);\n        }\n    }\n}\n\nprivate void CopyToClipboard(object sender, RoutedEventArgs args)\n{\n    var dataObject = new DataObject();\n\n    // Copy data from RichTextBox/File content into DataObject\n    if ((bool) rbCopyDataFromRichTextBox.IsChecked)\n    {\n        CopyDataFromRichTextBox(dataObject);\n    }\n    else\n    {\n        CopyDataFromFile(dataObject);\n    }\n\n    // Copy DataObject on the system Clipboard\n    if (dataObject.GetFormats().Length > 0)\n    {\n        if ((bool) cbFlushOnCopy.IsChecked)\n        {\n            // Copy data to the system clipboard with flush\n            Clipboard.SetDataObject(dataObject, true /*copy*/);\n        }\n        else\n        {\n            // Copy data to the system clipboard without flush\n            Clipboard.SetDataObject(dataObject, false /*copy*/);\n        }\n    }\n\n            // Dump the copied data contents on the information panel\n    DumpAllClipboardContentsInternal();\n}\n```\n\n前面两个方法分别从富文本框和文件去读取数据，从而将数据赋值到`IDataObject`对象中的。最后一个方法将得到的数据设置到剪切板上，其中还展示了如何自定义格式并粘贴到剪切板的方法。`Clipboard.SetDataObject`方法将指定的数据对象置于系统剪贴板中，并接受一个布尔参数，该参数指示应用程序退出时是否将数据对象保留在剪贴板中。\n\n```\n// Paste a selected paste data format\'s data to RichTextBox\nprivate void PasteClipboardDataToRichTextBox(string dataFormat, IDataObject dataObject, bool autoConvert)\n{\n    if (dataObject != null && dataObject.GetFormats().Length > 0)\n    {\n        var pasted = false;\n\n        if (dataFormat == DataFormats.Xaml)\n        {\n            var xamlData = dataObject.GetData(DataFormats.Xaml) as string;\n            if (!string.IsNullOrEmpty(xamlData))\n            {\n			pasted = PasteTextDataToRichTextBox(DataFormats.Xaml, xamlData);\n            }\n        }\n        else if (dataFormat == DataFormats.Rtf)\n        {\n            var rtfData = dataObject.GetData(DataFormats.Rtf) as string;\n            if (!string.IsNullOrEmpty(rtfData))\n            {\n                pasted = PasteTextDataToRichTextBox(DataFormats.Rtf, rtfData);\n            }\n        }\n        else if (dataFormat == DataFormats.UnicodeText\n                 || dataFormat == DataFormats.Text\n                 || dataFormat == DataFormats.StringFormat)\n        {\n            var textData = dataObject.GetData(dataFormat) as string;\n            if (textData != string.Empty)\n            {\n                SetTextOnRichTextBox(textData);\n                pasted = true;\n            }\n        }\n        else if (dataFormat == \"CustomSample\")\n        {\n            // Paste the application defined custom data format\'s data to RichTextBox content\n            var customStream = dataObject.GetData(dataFormat, autoConvert) as Stream;\n            if (customStream.Length > 0)\n            {\n                var textRange = new TextRange(richTextBox.Document.ContentStart,\n                    richTextBox.Document.ContentEnd);\n                textRange.Load(customStream, DataFormats.Text);\n                pasted = true;\n            }\n        }\n\n        if (!pasted)\n        {\n            MessageBox.Show(\n                \"Can\'t paste the selected data format into RichTextBox!\\n\\nPlease click Refresh button to update the current clipboard format Or select File RadioButton to paste data.\",\n                \"Paste Data Format Error\",\n                MessageBoxButton.OK,\n                MessageBoxImage.Exclamation);\n        }\n    }\n}\n\n// Paste a selected paste data format\'s data to the fileSSS\nprivate void PasteClipboardDataToFile(string dataFormat, IDataObject dataObject, bool autoConvert)\n{\n    var dialog = new SaveFileDialog {CheckFileExists = false};\n\n    if (dataFormat == DataFormats.Text\n        || dataFormat == DataFormats.UnicodeText\n        || dataFormat == DataFormats.StringFormat)\n    {\n        dialog.Filter = \"Plain Text (*.txt)|*.txt | All Files (*.*)|*.*\";\n    }\n    else if (dataFormat == DataFormats.Xaml)\n    {\n        dialog.Filter = \"XAML Flow Documents (*.xaml)|*.xaml | All Files (*.*)|*.*\";\n    }\n    else if (dataFormat == DataFormats.Rtf)\n    {\n        dialog.Filter = \"RTF Documents (*.rtf)|*.rtf | All Files (*.*)|*.*\";\n    }\n    else\n    {\n        dialog.Filter = \"All Files (*.*)|*.*\";\n    }\n\n    if (!(bool) dialog.ShowDialog())\n    {\n        return;\n    }\n\n    var fileName = dialog.FileName;\n\n    if (dataFormat == DataFormats.Xaml)\n    {\n        var xamlData = dataObject.GetData(DataFormats.Xaml) as string;\n        if (!string.IsNullOrEmpty(xamlData))\n        {\n            PasteTextDataToFile(dataFormat, xamlData, fileName, Encoding.UTF8);\n        }\n    }\n    else if (dataFormat == DataFormats.Rtf)\n    {\n        var rtfData = dataObject.GetData(DataFormats.Rtf) as string;\n        if (!string.IsNullOrEmpty(rtfData))\n        {\n            PasteTextDataToFile(dataFormat, rtfData, fileName, Encoding.ASCII);\n        }\n    }\n            else if (dataFormat == DataFormats.UnicodeText\n             || dataFormat == DataFormats.Text\n             || dataFormat == DataFormats.StringFormat)\n    {\n        var textData = dataObject.GetData(dataFormat, autoConvert) as string;\n        if (!string.IsNullOrEmpty(textData))\n        {\n            PasteTextDataToFile(dataFormat, textData, fileName,\n                dataFormat == DataFormats.Text ? Encoding.Default : Encoding.Unicode);\n        }\n    }\n    else\n    {\n        // Paste the CustomSample data or others to the file\n        //Stream customStream = dataObject.GetData(dataFormat, autoConvert) as Stream;\n        var customStream = GetDataFromDataObject(dataObject, dataFormat, autoConvert) as Stream;\n        if (customStream != null && customStream.Length > 0)\n        {\n            PasteStreamDataToFile(customStream, fileName);\n        }\n    }\n}\n		// Paste text data on RichTextBox as UTF8 encoding\nprivate bool PasteTextDataToRichTextBox(string dataFormat, string textData)\n{\n    var pasted = false;\n\n    var document = richTextBox.Document;\n    var textRange = new TextRange(document.ContentStart, document.ContentEnd);\n\n    Stream stream = new MemoryStream();\n\n    var bytesUnicode = Encoding.Unicode.GetBytes(textData);\n    var bytes = Encoding.Convert(Encoding.Unicode, Encoding.UTF8, bytesUnicode);\n\n    if (bytes.Length > 0 && textRange.CanLoad(dataFormat))\n    {\n        stream.Write(bytes, 0, bytes.Length);\n        textRange.Load(stream, dataFormat);\n        pasted = true;\n    }\n\n    return pasted;\n}\n\n// Paste text data to the file with the file encoding\nprivate void PasteTextDataToFile(string dataFormat, string textData, string fileName, Encoding fileEncoding)\n{\n    FileStream fileWriteStream;\n\n    try\n    {\n        fileWriteStream = new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.Write);\n    }\n    catch (IOException)\n    {\n        MessageBox.Show(\"File is not acessible.\\n\", \"File Write Error\");\n        return;\n    }\n\n    fileWriteStream.SetLength(0);\n\n    var bytesUnicode = Encoding.Unicode.GetBytes(textData);\n    var bytes = Encoding.Convert(Encoding.Unicode, fileEncoding, bytesUnicode);\n\n    if (bytes.Length > 0)\n    {\n        fileWriteStream.Write(bytes, 0, bytes.Length);\n    }\n\n    fileWriteStream.Close();\n}\n\n// Paste stream data to the file\nprivate void PasteStreamDataToFile(Stream stream, string fileName)\n{\n    FileStream fileWriteStream = null;\n\n    try\n    {\n        fileWriteStream = new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.Write);\n    }\n    catch (IOException)\n    {\n        MessageBox.Show(\"File is not acessible.\\n\", \"File Write Error\");\n    }\n\n    fileWriteStream.SetLength(0);\n\n    var bytes = new byte[stream.Length];\n\n    stream.Position = 0;\n    stream.Read(bytes, 0, bytes.Length);\n\n    if (bytes.Length > 0)\n    {\n        fileWriteStream.Write(bytes, 0, bytes.Length);\n    }\n\n    fileWriteStream.Close();\n}\n```\n\n上面是将剪切板内容粘贴到富文本框或文件中的方法。\n\n![](http://bobo-image.oss-cn-beijing.aliyuncs.com/18-12-5/23850233.jpg)', 0, '在学习.NET 框架时对官方示例代码的研究。', 'Microsoft ClipBoard 源码分析', 0, '2019-03-16 15:32:27', 0, 100, NULL);
INSERT INTO `article` VALUES (7, '用 Echarts 之前以为官方的文档做的很差，太难读，但认真做完一个表格后发现真香，在这里总结一下实现什么效果要去查询哪个配置项的配置。\n\n![](https://i.loli.net/2019/02/20/5c6d1f7accc69.jpg)\n\n## Option 子节点介绍\n\n打开[官网的配置项文档](https://echarts.baidu.com/option.html#title)，即可看到 option 下所有的子节点，在此介绍自己用到过的属性。\n\n| 属性名          | 作用                                             |\n| --------------- | ------------------------------------------------ |\n| color           | 调色盘颜色列表，数组格式，显示为数据项的背景颜色 |\n| backgroundColor | 整个图表的背景颜色                               |\n| textStyle       | 全局的字体样式配置                               |\n| title           | 图表的标题配置                                   |\n| legend          | 图例组件配置                                     |\n| grid            | 仅适用于直角坐标系的绘图网格配置                 |\n| xAis            | X轴配置                                          |\n| yAis            | Y轴配置                                          |\n| series          | 系列列表，每个数据项及其样式配置                 |\n\n> 颜色可以使用#FFFFFF 格式或者rgb()或者argb()格式，只需要加上单引号即可。\n\n### 一、X、Y 轴配置（xAis、yAis）\n\n#### 1、不显示坐标轴刻度线\n\n```js\naxisTick: {\n	show: false\n}\n```\n\n#### 2、坐标轴轴线配置\n\n```js\naxisLine: {\n	lineStyle: {\n		color: \'rgb(217, 216, 219)\'\n	}\n}\n```\n\n#### 3、坐标轴单位配置\n\n```js\nname: \'单位(万)\',\nnameTextStyle: {\n	fontWeight: \'bold\',\n	fontSize: 14,\n	align: \'right\'\n},\n// 还有 nameLocation,nameGap,nameRotate 可以配置\n```\n\n#### 4、坐标轴标签名配置\n\n```js\naxisLabel: {\n	color: \'rgb(202, 199, 202)\'，\n    inside: false // 标签是否朝内，默认朝外\n},\n```\n\n#### 5、坐标轴分割线配置(在图表内显示的)\n\n```js\nsplitLine: {\n	lineStyle: {\n		color: \'rgb(251, 249, 252)\'\n	}\n}\n```\n\n#### 6、不显示Y轴0刻度\n\n```js\nscale: true,\n```\n\n#### 7、控制数值轴间距\n\n==这个值是数值之差而不是标签间距==\n\n```js\nsplitNumber: 5\n```\n\n\n\n\n\n### 二、绘图区域配置（grid）\n\n#### 1、绘图区域和边界的距离\n\n```js\nleft: 0,\nright: 0,\n// 同时可以使用百分比来指定\ncontainLabel: true, // 是否包含标签区域\n```\n\n\n\n### 三、数据列表配置（series）\n\n#### 1、设置柱状图宽度\n\n```js\ntype: \'bar\',\nbarWidth: 20\n```\n\n#### 2、设置项目的样式\n\n```js\nitemStyle: {\n    // 正常显示时的样式\n    normal: {\n        // 设置柱状图圆角效果，分别设置上方和下方的圆角大小，亦可为单个数值，\n        barBorderRadius: [10, 10, 0, 0],\n        // 设置每个项目的数据值\n        label: {\n            show: true, //开启显示\n            position: \'top\', //在上方显示\n            distance: 10, // 距离柱状图的距离\n            textStyle: { //数值样式\n                color: \'#FFFFFF\',\n                fontSize: 14\n            },\n            borderRadius: 5,\n            backgroundColor: \'#4DD7CB\',\n            padding: [5, 10, 5, 10],\n            shadowColor: \'#4DD7CB\',\n            shadowBlur: 15,\n            shadowOffsetY: 3\n        }\n    },\n    // 高亮显示时的样式\n    emphasis: {\n        barBorderRadius: [10, 10, 0, 0]\n    },\n},\n```\n\n', 0, 'Echarts是Web端最常用的图表显示框架，可以实现各种各样的效果。', 'Echarts 图表库的使用', 0, '2019-03-16 15:34:20', 0, 100, NULL);
INSERT INTO `article` VALUES (8, '## Babel 使用\n\n[Babel](https://babeljs.io)是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。\n\n### 配置文件 `.babelrc`\n\n该文件存放于项目的根目录下，用于设置转码规则和插件，基本格式如下：\n\n```js\n{\n  \"presets\": [],\n  \"plugins\": []\n}\n```\n\n`presets`字段设置转码规则，官方提供以下规则：\n\n```sh\n# ES2015转码规则\n$ npm install --save-dev babel-preset-es2015\n\n# react转码规则\n$ npm install --save-dev babel-preset-react\n\n# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个\n$ npm install --save-dev babel-preset-stage-0\n$ npm install --save-dev babel-preset-stage-1\n$ npm install --save-dev babel-preset-stage-2\n$ npm install --save-dev babel-preset-stage-3\n```\n\n## 变量的解构赋值\n\n只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值\n\n```js\nvar [v1, v2, ..., vN ] = array;\nlet [v1, v2, ..., vN ] = array;\nconst [v1, v2, ..., vN ] = array;\n```\n\n### 一、不同类型的解构赋值\n\n#### 1、数组的解构赋值\n\n```js\n// 一维数组\nvar [a, b, c] = [1, 2, 3];\n// n维数组\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = [\'a\'];\nx // \"a\"\ny // undefined\nz // []\n```\n\n> 如果解构不成功，变量的值就变为 undefined\n\n在等号左边可以用下面方式声明默认值，但默认值只有在变量值严格等于 undefined 时才会生效\n\n```js\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError\n```\n\n#### 2、对象的解构赋值\n\n对象的解构赋值是按照属性名来对应的，因此属性名要完全与右边的属性名对应。\n\n```js\n// 属性顺序不一致时依旧可以取到值\nvar { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\n// 当属性名和对象名不一致时的写法\nvar { foo: baz } = { foo: \'aaa\', bar: \'bbb\' };\nbaz // \"aaa\"\n\n// 嵌套解构的对象的解构赋值方法\nlet obj = {};\nlet arr = [];\n\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\n\nobj // {prop:123}\narr // [true]\n```\n\n#### 3、字符串的解构赋值\n\n字符串解构赋值时，实际上是将字符串转换为类似数组的对象\n\n```js\nconst [a, b, c, d, e] = \'hello\';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n\n// 类似数组的对象都有 length 属性\nlet {length : len} = \'hello\';\nlen // 5\n```\n\n#### 4、数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。\n\n```js\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n```\n\n上面代码中，数值和布尔值的包装对象都有`toString`属性，因此变量`s`都能取到值。\n\n> 解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。\n\n#### 5、函数参数的解构赋值\n\n```javascript\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n// 实际上就等同于 let [x, y] = [1, 2]\n```\n\n### 二、解构赋值的用途\n\n#### 1、交换变量的值\n\n```js\n[x, y] = [y, x]\n```\n\n#### 2、接收函数返回的多个值\n\n```js\nfunction example() {\n  return [1, 2, 3];\n}\nvar [a, b, c] = example();\n```\n\n#### 3、定义函数参数\n\n```js\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n```\n\n#### 4、提取 json 数据\n\n```js\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet { id, status, data: number } = jsonData;\n```\n\n#### 5、定义函数参数的默认值\n\n```javascript\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n}) {\n  // ... do stuff\n};\n```\n\n#### 6、遍历 map 结构\n\n```javascript\n// 获取键名和键值\nvar map = new Map();\nmap.set(\'first\', \'hello\');\nmap.set(\'second\', \'world\');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n```\n\n#### 7、加载模块指定方法\n\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n## 函数的扩展\n\n### 一、函数默认值\n\n```javascript\nfunction log(x, y = \'World\') {\n  console.log(x, y);\n}\n\nlog(\'Hello\') // Hello World\nlog(\'Hello\', \'China\') // Hello China\nlog(\'Hello\', \'\') // Hello\n\n```\n\n同时函数默认值还可以和解构赋值结合使用。\n\n函数默认值的位置一定要在参数列表的最后，这样才能在使用该函数时省略。\n\n> 函数的 length 属性的返回值不会计算有默认值的参数\n\n### 二、rest 参数\n\n用于获取函数的多余参数，搭配的变量是一个数组，该变量将多余的参数放入数组中，利用 rest 参数，可以向该函数中传入任意数目的参数。\n\n```javascript\nfunction add(...values) {\n  let sum = 0;\n\n  for (var val of values) {\n    sum += val;\n  }\n\n  return sum;\n}\n\nadd(2, 5, 3) // 10\n\n```\n\n### 三、扩展运算符\n\n相当于 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于**函数调用**。\n\n#### 扩展运算符的应用\n\n##### 1、合并数组\n\n```javascript\nvar arr1 = [\'a\', \'b\'];\nvar arr2 = [\'c\'];\nvar arr3 = [\'d\', \'e\'];\n[...arr1, ...arr2, ...arr3]\n// [ \'a\', \'b\', \'c\', \'d\', \'e\' ]\n\n```\n\n##### 2、与解构赋值结合生成数组\n\n```javascript\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []:\n\n```\n\n##### 3、直接使用函数返回的多个值\n\n```javascript\n// 从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。\nvar dateFields = readDateFields(database);\nvar d = new Date(...dateFields);\n\n```\n\n##### 4、将字符串转换为数组\n\n```javascript\n[...\'hello\']\n// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n\n```\n\n> 实现了 Iterator 接口的对象均可采用该方法转换为数组。\n\n### 四、箭头函数\n\n## Module\n\n ES6 模块是编译时加载，自动采用严格模式。\n\n### 一、export 命令\n\n#### 1、导出变量\n\n```javascript\n// 第一种写法\nexport var firstName = \'Michael\';\nexport var lastName = \'Jackson\';\nexport var year = 1958;\n// 第二种写法（优先使用该方法）\nvar firstName = \'Michael\';\nvar lastName = \'Jackson\';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n\n```\n\n#### 2、导出函数或类\n\n```javascript\nexport function multiply(x, y) {\n  return x * y;\n};\n\n```\n\n#### 3、重命名\n\n```javascript\nfunction v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n\n```\n\n#### 4、默认导出\n\n其他模块加载该模块时，`import`命令可以为该匿名函数指定任意名字。\n\n一个模块只能有一个默认输出，因此`import`命令后面，**不使用大括号**。\n\n```javascript\n// 导出匿名函数\nexport default function () {\n  console.log(\'foo\');\n}\n// 导出非匿名函数\nexport default function foo() {\n  console.log(\'foo\');\n}\n\n```\n\n> `foo`函数的函数名`foo`，在模块外部是无效的。加载的时候，视同匿名函数加载。\n\n### 二、import 命令\n\n#### 1、载入模块\n\n```javascript\nimport {firstName, lastName, year} from \'./profile\';\n\n```\n\n> `import`后面的`from`指定模块文件的位置，可以是相对路径，也可以是绝对路径，`.js`路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。\n\n#### 2、重命名\n\n```javascript\nimport { lastName as surname } from \'./profile\';\n\n```\n\n#### 3、整体加载\n\n```javascript\nimport * as circle from \'./circle\';\n\n```\n\n#### 4、同时输入默认方法和其他变量\n\n```javascript\nimport _, { each } from \'lodash\';\n\n```\n\n### 三、复合写法\n\n在一个模块之中，先输入后输出同一个模块\n\n```javascript\nexport { foo, bar } from \'my_module\';\n\n```\n\n### 四、跨模块常量\n\n如果要使用的常量非常多，可以建一个专门的`constants`目录，将各种常量写在不同的文件里面，保存在该目录下\n\n```javascript\n// constants/db.js\nexport const db = {\n  url: \'http://my.couchdbserver.local:5984\',\n  admin_username: \'admin\',\n  admin_password: \'admin password\'\n};\n\n// constants/user.js\nexport const users = [\'root\', \'admin\', \'staff\', \'ceo\', \'chief\', \'moderator\'];\n\n```\n\n然后，将这些文件输出的常量，合并在`index.js`里面。\n\n```javascript\n// constants/index.js\nexport {db} from \'./db\';\nexport {users} from \'./users\';\n\n```\n\n使用的时候，直接加载`index.js`就可以了。\n\n```javascript\n// script.js\nimport {db, users} from \'./constants\';\n\n```', 0, 'ES6 即 ECAM Script 2015，它在以往 JavaScript 的基础上引入了类的概念，使得开发大型Web应用变得更具有工程化。', 'ES 6 学习', 0, '2019-03-16 15:37:10', 0, 100, NULL);
INSERT INTO `article` VALUES (9, '# SpringBoot 学习\n\n## 环境配置\n\n- jdk1.8以上\n- maven3.x以上\n- Idea\n- Spring Boot 1.5.9\n\n## maven 设置\n\n 在 maven 安装目录的 `settings.xml` 中配置`<profiles>`节点：\n\n```xml\n<profiles>\n	<profile>\n		<id>jdk-1.8</id>\n		<activation>\n			<maven.compile.source>1.8</maven.compile.source>\n			<maven.compile.target>1.8</maven.compile.target>\n<maven.compile.compileVersion>1.8</maven.compile.compileVersion>\n		</activation>\n	</profile>\n</profiles>\n```\n\n## Idea 设置\n\n依次进入 Settings => Build,Execution,Deployment => Build Tools => Maven => Maven home directory,选择自己安装的 Maven，并勾选下面两个 Override 以使用自己的配置文件。\n\n> 第一个选择刚才更改过的 `settings.xml` 文件，第二个如果 maven 目录下没有 `repository`目录的话就自己新建一个并选择。\n\n## Hello World\n\n### 1、创建 maven 工程\n\n创建时选中 maven 即可，不需要使用 Idea 提供的模版，后面的`groupId`是域名，`artifact`*可能*是项目名。\n\n项目创建完成后会在右下角弹出一个提示`Maven projects needs to be imported`，此时应该点击`Enable Auto-Import`。\n\n### 2、导入 Spring Boot 相关依赖\n\n在 `pom.xml`中进行如下配置：\n\n```xml\n<!-- Inherit defaults from Spring Boot -->\n	<parent>\n		<groupId>org.springframework.boot</groupId>\n		<artifactId>spring-boot-starter-parent</artifactId>\n		<version>2.1.2.RELEASE</version>\n	</parent>\n\n	<!-- Add typical dependencies for a web application -->\n	<dependencies>\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-starter-web</artifactId>\n		</dependency>\n	</dependencies>\n\n```\n\n### 3、编写主程序启动 Spring Boot 应用\n\n```java\n// 该注解告诉 Spring Boot 这是一个主程序类\n@SpringBootApplication\npublic class HelloWorldMainApplication {\n\n    public static void main(String[] args) {\n        // 启动 Spring Boot 应用\n        SpringApplication.run(HelloWorldMainApplication.class,args);\n    }\n\n}\n```\n\n### 4、编写相关的 Service、Controller\n\n```java\n@Controller\npublic class HelloController {\n\n    @ResponseBody\n    @RequestMapping(\"/hello\")\n    public String hello(){\n        return \"hello world\";\n    }\n\n}\n```\n\n项目的结构如图所示：\n\n![](https://www.z4a.net/images/2019/01/21/Snipaste_2019-01-21_20-36-05.png)\n\n### 5、启动测试\n\n进入本地回环地址进行测试，默认进入错误界面。\n\n![](https://www.z4a.net/images/2019/01/21/image791ef0b3a1670e11.md.png)\n\n进入刚刚配置的接口地址，可以正常访问。\n\n![](https://www.z4a.net/images/2019/01/21/image0be2b6fce5e48a8a.png)\n\n### 6、添加打包插件（简化部署）\n\n在 `pom.xml`中增加如下配置：\n\n```xml\n<!-- Package as an executable jar -->\n	<build>\n		<plugins>\n			<plugin>\n				<groupId>org.springframework.boot</groupId>\n				<artifactId>spring-boot-maven-plugin</artifactId>\n			</plugin>\n		</plugins>\n	</build>\n```\n\n之后在 Idea 右边栏打开  maven project，在 `lifecycle`中运行 package 方法进行打包。打包之后的 jar 包存放在 `target`目录中，可以使用`java -jar`命令运行生成的 jar 包。\n\n## 分析 POM 文件\n\n### 1、查看项目的父项目\n\nSpring Boot 作为版本仲裁中心，使得开发者不再需要写其他依赖项目的版本。（如果 Spring Boot 的`dependencies`中没有的依赖仍然需要声明版本号）\n\n```xml\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.2.RELEASE</version>\n</parent>\n\n点进 spring-boot-starter-parent 可以看到依旧依赖了父项目：\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-dependencies</artifactId>\n        <version>2.1.2.RELEASE</version>\n        <relativePath>../../spring-boot-dependencies</relativePath>\n</parent>\n\n进去之后可以看到有很多依赖的版本号配置：\n<activemq.version>5.15.8</activemq.version>\n<antlr2.version>2.7.7</antlr2.version>\n<appengine-sdk.version>1.9.71</appengine-sdk.version>\n<artemis.version>2.6.3</artemis.version>\n<aspectj.version>1.9.2</aspectj.version>\n<assertj.version>3.11.1</assertj.version>\n<atomikos.version>4.0.6</atomikos.version>\n<bitronix.version>2.1.4</bitronix.version>\n...\n```\n\n\n\n### 2、启动器\n\n`spring-boot-starter`叫 Spring Boot 场景启动器，在 Spring Boot 官方有很多的启动器可以选择，最基本的是 web，还有很多，以下只是其中一部分：\n\n![](https://www.z4a.net/images/2019/01/21/image2601ca2745aa0d91.md.png)\n\nSpring Boot 将所有的功能都抽取出来，做成一个个的 starter（启动器），只需要在项目中引入这些 starter，相关场景的所有依赖就会导入进来。\n\n### 3、入口文件、主程序类\n\n```java\n@SpringBootApplication:标注在某个类上，告诉 Spring Boot 应该运行这个类的 main 方法来启动 Spring Boot 应用。\n\n// 点开该类可以看到该注解是个组合注解\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\n```\n\n**@SpringBootConfiguration**:标注在某个类上，表示这是一个 Spring Boot 的配置类。其中**@Configuration**来标注这个注解，这个配置类也是容器中的一个组件，上面有**@Component**的注解。\n\n**@EnableAutoConfiguration**:开启自动配置功能：\n\n```java\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n```\n\n**@AutoConfigurationPackage**:自动配置包\n\n将主配置类（@SpringBootApplication 标注的类）所在包及下面所有子包的所有组件扫描到 Spring 容器。\n\n**@Import({Registrar.class})**:Spring 的底层注解 @import ，给容器导入一个组件\n\n![](https://www.z4a.net/images/2019/01/21/image48ddeb9cf2d33161.md.png)\n\n![](https://www.z4a.net/images/2019/01/21/imagebc79d16d430ebf7d.md.png)\n\n所有的自动配置都在`spring-boot-autoconfigure.jar`包下。\n\n### 4、使用 Spring Initializr 快速创建 Spring Boot 应用\n\n更改需要更改的部分：\n\n![](https://www.z4a.net/images/2019/01/22/image.md.png)\n\n在下一步中勾选需要添加的模块，项目创建完成后删除不必须的文件。\n\n![](https://www.z4a.net/images/2019/01/22/image39a8c42f9ccd07ba.png)\n\n创建 Controller:\n\n```java\n@Controller\npublic class WeChatController {\n    \n    // @ResponseBody 表明该方法可以返回给浏览器，当后续开发时大部分都是返回 json 数据时可以将这个注解加在类前面，表示该类的方法都返回\n    // json 数据，同时也可以替换类前面的 @Controller 注解为 @RestController 注解来达到一致的效果。\n    @ResponseBody\n    @RequestMapping(\"/wx\")\n    public String wx(){\n        return \"this is a test massage.\";\n    }\n    \n}\n```\n\n运行测试。\n\n### Spring Boot 的 resource 目录结构：\n\n- static 存放静态资源，如 js、img、css等\n- templates 存放模版资源\n- application.properties 存放Spring Boot 的配置文件\n\n> Spring Boot 由于采用嵌入式 Tomcat，因此默认不支持 JSP 渲染，可以使用模版引擎，如 freemarker、thymeleaf。\n\n# Spring Boot 配置文件\n\n## 一、全局配置文件（名称固定）\n\n- application.properties\n- application.yml\n\n配置文件用于修改 Spring Boot 自动配置的默认值。\n\n> *.yml 文件是 YAML 格式的文件，YAML 既是也不是标记语言。它以数据为中心，比 json、xml 更适合作为配置文件。\n\n配置对比：\n\nYAML:\n\n```yaml\nserver:\n	port: 8081\n```\n\nXML:\n\n```xml\n<server>\n	<port>8081</port>\n</server>\n```\n\n可以发现 YAML 少了大量的标签的闭合，使得配置更加简洁。\n\n## 二、YAML 语法\n\n### 1、基本语法\n\n表示属性与值的关系：\n\n- k: v 表示一对键值对（v 前面必须要有空格）\n- 以空格的缩进来控制层级关系。\n- 属性和值是大小写敏感的。\n\n### 2、值的写法\n\n字面量：普通的值（数字、字符串、布尔值）\n\nk: v 字面量直接写，且字符串默认不用加上单引号或双引号。\n\n> 引号有特殊的含义：\n>\n> 单引号：不会转义字符串里面的特殊字符，特殊字符会作为本身想展示的意思。\n>\n> 双引号：会转义字符串里的特殊字符。\n\n对象、Map（属性和值）：\n\n```yaml\nPerson:\n	name: zhangsan\n	age: 15\n```\n\n行内写法：\n\n```yaml\nPerson: {name: zhangsan,age: 15}\n```\n\n数组（List、Set）：\n\n用`-`值表示数组中的一个元素：\n\n```yaml\npets:\n - cat\n - dog\n - pig\n```\n\n行内写法：\n\n```yaml\npets: [cat,dog,pig]\n```\n\n### 3、配置文件注入\n\n在`application.yml`中配置 Person 对象的一些属性。\n\n> 如果配置成功，当光标在一个类的属性上时，编辑器下方会显示当前行的信息。\n>\n> ![](https://www.z4a.net/images/2019/01/22/imagef597a9e98db63568.md.png)\n\n在 bean 包下新建一个 Person 类并写上相关属性和 get 、set 、toString 方法，然后在类的上面写上注解：\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person{}\n// @ConfigurationProperties 表示将该类的值与配置文件中的值自动绑定\n// 此时在 application.yml 中会提示没有配置文件加载器，点击提示打开官方文档，将以下代码添加到 maven 中。\n// 添加完成后重新运行该项目，之后即可使用 yml 文件的自动提示功能和元数据映射。\n// 同样也可以用 Spring 原生的注解 @Value 来获取值，但 @Value 只能一个一个地绑定到属性上，相对来说比较繁琐。但支持 Spring 的 el 表达式语言。\n```\n\n```xml\n<!- 将以下配置导入 maven -->\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-configuration-processor</artifactId>\n	<optional>true</optional>\n</dependency>\n\n```\n\n### 4、单元测试\n\n使用 test 目录下面的文件进行单元测试，具体使用见下面代码：\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Helloworld01quickApplicationTests {\n\n	@Autowired\n	Person person;\n\n	@Test\n	public void contextLoads() {\n		System.out.println(person);\n	}\n\n}\n\n```\n\n![](https://www.z4a.net/images/2019/01/22/imagefc692c099a73b1a2.png)\n\n### 5、数据校验\n\nJSR303 数据校验：\n\n类前加 @Validated 注解，属性前加 @Email 注解。\n\n### 6、@Value 和@ConfigurationProperties 比较\n\n|                 | @Value | @Configuration |\n| --------------- | ------ | -------------- |\n| JSR303校验      | 不支持 | 支持           |\n| 松散绑定        | 不支持 | 支持           |\n| Spring EL表达式 | 支持   | 不支持         |\n| 复杂类型封装    | 不支持 | 支持           |\n\n使用 @Value：在某个业务逻辑获取配置文件中的某项值。\n\n使用 @ConfigurationProperties：使用 JavaBean 映射配置文件时。\n\n### 7、@PropertySource 和 @ImportResource\n\n**@PropertySource**：与 @ConfigurationProperties 类似，不过它是加载指定的配置文件。\n\n```java\n@PropertySource(value={\"classpath:person.properties\"})\n\n```\n\n**@ImportResource**:加载配置文件到 Spring 或其他框架。\n\n用法：将该注解标注在一个配置类上，使用 `location`指定配置文件所在路径。\n\n> Spring Boot 推荐使用全注解的方式给容器添加组件。\n\n创建`config`包，新建配置类并标注`@Configuration`使 Spring Boot 能够识别到。在方法前标注`@Bean`，方法的返回值会添加到容器中，容器中组件默认的 id 就是方法名。\n\n### 8、配置文件占位符\n\n> 在 yml 文件或 properties 文件中均可使用这种方式。\n\n- 使用`${}`来表示占位符\n- `${random.uuid}`表示一个随机字符串\n- 可以使用配置文件定义过的 key 作为占位符，若取不到值则可以通过`${xxx:0}`来设置默认值。\n\n### 9、profile 多环境支持\n\n配置文件命名规则为：application-{profile}.properties/yml\n\n例如以下命名方式：\n\n- application.properties\n- application-dev.properties\n\n默认是使用第一个配置文件，在第一个文件中可以指定`spring.profile.active=dev`来**激活指定 profile**文件。\n\nyml 文件有更简洁的方式---多文档块。例子如下：\n\n```yaml\nserver:\n	port: 8081\nspring:\n	profiles:\n		active: prod\n		\n---\nserver:\n	port: 8082\nspring:\n	profiles: dev\n		\n---\nserver:\n	port: 8083\nspring:\n	profiles: prod \n\n```\n\n#### 命令行方式激活指定 profile\n\n```shell\n--spring.profiles.active=dev\n# 在项目配置中设置上面命令即可\n# 若要运行打包后的 jar 文件，则在命令行末尾加入上述命令。\n\n```\n\n#### 虚拟机参数方式指定 profile\n\n在项目配置中找到 `VM options`,添加如下参数：\n\n```sh\n-DSpring.profiles.active=dev\n\n```\n\n### 10、配置文件加载位置及顺序\n\n优先级由高到低为：\n\n1. file:./config/\n2. file:./\n3. classpath:/config/\n4. classpath:/\n\n> 高优先级配置会覆盖低优先级配置。\n\nSpring Boot 会从这四个位置加载全部配置文件，会形成**互补配置**。\n\n> 可以通过`spring.config.location`指定加载的配置文件位置。不过这是在项目打包好之后使用命令行参数下进行配置的，同样会与四个加载位置形成互补配置。\n\n### 11、外部配置的加载顺序\n\n优先级由高到低为：\n\n![](https://www.z4a.net/images/2019/01/22/imageca93b50aae6ccea4.md.png)\n\n加载方式同内部配置。\n\n## 其他\n\n### 1、服务器相关配置\n\n```properties\n# 指定服务器端口号\nserver.port\n# 指定项目目录\nserver.context.path\n\n```\n\n', 0, 'SpringBoot 的基本配置及运行。', 'Spring Boot 学习', 0, '2019-03-16 15:38:06', 14, 100, 1);
INSERT INTO `article` VALUES (10, '# Vuex 状态管理\n\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n## 一、store 模式（简单应用）\n\n虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。\n\n如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 [store 模式](https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8)就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：\n\n> Flux 架构就像眼镜：您自会知道什么时候需要它。\n\n### 1、起步\n\n经常被忽略的是，Vue 应用中原始`数据`对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享：\n\n```js\nconst sourceOfTruth = {}\n\nconst vmA = new Vue({\n  data: sourceOfTruth\n})\n\nconst vmB = new Vue({\n  data: sourceOfTruth\n})\n```\n\n现在当 `sourceOfTruth` 发生变化，`vmA` 和 `vmB` 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 `this.$root.$data` 去访问。现在我们有了唯一的数据来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录。\n\n### 2、简单的 store 模式\n\n为了解决这个问题，我们采用一个简单的 **store 模式**：\n\n```js\nvar store = {\n  debug: true,\n  state: {\n    message: \'Hello!\'\n  },\n  setMessageAction (newValue) {\n    if (this.debug) console.log(\'setMessageAction triggered with\', newValue)\n    this.state.message = newValue\n  },\n  clearMessageAction () {\n    if (this.debug) console.log(\'clearMessageAction triggered\')\n    this.state.message = \'\'\n  }\n}\n```\n\n需要注意，所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。\n\n此外，每个实例/组件仍然可以拥有和管理自己的私有状态：\n\n```js\nvar vmA = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n\nvar vmB = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n```\n\n> 不应该在 action 中 **替换**原始的状态对象 - 组件和 store 需要引用同一个共享对象，mutation 才能够被观察\n\n组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 [Flux](https://facebook.github.io/flux/) 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。\n\n## 二、开始使用 Vuex\n\n每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：\n\n1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n### 1、创建 store\n\n```js\n// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n```\n\n### 2、获取及变更 store\n\n```js\nstore.commit(\'increment\')\n\nconsole.log(store.state.count) // -> 1\n```\n\n## 三、核心概念\n\n### 1、State\n\nVuex 使用**单一状态树**，用一个对象就包含了全部的应用级状态，这也意味着每个应用将仅仅包含一个 store 实例。\n\n#### 使用计算属性获取状态\n\n```js\n// 创建一个 Counter 组件\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n```\n\n每当 `store.state.count` 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。\n\n然而，这种模式导致**组件依赖全局状态单例**。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。\n\nVuex 通过 `store` 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 `Vue.use(Vuex)`）：\n\n```js\nconst app = new Vue({\n  el: \'#app\',\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  store,\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n```\n\n通过在根实例中注册 `store` 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 `this.$store` 访问到。让我们更新下 `Counter` 的实现：\n\n```js\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n\n#### mapState 辅助函数\n\n当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性，让你少按几次键：\n\n```js\n// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from \'vuex\'\n\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n\n    // 传字符串参数 \'count\' 等同于 `state => state.count`\n    countAlias: \'count\',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组。\n\n```js\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  \'count\'\n])\n```\n\n#### 对象展开运算符\n\n```js\n// 使用对象展开运算符将此对象混入到外部对象中\n  ...mapState({\n    // ...\n  })\n```\n\n### 2、Getter\n\n可以认为是 store 的计算属性。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\nGetter 接受 state 作为其第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: \'...\', done: true },\n      { id: 2, text: \'...\', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n```\n\n#### 通过属性访问 Getter\n\nGetter 会暴露为 `store.getters` 对象，你可以以属性的形式访问这些值：\n\n```js\nstore.getters.doneTodos // -> [{ id: 1, text: \'...\', done: true }]\n```\n\nGetter 也可以接受其他 getter 作为第二个参数：\n\n```js\ngetters: {\n  // ...\n  doneTodosCount: (state, getters) => {\n    return getters.doneTodos.length\n  }\n}\nstore.getters.doneTodosCount // -> 1\n```\n\n我们可以很容易地在任何组件中使用它：\n\n```js\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }\n}\n```\n\n> getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。\n\n#### 通过方法访问 Getter （可以实现给 Getter 传参）\n\n```js\ngetters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\nstore.getters.getTodoById(2) // -> { id: 2, text: \'...\', done: false }\n```\n\n> getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n\n#### mapGetters 辅助函数\n\n`mapGetters` 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：\n\n```js\nimport { mapGetters } from \'vuex\'\n\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      \'doneTodosCount\',\n      \'anotherGetter\',\n      // ...\n    ])\n  }\n}\n\n```\n\n如果你想将一个 getter 属性另取一个名字，使用对象形式：\n\n```js\nmapGetters({\n  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: \'doneTodosCount\'\n})\n\n```\n\n### 3、Mutation\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n\n```\n\n你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 `increment` 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 **store.commit** 方法：\n\n```js\nstore.commit(\'increment\')\n\n```\n\n#### 提交载荷（Payload）\n\n你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：\n\n```js\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit(\'increment\', 10)\n\n```\n\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：\n\n```js\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\nstore.commit(\'increment\', {\n  amount: 10\n})\n\n```\n\n#### 对象风格的提交方式\n\n提交 mutation 的另一种方式是直接使用包含 `type` 属性的对象：\n\n```js\nstore.commit({\n  type: \'increment\',\n  amount: 10\n})\n\n```\n\n当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：\n\n```js\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n\n```\n\n#### 需要遵守的响应规则\n\n1. 最好提前在你的 store 中初始化好所有所需属性。\n2. 当需要在对象上添加新属性时，你应该\n\n- 使用 `Vue.set(obj, \'newProp\', 123)`, 或者\n\n- 以新对象替换老对象。例如，利用 stage-3 的[对象展开运算符](https://github.com/sebmarkbage/ecmascript-rest-spread)我们可以这样写：\n\n  ```js\n  state.obj = { ...state.obj, newProp: 123 }\n  \n  ```\n\n3. Mutation 必须是同步函数。\n\n#### 使用常量代替 Mutation 事件类型\n\n```js\n// mutation-types.js\nexport const SOME_MUTATION = \'SOME_MUTATION\'\n// store.js\nimport Vuex from \'vuex\'\nimport { SOME_MUTATION } from \'./mutation-types\'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n\n```\n\n#### 在组件中提交 Mutation\n\n你可以在组件中使用 `this.$store.commit(\'xxx\')` 提交 mutation，或者使用 `mapMutations` 辅助函数将组件中的 methods 映射为 `store.commit` 调用（需要在根节点注入 `store`）。\n\n```js\nimport { mapMutations } from \'vuex\'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      \'increment\', // 将 `this.increment()` 映射为 `this.$store.commit(\'increment\')`\n\n      // `mapMutations` 也支持载荷：\n      \'incrementBy\' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(\'incrementBy\', amount)`\n    ]),\n    ...mapMutations({\n      add: \'increment\' // 将 `this.add()` 映射为 `this.$store.commit(\'increment\')`\n    })\n  }\n}\n\n```\n\n### 4、Action\n\nAction 类似于 mutation，不同在于：\n\n- Action 提交的是 mutation，而不是直接变更状态。\n- Action 可以包含任意异步操作。\n\n让我们来注册一个简单的 action：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit(\'increment\')\n    }\n  }\n})\n\n```\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 `context.commit` 提交一个 mutation，或者通过 `context.state` 和 `context.getters` 来获取 state 和 getters。当我们在之后介绍到 [Modules](https://vuex.vuejs.org/zh/guide/modules.html) 时，你就知道 context 对象为什么不是 store 实例本身了。\n\n实践中，我们会经常用到 ES2015 的 [参数解构](https://github.com/lukehoban/es6features#destructuring) 来简化代码（特别是我们需要调用 `commit` 很多次的时候）：\n\n```js\nactions: {\n  increment ({ commit }) {\n    commit(\'increment\')\n  }\n}\n\n```\n\n', 0, '在大型Web应用开发中各个组件之间的管理是一件非常困难的事，有了Vuex，这一切都变得非常简单。', 'Vuex学习', 0, '2019-03-16 15:39:33', 1, 100, 2);
INSERT INTO `article` VALUES (11, '# 一篇文章告诉你MVC、MVP、MVVM\n夏尼采 安卓巴士Android开发者门户 \n![image](https://app.yinxiang.com/shard/s8/res/523dc34e-b9dd-43e0-8491-4b1499daa8d0/640.gif)\n\n一个人善于使用模式，相当于把一些特定问题进行了抽象概括，大脑其实可以腾出更大的空间处理别的事情（具体的业务等）。所以，这一两年我也比较喜欢尝试使用一些流行的模式或者开源框架到自己的项目中，最终不一定会投入使用，但尝试的过程还是很有益处的。今天我们就把开发当中常用的模式简单介绍一下。来小可爱，上车吧！\n![image](https://app.yinxiang.com/shard/s8/res/8c0083f4-5a11-49fa-b4ff-462b29961875/640.jpg)\n\n## MVC\nMVC全名是Model--View--Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。其中Model层处理数据，业务逻辑等；View层处理界面的显示结果；Controller层起到桥梁的作用，来控制View层和Model层通信以此来达到分离视图显示和业务逻辑层。\n![image](https://app.yinxiang.com/shard/s8/res/725a5388-5c3e-48d9-b043-8b57e4116542/640.jpg)\n\n我们往往把Android中界面部分的实现也理解为采用了MVC框架，常常把Activity理解为MVC模式中的Controller。\n看似没有什么特别的地方，但是由几个需要特别关注的关键点：\n\n1、View是把控制权交移给Controller，自己不执行业务逻辑。\n\n2、Controller执行业务逻辑并且操作Model，但不会直接操作View，可以说它是对View无知的。\n\n3、View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。\n\n**MVC的优缺点**\n优点：\n```\n1、把业务逻辑全部分离到Controller中，模块化程度高。当业务逻辑变更的时候，不需要变更View和Model，    只需要Controller  换成另外一个  \n     Controller就行了（Swappable Controller）。\n2、观察者模式可以做到多视图同时更新。\n```\n缺点：\n```\n1、Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，  \n     Controller业务逻辑的正确性是无法验证的：Controller更新Model的时候，无法对View的更新操作进行断言。\n2、View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。\n     因为不同程序的的Domain Model是不一样的\n```\n## MVP\nMVP其实是MVC的一种演进版本，它更简单，将MVC中的Controller改为了Presenter，View通过接口与Presenter进行交互，降低耦合，方便进行单元测试。\n\nView：负责绘制UI元素、与用户进行交互(Activity、View、Fragment都可以做为View层)；\nModel：对数据的操作、对网络等的操作，和业务相关的逻辑处理；\nPresenter：作为View与Model交互的中间纽带，处理与用户交互的逻辑。可以把Presenter理解为一个中间层的角色，它接受Model层的数据，并且处理之后传递给View层，还需要处理View层的用户交互等操作。\n![image](https://app.yinxiang.com/shard/s8/res/6fa9f47b-2f04-426d-bf78-98c741bd417b/640.jpg)\n\n### 关键点：\n1、View不再负责同步的逻辑，而是由Presenter负责。Presenter中既有业务逻辑也有同步逻辑。\n2、View需要提供操作界面的接口给Presenter进行调用。（关键）\n\n对比在MVC中，Controller是不能操作View的，View也没有提供相应的接口；而在MVP当中，Presenter可以操作View，View需要提供一组对界面操作的接口给Presenter进行调用；Model仍然通过事件广播自己的变更，但由Presenter监听而不是View。\n\n### MVP（Passive View）的优缺点\n#### 优点：\n1、便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter业务逻辑的正确性。\n2、View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务逻辑完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做高度可复用的View组件。\n#### 缺点：\n1、Presenter中除了业务逻辑以外，还有大量的View->Model，Model->View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。\n## MVVM\nMVVM模式（Model--View--ViewModel模式），和MVP模式相比，MVVM 模式用ViewModel替换了Presenter ，其他层基本上与 MVP 模式一致，ViewModel可以理解成是View的数据模型和Presenter的合体。\n\nMVVM采用双向绑定（data-binding）：View的变动，自动反映在ViewModel，反之亦然，这种模式实际上是框架替应用开发者做了一些工作（相当于ViewModel类是由库帮我们生成的），开发者只需要较少的代码就能实现比较复杂的交互。\n\n![image](https://app.yinxiang.com/shard/s8/res/99e9a754-c4f1-4cdd-975f-97f0960a094e/640.jpg)\n### MVVM的调用关系\n\nMVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。\n\n关键点：\nMVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。\n只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。\nMVVM的优缺点\n优点：\n1、提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。\n2、简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。\n缺点：\n1、过于简单的图形界面不适用，或说牛刀杀鸡。\n2、对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。\n3、数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。\n结语\n可以看到，从MVC->MVP->MVVM，就像一个打怪升级的过程。后者解决了前者遗留的问题，把前者的缺点优化成了优点。同样的Demo功能，代码从最开始的一堆文件，优化成了最后只需要20几行代码就完成。MV*模式之间的区分还是蛮清晰的，希望可以给对这些模式理解比较模糊的同学带来一些参考和思路。\n\n\n\n\n\n\n\n大家都在看\n\n\n\nAndroid Architecture Components架构下的高效开发\n\nHi，我们再来聊一聊Java的单例吧\n\nAndroid开发中的面向切面编程AOP\n\nAndroid组件化最佳实践 ARetrofit原理\n\n\n\n欢迎前往安卓巴士博客区投稿，技术成长于分享\n\n期待巴友留言，共同探讨学习\n\n\n\n\n\n阅读原文', 0, '一篇文章告诉你MVC、MVP、MVVM', '一篇文章告诉你MVC、MVP、MVVM', 0, '2019-03-16 16:06:14', 0, 101, NULL);
INSERT INTO `article` VALUES (12, '#  Navicat Premium 12.1.15.0安装与激活\n\n![img](https://app.yinxiang.com/shard/s8/res/78509d6e-8606-40c8-af42-6f8ab1273d25/96) \n\n[丿记忆灬永殇丨](https://www.jianshu.com/u/64a2c1b1740a)\n\n \n\n**关注\n\n2018.01.20 13:43* 字数 1284 阅读 272434评论 335喜欢 503赞赏 24\n\n> ##### 声明：本文所提供的所有软件均来自于互联网，仅供个人研究和学习使用，请勿用于商业用途，下载后请于24小时内删除，请支持正版！\n\n------\n\n> #### 本文介绍Navicat Premium 12.1.15.0的安装、激活与基本使用。已于2019年02月15日测试，成功激活Navicat Premium 12.1.15.0简体中文64位。\n\n### **一、Navicat Premium 12下载**\n\n#### [Navicat Premium 12](https://www.navicat.com.cn/)是一套数据库开发管理工具，支持连接 MySQL、Oracle等多种数据库，可以快速轻松地创建、管理和维护数据库。\n\n> #### [Navicat Premium 12简体中文下载](https://www.navicat.com.cn/download/navicat-premium)：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/b0407632-59ab-47e3-8c97-105d0ab6194c/7213631-7dadfc11ab3e5bd6.png)\n\n下载\n\n------\n\n> #### [Navicat Premium 12.1.15.0简体中文64位](https://www.lanzous.com/i35cisb)\n>\n> #### [Navicat Premium 12.1.15.0简体中文32位](https://www.lanzous.com/i35cj1a)\n>\n> #### [Navicat Premium 12.1.15.0英文64位](https://www.lanzous.com/i35cjdc)\n>\n> #### [Navicat Premium 12.1.15.0英文32位](https://www.lanzous.com/i35cjmb)\n>\n> #### [Navicat 12用户指南(官方中文版)](https://www.lanzous.com/i2wyx9a)\n\n### **二、Navicat Premium 12安装**\n\n> #### 双击安装，点击下一步：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/cdc3147c-a31c-41a5-aedb-a35f7d5ca9e2/7213631-f78a6773ba0c739f.png)\n\n开始安装\n\n> #### 同意协议，点击下一步：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/1cf62446-3bec-43d3-81b2-5c7bd166f6c5/7213631-e221126633625fd3.png)\n\n同意协议\n\n> #### 选择安装位置（可默认），点击下一步：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/c7167d3d-1ac6-43dc-8f1b-0b4b22dcc814/7213631-25d629dc77b4c745.png)\n\n选择安装位置\n\n> #### 创建开始菜单文件夹，点击下一步：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/7f402b82-6d5e-4aa3-9ae8-edf4232fa014/7213631-e14a2fda7b7086f0.png)\n\n开始菜单文件夹\n\n> #### 创建桌面快捷方式，点击下一步：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/40cf3379-2dfd-40a7-a4a0-bec6489af352/7213631-69c26141eb9fe6b8.png)\n\n是否创建快捷方式\n\n> #### 准备安装，点击下一步：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/5371ee83-622c-49f1-916a-6e114f6d5be9/7213631-414b4acdf2f3b3db.png)\n\n准备安装\n\n> #### 正在安装中，等待安装完成：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/03a39a05-9fdb-4e19-b7c1-6a9aecb1bc17/7213631-6c09db9aff0d588f.png)\n\n正在安装\n\n> #### 安装完成，点击完成：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/69837ab0-312e-4f0c-bb97-db889212a3f4/7213631-3c69c07c5ca841be.png)\n\n安装成功\n\n### **三、Navicat Premium 12激活**\n\n> #### 注册机下载：[Navicat Premium 12.0.x&12.1.x注册机](https://www.lanzous.com/i35cjod)\n>\n> #### 重要提示：该注册机来源于[DeltaFoX](https://dfox.it/DeFconX/files/file/79-navicat-software/)（[GitHub](https://github.com/Deltafox79/Navicat_Keygen)）。一般来说，由于注册机会修改.exe文件或.dll文件，加壳并且没有数字签名，所以*杀毒软件会报毒*，自行决定是否使用本注册机。如需使用本注册机或者下载后找不到文件，需要关闭杀毒软件或将本注册机添加至杀毒软件白名单。\n\n------\n\n> #### ※※备用方案※※：命令行激活工具，来自[DoubleLabyrinth](https://github.com/DoubleLabyrinth)，分别适用于[Windows](https://github.com/DoubleLabyrinth/navicat-keygen/blob/windows/README.zh-CN.md)和[Mac](https://github.com/DoubleLabyrinth/navicat-keygen/blob/mac/README.zh-CN.md)。请仔细阅读README.md，有问题请到GitHub向该作者提issue。\n\n------\n\n> #### 若曾安装过Navicat Premium且多次激活失败，请先卸载已安装的Navicat Premium并清理文件残留和注册表残留，重启电脑，再次尝试激活。请勿无脑提问！确保Navicat Premium程序已关闭。无需断网，无需将注册机放到Navicat Premium安装目录下。\n\n> #### **以管理员身份运行**此注册机：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/3f7c42e5-08a8-4fa2-b55c-7ad637f242ea/7213631-bd58b2744f974523.png)\n\n运行注册机\n\n> #### 打开注册机后，在**1) Patch**，勾选Backup、Host和Navicat v12，然后点击Patch按钮：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/4ca801e0-42de-494f-a295-68d940419010/7213631-4ad41145620e68a2.png)\n\n点击Patch\n\n> #### 找到Navicat Premium 12安装路径下的**navicat.exe**，选中并点击打开：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/1554be66-f1a7-49e1-a3ba-ef37dc252cf9/7213631-46e495f1031d45a0.png)\n\nnavicat.exe\n\n> #### 此时出现如下弹窗，提示`navicat.exe - x64 -> Cracked.`，提示已破解（别高兴，还没结束）。若提示`libcc.dll`或`navicat.exe`出错，检查是否未关闭Navicat Premium，或到安装目录下将`libcc.dll`和`navicat.exe`删除，并将`libcc.dll.BAK`或`navicat.exe.BAK`去掉`.BAK`后缀名。否则卸载已安装的Navicat Premium并清理文件残留和注册表残留：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/2af1c37a-87ac-44b3-9464-adb2fa0b2ddc/7213631-1164104c57f1501e.png)\n\n已破解\n\n> #### **2) License, Product and Language**确保License为Enterprise，Products为Premium，Languages为Simplified Chinese（即简体中文，其它语言版本如英文版请选择English）；\n>\n> #### **3) Resale License**确保Resale Version为Site license；\n>\n> #### **4) Keygen / Offline Activation**中Your Name和Your Organization可以任意填写或者默认：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/e8218e8e-093a-48f4-9dc8-e9863d2e6d37/7213631-617c0378d9059b8c.png)\n\n检查选项\n\n> #### 在**4) Keygen / Offline Activation**，点击Generate，将自动生成Serial Keygen（即注册码）：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/061fb563-a514-4bb0-959b-d057b0c2caf7/7213631-c25c34ee2fe8c032.png)\n\n生成注册码\n\n> #### 打开Navicat Premium 12，点击菜单栏的**帮助**，选择**注册**，在注册窗口**键**处填入上一步生成的Serial Keygen（即注册码），然后点击**激活**：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/4cd64fda-0cda-4a51-925c-3ee56054cddf/7213631-195b6b44c49f5347.png)\n\n填入注册码\n\n> #### 点击**手动激活**：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/96cd521f-4c75-44e5-bbee-7008c357e95a/7213631-a97ac52f1e96130a.png)\n\n手动激活\n\n> #### 将Navicat手动激活窗口的请求码框中内容复制到注册机Request Code框中，点击Activation Code下面的Generate按钮（若此处出现错误，要么你未完全按照教程来，要么你所安装的版本高于注册机所支持的版本）：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/9238b6ef-afb2-490e-928f-dd62bb978ebf/7213631-cac449d6876f231a.png)\n\n请求码\n\n> #### 将注册机Activation Code处生成的激活码内容复制到Navicat手动激活窗口的激活码框中（或点击Activation Code处下面的Copy按钮，这样会自动粘贴到Navicat手动激活窗口的激活码框中），然后点击激活按钮：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/6c0015bf-5584-4316-86a3-9a3c304882c3/7213631-c920756846df68df.png)\n\n激活码\n\n> #### 提示Navicat现已激活：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/9221dba6-84be-490a-ae29-e4ac801637dd/7213631-88c4de683b5d12f8.png)\n\n激活成功\n\n> #### Navicat Premium 12.1.15.0激活成功：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/4ec39998-d76e-48bc-a162-2b8d826b1e06/7213631-0c0170feafc52772.png)\n\nNavicat Premium 12.1.15.0中文版激活成功\n\n### **三、Navicat Premium 12基本使用**\n\n> #### 以Navicat Premium 12连接MySQL数据库为例，依次选择**连接 > MySQL**：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/30cfe2e7-57e2-4e3f-92ee-a129b1de149e/7213631-e8f66d4c80e394fb.png)\n\n连接MySQL\n\n> #### 设置相关的连接信息，点击**测试连接**，测试是否能连接上MySQL数据库。若弹出**连接成功**窗口，则表示连接MySQL数据库成功，点击确定：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/2f6f6445-94d4-4080-b944-c68c3ed99f7e/7213631-d9b161b88be42ab1.png)\n\n新建连接\n\n> #### 右键刚刚建立的连接TEST，可以打开连接、关闭连接和创建数据库等等操作，实现对MySQL数据库管理：\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/023baa8b-7b11-4a75-a1b8-7ad592f0cb71/7213631-6b4a977d376029fd.png)\n\n打开连接\n\n### **至此，对Navicat Premium 12.1.15.0下载、安装、激活与使用的介绍完毕。**\n\n------\n\n> #### 若需[本博文壁纸](https://pan.baidu.com/s/1dYwKP4)，提取密码：dqbq', 0, 'Navicat Premium 12.1.15.0安装与激活', 'Navicat Premium 12.1.15.0安装与激活', 0, '2019-03-16 16:08:04', 0, 102, NULL);
INSERT INTO `article` VALUES (13, '1. [\n   专栏](https://segmentfault.com/blogs)\n2. / 文章详情\n\n\n\n\n\n[![img](https://app.yinxiang.com/shard/s8/res/5b7fe106-ef9f-4970-9bde-739608426413/1109098649-5abb21d6d03a5_big64) ](https://segmentfault.com/u/yvonne_596d715a7ca34)\n\n[**chenyunqing**](https://segmentfault.com/u/yvonne_596d715a7ca34) ![img](https://app.yinxiang.com/shard/s8/res/6f7db24b-e6d2-41fc-a844-02dfc13464d1/rp.png)17\n\n2018-07-02 发布\n\n\n\n# [在Vue中使用echarts的两种方式](https://segmentfault.com/a/1190000015453413)\n\n原创\n\n- [npm ](https://segmentfault.com/t/npm/blogs)\n- [webpack ](https://segmentfault.com/t/webpack/blogs)\n- [vue-cli ](https://segmentfault.com/t/vue-cli/blogs)\n- [echarts ](https://segmentfault.com/t/echarts/blogs)\n- [vue.js ](https://segmentfault.com/t/vue.js/blogs)\n\n 3.9k 次阅读  ·  读完需要 11 分钟\n\n\n\n\n\n\n\n# 准备：使用[vue-cli](https://github.com/vuejs/vue-cli)脚手架\n\n如果你已经有自己的项目，可以跳过这一步。\n\n### npm下载vue-cli脚手架\n\n```\nnpm install -g @vue/cli\n```\n\n### 初始化一个项目\n\n```\nvue init webpack hello\n```\n\n![clipboard.png](https://app.yinxiang.com/shard/s8/res/e1835ada-2bde-4917-9b10-54a3720f5815/bVbiIOF)\n\n然后等待它安装完所有的依赖包就可以了。\n\n下面我们开始引入echarts。\n\n# 方式一、直接引入echarts\n\n### 先npm安装echarts\n\n```\nnpm install echarts --save\n```\n\n### 开发：\n\nmain.js\n\n```\nimport myCharts from \'./comm/js/myCharts.js\'\nVue.use(myCharts)\n```\n\nmyCharts.js\n\n```\n/**\n * 各种画echarts图表的方法都封装在这里\n */\n\nimport echarts from \'echarts\'\nconst install = function(Vue) {\n    Object.defineProperties(Vue.prototype, {\n        $chart: {\n            get() {\n                return {\n                    //画一条简单的线\n                    line1: function (id) {\n                        this.chart = echarts.init(document.getElementById(id));\n                        this.chart.clear();\n\n                        const optionData = {\n                            xAxis: {\n                                type: \'category\',\n                                data: [\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\']\n                            },\n                            yAxis: {\n                                type: \'value\'\n                            },\n                            series: [{\n                                data: [820, 932, 901, 934, 1290, 1330, 1320],\n                                type: \'line\',\n                                smooth: true\n                            }]\n                        };\n\n                        this.chart.setOption(optionData);\n                    },\n                }\n            }\n        }\n    })\n}\n\nexport default {\n    install\n}\n```\n\nHelloWorld.vue\n\n```\n<template>\n  <div class=\"hello\">\n    <div id=\"chart1\"></div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'HelloWorld\',\n  data () {\n    return {\n    }\n  },\n  mounted() {\n    this.$chart.line1(\'chart1\');\n  }\n}\n</script>\n\n<style scoped>\n  #chart1 {\n    width: 300px;\n    height: 300px;\n  }\n</style>\n```\n\n![clipboard.png](https://app.yinxiang.com/shard/s8/res/6e518e98-48c1-445b-9cec-417465a6fb0c/bVbc22p)\n\n# 方式二、使用[vue-echarts](https://github.com/Justineo/vue-echarts)\n\n### 先npm安装vue-echarts\n\n```\nnpm install vue-echarts --save\n```\n\n### 开发：\n\nmain.js\n按需引入\n\n```\nimport ECharts from \'vue-echarts/components/ECharts\'\nimport \'echarts/lib/chart/line\'\nVue.component(\'chart\', ECharts)\n```\n\nHelloWorld.vue\n\n```\n<template>\n  <div class=\"hello\">\n    <chart ref=\"chart1\" :options=\"orgOptions\" :auto-resize=\"true\"></chart>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'HelloWorld\',\n  data () {\n    return {\n      orgOptions: {},\n    }\n  },\n  mounted() {\n    this.orgOptions = {\n        xAxis: {\n            type: \'category\',\n            data: [\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\']\n        },\n        yAxis: {\n            type: \'value\'\n        },\n        series: [{\n            data: [820, 932, 901, 934, 1290, 1330, 1320],\n            type: \'line\',\n            smooth: true\n        }]\n    }\n  }\n}\n    </script>\n\n```\n\nps：原本webpack配置需要改的，看了一下vue-echarts的官网说明是v2.3.4之后都不需要改了，所以到这里就结束了。试过打包了，没报错~\n\n\n\n\n\n- [![img](https://app.yinxiang.com/shard/s8/res/cb00d70c-3c50-4ecd-b724-799e90dd9061/creativecommons-cc.png)](https://creativecommons.org/licenses/by-nc-nd/4.0/)\n- \n\n- [新浪微博](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n- [微信](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n- [Twitter](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n- [Facebook](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n\n\n\n\n\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/37adc6cf-4c42-4b2d-87e9-6a529b51c901/lg.php)\n\n#### 你可能感兴趣的\n\n![img](https://app.yinxiang.com/shard/s8/res/37adc6cf-4c42-4b2d-87e9-6a529b51c901/lg.php)\n\n- [Vue应用部署到服务器的正确方式](http://segmentfault.com/a/1190000010191670)darkCode[html5](https://segmentfault.com/t/html5)[node.js](https://segmentfault.com/t/node.js)[javascript](https://segmentfault.com/t/javascript)\n- [GitLab 简明安装配置指南](http://segmentfault.com/a/1190000002722631)Hiufan[gitlab](https://segmentfault.com/t/gitlab)\n- [三大图表库：ECharts 、 BizCharts 和 G2，该如何选择？](http://segmentfault.com/a/1190000016469959)薄荷前端[echarts](https://segmentfault.com/t/echarts)[react.js](https://segmentfault.com/t/react.js)[canvas](https://segmentfault.com/t/canvas)\n- [vue2.5/vue-cli3.0版本更新引发的一些常见问题](http://segmentfault.com/a/1190000014219426)yint[vue.js](https://segmentfault.com/t/vue.js)[vue-cli](https://segmentfault.com/t/vue-cli)\n- [L2TP/IPSEC搭建VPN详细教程](http://segmentfault.com/a/1190000006125737)唐霜[ipsec](https://segmentfault.com/t/ipsec)[l2tp](https://segmentfault.com/t/l2tp)[vpn](https://segmentfault.com/t/vpn)[vpn-server](https://segmentfault.com/t/vpn-server)\n- [webpack超简易入门安装](http://segmentfault.com/a/1190000011882193)比那名居天子[webpack](https://segmentfault.com/t/webpack)[webpack-dev-server](https://segmentfault.com/t/webpack-dev-server)\n- [(Git)合并多个commit](http://segmentfault.com/a/1190000007748862)nihao[git](https://segmentfault.com/t/git)\n- [vue — 创建vue项目](http://segmentfault.com/a/1190000014218991)Daisy[vue.js](https://segmentfault.com/t/vue.js)\n\n\n\n6 条评论\n\n[默认排序](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[时间排序](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n\n\n[![img](https://app.yinxiang.com/shard/s8/res/95762d9c-c0bc-4d91-abc4-0633cca4ae35/14175500-59c4a5c8e0739_big64)](https://segmentfault.com/u/jackie_zhang)\n\n[](https://segmentfault.com/a/1190000015453413#911)\n\n[JackieZhang](https://segmentfault.com/u/jackie_zhang)\n\n \n\n· 2018年10月26日\n\n\n\n顺丰科技……\n\n\n\n\n\n赞 回复\n\n\n\n？.？\n\n\n\n— [**chenyunqing** ](https://segmentfault.com/u/yvonne_596d715a7ca34)作者 · 2018年10月26日 \n\n0\n\n[@chenyunqing](https://segmentfault.com/u/yvonne_596d715a7ca34) 没什么啊，你在几楼？\n\n\n\n[](https://segmentfault.com/a/1190000015453413#911)— [**JackieZhang** ](https://segmentfault.com/u/jackie_zhang)· 2018年10月26日 \n\n\n\n23333吓得我刚才赶紧去p了个图......怎么不先问在哪栋？新来的吧啊哈哈哈\n\n\n\n— [**chenyunqing** ](https://segmentfault.com/u/yvonne_596d715a7ca34)作者 · 2018年10月26日 \n\n[添加回复](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n\n\n[![img](https://app.yinxiang.com/shard/s8/res/8b949549-0f38-4016-803a-57a891e21672/444705732-5992f93e662c0_big64)](https://segmentfault.com/u/wanghao_5779e686713bc)\n\n\n\n[彼岸花开](https://segmentfault.com/u/wanghao_5779e686713bc)\n\n \n\n· 2018年12月05日\n\n\n\n全局引入 包体积会很大吧，\n\n\n\n\n\n赞 回复\n\n\n\n第一种方式用了全局引入，是方便小白随便试的，如果需要按需引入，可以把import部分改成：\nimport echarts from \'echarts/lib/echarts\'\nimport \'echarts/lib/chart/line\'\n\n\n\n— [**chenyunqing** ](https://segmentfault.com/u/yvonne_596d715a7ca34)作者 · 2018年12月12日 \n\n[添加回复](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/a5497e51-5712-4905-a23e-b0a66fd6fc13/user-128.png)\n\n\n  ', 0, '在Vue中使用echarts的两种方式 - 个人文章 - SegmentFault 思否', '在Vue中使用echarts的两种方式 - 个人文章 - SegmentFault 思否', 0, '2019-03-16 16:10:34', 0, 103, NULL);
INSERT INTO `article` VALUES (14, '###  引子\n\n自从从JAVA伪全栈转前端以来，学习的路上就充满了荆棘（奇葩问题），而涉及前后端分离这个问题，对cors的应用不断增多，暴露出的问题也接踵而至。\n这两天动手实践基于Token的WEB后台认证机制，看过诸多理论（[较好一篇](http://www.cnblogs.com/xiekeli/p/5607107.html)推荐），正所谓虑一千次，不如去做一次。 犹豫一万次，不如实践一次，所以就有了下文，关于token的生成，另外一篇文章会细讲，本篇主要讨论在发送ajax请求，头部带上自定义token验证验证，暴露出的跨域问题。\n\n### 先说说定义\n\nCORS：跨来源资源共享（CORS）是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比JSONP要来的好，JSONP对于 RESTful 的 API 来说，发送 POST/PUT/DELET 请求将成为问题，不利于接口的统一。但另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。不过现代的浏览器（IE10以上）基本都支持 CORS。\n预检请求（option）:在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求(一般都是浏览检测到请求跨域时，会自动发起)，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers 首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。\n\n```\nOPTIONS /resources/post-here/ HTTP/1.1 \nHost: bar.other \nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 \nAccept-Language: en-us,en;q=0.5 \nAccept-Encoding: gzip,deflate \nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 \nConnection: keep-alive \nOrigin: http://foo.example \nAccess-Control-Request-Method: POST \nAccess-Control-Request-Headers: X-PINGOTHER, Content-Type\n```\n\n服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中。\n\n### 问题描述\n\n话不多说，先上代码：\n\n```\n前端（ajax库：vue-resource）\n        userLogin:function(){\n            this.$http({\n                method:\'post\',\n                url:\'http://localhost:8089/StockAnalyse/LoginServlet\',\n                params:{\"flag\":\"ajaxlogin\",\"loginName\":this.userInfo.id,\"loginPwd\":this.userInfo.psd}, \n                headers: {\'Content-Type\': \'application/x-www-form-urlencoded\'}, \n                credientials:false, \n                emulateJSON: true                    \n            }).then(function(response){\n                sessionStorage.setItem(\"token\",response.data);\n                this.isActive =false;\n                document.querySelector(\"#showInfo\").classList.toggle(\"isLogin\");\n            })                 \n        }\n后端相关配置：\n        response.setHeader(\"Access-Control-Allow-Origin\", \"http://localhost\"); //允许来之域名为http://localhost的请求        \n    response.setHeader(\"Access-Control-Allow-Headers\", \"Origin,No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With, userId, token\");\n    response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\"); //请求允许的方法\n    response.setHeader(\"Access-Control-Max-Age\", \"3600\");    //身份认证(预检)后，xxS以内发送请求不在需要预检，既可以直接跳过预检，进行请求(前面只是照猫画虎，后面才理解)\n```\n\n关于上面一段代码，是我的用户首次登录认证，生成token令牌，保存在sessionStorage中，供后面调用；需要说明的是，前端服务器地址是：localhost:80,后端服务器地址：localhost:8089，所以前后端涉及到跨域，自己在后端做了相应的跨域设置：response.setHeader(\"Access-Control-Allow-Origin\", \"http://localhost\"); 所以登录认证,安全的实现了跨域信息认证，后端相应发送回来了相应的token信息。\n但获取到token后，想在需要的时候，在请求的头部携带上这个令牌，来做相应的身份认证，所以自己在请求中做了这些改动（有标注），后端没改动，源码：\n\n```\n        checkIdentity:function(){\n            let token =sessionStorage.getItem(\'token\');\n            this.$http({\n                method:\'post\',\n                url:\'http://localhost:8089/StockAnalyse/LoginServlet\',\n                params:{\"flag\":\"checklogin\",\"isLogin\":true,\"token\":token}, \n                headers: {\'Content-Type\': \'application/x-www-form-urlencoded\'}, \n                headers:{\'token\':token},        //header中携带令牌信息            \n                credientials:false, \n                emulateJSON: true                    \n            }).then(function(response){\n                console.log(response.data);\n            })                 \n        }   \n```\n\n但实际上在devtools打印了如下错误信息：Response to preflight request doesn\'t pass access control check: No \'Access-Control-Allow-Origin\' header is present on the requested resource. Origin \'[http://localhost](http://localhost/)\' is therefore not allowed access.仔细想一想，好像，似乎这个问题遇到过，还提过问，确实提过，[链接在这里](https://segmentfault.com/q/1010000009255088)。但这次的设置和上次一样，就在header里多加了一个自定义token，但却报了和上次没有设置headers: {\'Content-Type\': \'application/x-www-form-urlencoded\'}一样的错误信息，于是，不知所措，算了，重头再来，好好百度，研究一下cors跨域。\n\n### 理论学习\n\n运气不错，找到了[一篇好文](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)，文章讲的很细，也找到自己问题的所在：触发 CORS 预检请求。引用原文的话加以自己总结：跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request：似曾相识有没有？诶，对，上面那个错误信息中，就有一个这样陌生的词汇），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。所以跨域请求分两种：简单请求和预检请求。一次完整的请求不需要服务端预检，直接响应的，归为简单请求；而响应前需要预检的，称为预检请求，只有预检请求通过，才有接下来的简单请求。对于那些是简单请求，那些会触发预检请求，文章做了详细的总结，这里列出触发预检请求的条件（不知道脑子为啥会想到那些会触发BFC的条件），不要跑题，原文是这样总结的：\n\n```\n当请求满足下述任一条件时，即应首先发送预检请求：\n使用了下面任一 HTTP 方法：\nPUT\nDELETE\nCONNECT\nOPTIONS\nTRACE\nPATCH\n人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：\nAccept\nAccept-Language\nContent-Language\nContent-Type (but note the additional requirements below)\nDPR\nDownlink\nSave-Data\nViewport-Width\nWidth\n Content-Type 的值不属于下列之一:\napplication/x-www-form-urlencoded\nmultipart/form-data\ntext/plain\n```\n\n### 问题分析\n\n所以，再来看自己两次犯错（第一次是没有设置：headers: {\'Content-Type\': \'application/x-www-form-urlencoded\'}, 第二次是设置自定义header，headers:{\'token\':token}。很巧，有没有，一次少，一次多，都点燃了导火索），其实都是触发了预检请求。对于第一次的错误，很好解决，增加headers: {\'Content-Type\': \'application/x-www-form-urlencoded\'}，就解决了，[关于Conten-Type的几种取值，你需要知道的](http://zccst.iteye.com/blog/2180127)。但对于第二个错误，好像没法向第一种那样，将预检请求转变为简单请求，所以，只有寻找方法怎么在后端实现相应的预检请求，来返回一个状态码2xx，告诉浏览器此次跨域请求可以继续。所以注意力转向后端。\n关于JAVA实现预检请求，基本都是采用过滤器，不要问我为什么不是监听器或者拦截器（我就是个伪全栈，就不要相互为难了，自己百度之），自定义（copy）了一个filter,并在web.xml中进行了设置。源码：\n\n```\nFilter接口实现部分：\npackage stock.model;\nimport java.io.IOException;   \nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;    \nimport org.apache.commons.httpclient.HttpStatus;   //这里需要添加commons-httpclient-3.1.jar\npublic class CorsFilter implements Filter {     //filter 接口的自定义实现\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");           \n        String token = request.getHeader(\"token\");\n        System.out.println(\"filter origin:\"+token);//通过打印，可以看到一次非简单请求，会被过滤两次，即请求两次，第一次请求确认是否符合跨域要求（预检），这一次是不带headers的自定义信息，第二次请求会携带自定义信息。\n        if (\"OPTIONS\".equals(request.getMethod())){//这里通过判断请求的方法，判断此次是否是预检请求，如果是，立即返回一个204状态吗，标示，允许跨域；预检后，正式请求，这个方法参数就是我们设置的post了\n          response.setStatus(HttpStatus.SC_NO_CONTENT); //HttpStatus.SC_NO_CONTENT = 204\n          response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, DELETE, OPTIONS, DELETE\");//当判定为预检请求后，设定允许请求的方法\n          response.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type, x-requested-with, Token\"); //当判定为预检请求后，设定允许请求的头部类型\n          response.addHeader(\"Access-Control-Max-Age\", \"1\");                           \n        }\n        filterChain.doFilter(servletRequest, servletResponse);\n    }\n    @Override\n    public void destroy() {     \n    }\n}\nweb.xml配置部分\n<filter>\n<filter-name>cors</filter-name>\n<filter-class>stock.model.CorsFilter</filter-class>\n</filter>\n<filter-mapping>\n<filter-name>cors</filter-name>\n<url-pattern>/*</url-pattern>\n</filter-mapping> \n```\n\n### 结论\n\n当在后端实现添加上面的源码后，皆大欢喜，问题得以解决，补上失败和成功,自己截下的两张请求响应图。![图片描述](https://app.yinxiang.com/shard/s8/res/ad1c86a1-9eed-4b89-884d-a96f31828c3a/bVPZ8K)仔细看请求响应失败发起响应那张图，在General的数据集中，可以看到方法是options，而非代码指定的post请求，所以这是一次浏览器发出的一次预检请求，让服务器确认此IP是否有访问的权限，如果有，服务器需要返回一个2xx的状态码给浏览器。紧接着再发起一次简单请求。如下面在devtools中的截取图片（为了对比清除，我把两次分别截取，做了拼接，因为不会做动态图）。可以看到同一个post请求，实际上产生了两次网络连接。![图片描述](https://app.yinxiang.com/shard/s8/res/2f96bf9e-7c7b-4b72-94ad-471f4c2bea9d/bVP7FU)\n但关于cors,要去探索的，还有很多很多，所以遵循革命语录：实践（有时也可以是时间）是检验真理的唯一标准，是没有错的。后续有新的收获，再补充。', 0, 'cors跨域之简单请求与预检请求（发送请求头带令牌token） - 个人文章 - SegmentFault 思否', 'cors跨域之简单请求与预检请求（发送请求头带令牌token） - 个人文章 - SegmentFault 思否', 0, '2019-03-16 16:14:20', 0, 104, NULL);
INSERT INTO `article` VALUES (15, '比尔·盖茨发布2019新年信：意料之外\n\n12小时前\n\nPingWest品玩2月13日讯，盖茨基金会官方微信公众号今日发布比尔和梅琳达·盖茨的[2019新年公开信](https://www.pingwest.com/w/%E6%AF%94%E5%B0%94%E5%92%8C%E6%A2%85%E7%90%B3%E8%BE%BE%C2%B7%E7%9B%96%E8%8C%A8)。分享了夫妻二人这些年来经历的故事与所感。\n\n你怎么评价2018年？和你之前想像的一样吗？\n\n\n我们的答案恐怕是否定的。无论是频繁发生的自然灾害，还是参加竞选的女性数量创下记录，2018年发生了很多意料之外的事情。站在今天回望过去，世界已经和我们几年前的展望大相径庭。\n\n意料之外也有好处，它能警醒我们世事未必如愿，也能激励我们行动刻不容缓。有些意外敦促我们改变现状，有些意外则表明我们期待的改变已经在发生。\n\n*“无论是频繁发生的自然灾害，还是参加竞选的女性数量创下记录，2018年发生了很多意料之外的事情。”*\n\n二十五年前，我们读到的一篇文章中提到，贫困国家每年有数十万儿童死于腹泻。这个出乎我们意料的数字，促使我们确立了盖茨基金会的理念。我们相信，在一个人人平等的世界中，所有人都应从创新中受益，没有任何一个孩子会死于可预防的疾病。但我们看到的是，不平等依然大量存在。\n\n这个发现是我们的慈善之路上的重要一步。震惊之余，我们心生愤慨，并决心为此采取行动。\n\n当然，也有令人惊喜的意外。刚开始了解疟疾的时候，我们以为只有发明长效疫苗才能切实推进抗疟事业。孰不知，得益于推广使用蚊帐和其他多种手段，疟疾导致的死亡人数自2000年以来已经下降了42%。\n\n在今年的公开信里，我们希望和大家分享一路走来的另外九大意外。有些让人忧虑，有些给人启迪，但无一不激励我们采取行动。我们希望大家也能获得同样的鼓舞，并付诸行动。只有这样，世界才能变得更好。\n\n**1. 非洲是最年轻的大陆**\n\n\n \n\n**比尔：**全球老龄化趋势仍在持续，但非洲的年龄（几乎）没变。这听上去令人费解，仔细分析一下就能明白。\n\n*“非洲年轻人决定了整个大陆，乃至全世界的未来。”*\n\n普遍的寿命增长导致全球人口年龄中位数不断提高。随着越来越多的孩子能长大成人，妇女的生育数量也逐渐下降，带来的结果就是全球人口年龄正在慢慢向中年靠拢。\n\n非洲却是例外。非洲人口的年龄中位数只有18岁，北美则是35岁。未来几十年，非洲的年轻人数量将一直保持上升。\n\n这背后的原因很多。其中之一是尽管非洲很多地区人口出生率下降，但在撒哈拉以南非洲最贫困的地区却在上升。这既可能成为资产，也可能成为负债。我和梅琳达认为，恰当的投资无疑将释放非洲的巨大潜力。非洲年轻人决定了整个大陆，乃至全世界的未来。\n\n**梅琳达：**谈到经济发展的诸多要素，经济学家通常会强调“人力资本”。换言之，未来取决于年轻人能否获得优质的健康服务和教育。健康和教育是经济增长的双重引擎。\n\n如果撒哈拉以南非洲国家能对年轻人进行投资，那么到2050年，该地区的劳动力在全球中的占比会翻一番，并为亿万民众创造更好的生活。\n\n女童教育堪称世界上最强大的力量之一。受过教育的女童能够生活得更加健康、更加富裕。（如果女童能够接受12年的优质教育，所有女性终生创造的收入将增加30万亿美元，比美国经济总量还多。）她们的家庭也会因此受益。女性受教育水平越高，就越有可能养育健康的子女。据联合国教科文组织估计，在中低收入国家，如果所有女性都能读完中学，那么儿童死亡率将会下降一半左右。\n\n非洲的年轻人得以健康成长、接受良好教育，并被充分赋权——尤其是女孩儿们也能获得同样的机会，而不是被遗忘——这是我最为憧憬的社会进步。\n\n**2.家庭基因检测既能帮助发现“连环手”，又能预防早产**\n\n**比尔：**去年，一则警察利用基因检测结果抓获“金州杀手”的新闻轰动世界。但家庭基因检测的好处不止于此。基因检测公司23andMe的用户自愿提交了四万多份样本，通过对这些样本的分析，科学家们发现了早产与六个基因之间的潜在关联，其中的一个基因负责调节人体如何利用矿物质硒。 \n\n有些人的基因妨碍硒的正常代谢。由盖茨基金会资助的23andMe研究发现，有这种基因的孕妇更易发生早产，这表明硒对产妇的分娩时间有重要影响。\n\n*“科学家们发现了早产与六个基因之间的潜在关联。”*\n\n了解早产的原因非常重要。全球每年发生1500万例早产，这是五岁以下儿童死亡的头号杀手。早产可能发生在任何一位母亲身上，但有些群体的早产率更高（接下来梅琳达会具体介绍），低收入国家的早产儿死亡率远高于富裕国家。\n\n到今年年底，研究者们将有望搞清楚硒对早产风险的确切影响。如果二者之间的关联足够显著，硒的代谢就有可能成为经济易行的解决方案，帮助孕妇足月生产。\n\n这种关联只是近年来我们取得的突破之一。在更精良的工具和更充分的数据共享的帮助下，我们终于开始理解早产发生的原因，以及如何能让胎儿在子宫里孕育得更久。斯坦福团队开发的简易早产血检让我尤其兴奋。它能帮助孕妇预测何时分娩，从而配合医生降低风险。\n\n**梅琳达：**比尔介绍了一些很有前景的发现，但即便如此，我们对早产认知的匮乏还是令人吃惊。我实在想不到，有什么其他事情像早产这样——足足影响着全球10%的人口，却被如此忽视。 \n\n我们无法识别大多数早产发生的原因，也不知道为什么有些孕妇更容易早产。例如为什么高个子妇女孕期更长？为什么非洲裔美国妇女的早产率高于从非洲国家移民来的妇女？这些依旧成谜。一种理论认为这是社会文化造成的，因为非洲裔美国女性一生面对种族主义和歧视，这些压力对她们的健康造成了伤害。另一种理论认为，在美国长大的女性体内的微生物构成与移民不同。我们无从得知真正的原因。\n\n但我们很清楚地知道：即使同为早产，生产的时间也对伤害程度有着重要影响——36周出生的婴儿要比34周出生的健康得多。完全杜绝早产可能不太现实，我们的目标是尽量延长孕期，让每个孩子尽可能足月生产。现在，我们终于开始填补这方面的知识空白。\n \n\n**3.今后四十年，全世界每个月都将新建一个纽约市**\n\n**比尔：**我希望能有更多的人充分了解如何才能阻止气候变化。 \n\n你或许读到过类似信息：随着可再生能源成本降低，我们在电力上取得了一些进展。但事实上电力只占全球温室气体排放总量的四分之一。\n\n全球温室气体排放量的21%来自制造业。提到制造业，多数人想到的是流水线上的小配件，但其实还包括建筑材料。生产钢铁水泥要消耗大量化石燃料，过程中又会释放大量碳等副产品。\n\n随着城市人口在未来几十年的持续增长，全球建筑体量到2060年预计将会翻倍，相当于从现在开始每月新建一个纽约市。这需要大量钢铁水泥。我们需要想办法在不加剧气候变化的前提下实现这一切。\n\n排放大户不止制造业一个。农业占全球温室气体排放的24%，这包括牛打嗝和放屁时排放的甲烷。（我自己也很意外，居然会在年信里正经探讨关于牛肠胃胀气的问题。）\n\n重要的是，我们如果要解决气候变化，就要让农业、电力、制造、交通、建筑等所有导致气候变化的行业都实现近零排放。我把这五个领域称为气候变化的五大挑战。\n\n指望人们不用化肥、不开轮船、不盖房子、不坐飞机，这些都不现实。要求发展中国家为了其他人的利益而放慢本国发展也不公平。例如在中低收入国家，牛还是很多人收入和营养的重要来源。\n\n有一个解决方法是对这五大领域的创新进行投资，从而在不破坏气候的前提下保持发展。对于每一个重大挑战，我们都需要突破性发明。\n\n我可以分享一些进展。欧盟委员会最近承诺投资这五个领域的研发。我参与发起的十亿美元规模的突破能源风险投资基金（Breakthrough Energy Ventures），针对致力解决这五大挑战的清洁能源公司进行投资。（我在突破能源风险投资基金的工作与基金会帮助农民适应气候变化的工作彼此独立。）\n\n我们需要更好地让公众了解这些挑战，而媒体对这些问题的广泛关注将对此大有助益。读到太阳能电池板的故事固然不错，但我们也需要了解关于卡车、水泥、牛放屁等方面的信息。\n\n**4. 数据也存在性别歧视**\n\n**比尔：**我每天花大量时间研究健康和发展方面的数据。关于妇女和女童的数据如此之少，让我始料未及。我想主要原因在于，我们人为地将某些问题划分为“女性问题”和其它问题，而女性问题通常得不到深入研究。这将妨碍人类整体的进步。如果不了解全球半数人口的情况，就无法实现真正的进步。更何况科技让数据收集如此简单，我们没有理由继续这样。\n\n**梅琳达：**发展中国家的妇女去年收入多少？她们拥有多少财产？女孩花在家务上的时间比男孩多多少?\n\n我不知道答案。其他人也不知道。因为这些数据根本就不存在。\n\n我和比尔可以用整封年信的篇幅谈论数据在促进全球最贫困人口发展上的作用。数据会催生更好的决策和政策，帮助我们制定目标、评估进展，也让倡导和问责成为可能。\n\n因此，关于妇女和女童的数据缺失危害甚大，导致我们无法帮助她们改善生活。\n\n问题不只是数据统计忽略了部分女性，而且决策者们所依据的现有数据质量也很糟糕，甚至是带有性别歧视的。我们通常认为数据是客观的，但我们得到的答案往往取决于我们提出的问题。如果问题本身就带有偏见，得到的数据也会如此。\n\n例如，关于发展中国家女性的数据，我们所掌握的数据大多与她们的生殖健康相关。因为在很多地方，女性在社会中的主要角色是妻子和母亲，这也是研究者们关注的重点。但是，我们并不清楚她们的收入或资产，因为在许多国家，收入和资产都是按家庭来统计的。由于丈夫往往被视为一家之主，所以已婚女性创造的价值就都被划归到男性名下。\n\n如果我们只能依靠这些有缺陷的数据，就容易低估女性经济活动的价值，也难以衡量女性的经济状况是否得到改善。\n\n三年前，基金会开始投入巨资填补其中一些数据空白。我们和很多其他组织一起，加速推进性别数据革命，包括为数据采集者提供新的工具和培训，以及按性别划分现有数据并从中获取洞察。\n\n数据收集分析的工作听上去很枯燥，实际也的确如此。但如果能善用数据，赋能千千万万的女性，那会是另外一番景象。\n\n几年前我访问肯尼亚时，曾陪同一位名叫克里斯汀的数据采集员前往内罗毕最贫困的地区，挨家挨户做女性调研。她告诉我，她在工作中接触的很多女性从未被问及有关她们生活的问题。克里斯汀说，当她登门拜访并解释来意后，这些妇女能感受到自己受到了重视和关心。\n\n我认为她的观点很有道理。我们选择衡量的对象往往体现了一个社会的价值标准。因此在涉及了解妇女和女童生活的问题上，我们不能接受我不知道”这样的答案。\n\n**5. 跟青少年学习愤怒管理**\n\n**梅琳达：**前年秋天，为了更好地了解贫困和高入狱率之间的关系，我和比尔在佐治亚州立监狱待了一个下午。（我们在去年年信里提到，基金会在美国国内的工作已从公共教育拓展到更多领域，我们着手从多个角度研究美国的贫困问题。）\n\n其中最令人难忘的是我们与几位服刑人员的对话。他们和人们想象中的暴力罪犯的形象大相径庭。在我们的交谈中，他们风趣、友善、善于思考。\n\n我们谈到他们犯罪的原因以及出狱之后的打算。虽然并未谈及犯罪细节（其中有些是严重的暴力犯罪），但他们中的多数认为自己本质并不坏，但交友不慎，一时冲动犯下错误。他们为自己的行为承担责任，并表示如果能够重新来过，他们会有不同的选择。但在关键时刻，他们做出了错误决定。\n\n*“尽管境遇千差万别，但学习控制愤怒与每个人息息相关。”* \n\n美国每天都有很多年轻人陷入类似境地——言语不合，暴力相向，后果是非死即伤。越来越多的研究表明，如果能对年轻人进行干预，辅导他们控制冲动，也许能帮他们更安全地应对这些情况，从而留在学校，远离麻烦。这就是Becoming a Man（成为一个男人，缩写BAM）这样的项目所做的事。\n\n在犯罪高发、帮派横行的社区中，BAM项目帮助年轻人控制自身情绪，从而作出更好的决定。项目的成功引起了广泛关注。芝加哥大学的一项研究发现，BAM项目将参与者的暴力犯罪逮捕率降低了近一半。\n\n去年，比尔参加了BAM项目为高中生组织的小组讨论。他一回家我就看出来，这次活动对他触动很大。他说：“我不只是旁观，还参与了BAM小组的讨论。”\n\n**比尔：**我最初听说BAM，是因为我们的基金会资助了帮助未成年人社交和情感成长的项目。我没想到它的效果这么好，于是想亲眼看看是如何运作的，但没想到让我如此感动。\n\n我参加了一场由几名学生和一位辅导员组成的小组座谈，这样的活动他们每周举行两次。想要参加必须获得小组的正式邀请，于是在学生们邀请我加入之后，我和五个高二高三的男生围坐成一圈。大家开始依次讨论当天的话题。那天赶上的话题是愤怒：你上次生气是什么时候？你当时是如何处理的？是否还有不同的处理方法？\n\n有人讲的是常见的青春烦恼，例如老师对他不公平，打游戏怎么都过不了关。也有一些悲惨的故事：其中一位刚刚目睹家人入狱，另一位的朋友遭受枪击。（为了保护参会者的隐私，我省略了一些细节。）\n\n轮到我的时候，我的答案有些与众不同。我讲的是自己曾经因为得知脊髓灰质炎病例增加而在会议上大发雷霆的事。能够操心这样的问题，是我的幸运。这些小伙子们的烦恼更关乎生活。脊髓灰质炎几乎不在他们最关注的问题之列，对于这一点我完全能够理解。\n\n尽管境遇千差万别，但学习控制愤怒与每个人息息相关。这是重要的人生技能，也是心智成熟的一个表现。回想自己的成长过程，如果我觉得父母做的不公平，我也会对他们很刻薄。在微软工作的时候，我对同事们也很严厉。虽说有时严厉有助于成功，但我相信自己有时候也严厉过头了。\n\n看到这些生活环境艰难的年轻人能比我更早学习这项技能，让我深受触动。他们深入交谈，互相问了一些很有见地的问题。他们在人生的重大挑战面前显示出了非凡的坚韧。\n\n座谈结束后，我还留下来聊了一会儿。我们玩儿自拍，讨论Xbox和PlayStation哪个更好。（我说自己家里用的是Xbox，完全没人感到意外。）\n\n我参加的这个BAM小组已经运作一年了，效果十分显著。组员之间的相敬相亲让我颇受感动。我离开时不禁想到：世界上的每个课堂都应该是这样的感觉。\n\n**6. 全球的也是民族的**\n\n**梅琳达：**最近，我们越来越频繁地听到“民族主义”这个词。它是21世纪政治领域最富内涵的语汇之一。虽然不同的人理解不同（其内涵和暗示也因人而异），但民族主义的核心是将本国的利益放在首位。我想大多数人都会认同这一点。 \n\n我和比尔都热爱自己的国家，认同美国所代表的价值观，同时也赞成领导者们有责任捍卫我们的国家。正是出于这些原因，我们将推动全球合作视为我们的爱国责任。\n\n持同样观点的不只我们两个。去年白宫曾两次威胁大幅削减美国的对外援助预算，当时最强烈的抗议之声正是来自国会议员和美军将领。他们指出，这些投资对于维护美国利益至关重要。\n\n美国和其他国家开展对外援助的主要原因是其有助于提高国外的稳定，进而促进国内安全。加强国外的卫生体系建设，能够降低埃博拉等致命疾病在全球流行的概率。如果所有父母都能在安全的环境下抚养健康的孩子，并让他们接受教育，可能就不会有那么多人背井离乡地去寻求更好的生活。\n\n本国利益至上并不意味着对其他国家置之不理。事实证明，我们恰恰应该反其道而行之。\n\n**比尔：**我们将在未来几年反复强调这一点，因为全球健康已经到了关键的时刻。梅琳达讲的那种只顾自己的方式会导致重大挫败。 \n\n2019年，各国政府需要再次向抗击艾滋病、结核病和疟疾全球基金（全球基金，the Global Fund）作出资助承诺，这是全球健康领域最重大的举措之一。2020年，全球疫苗免疫联盟（Gavi）也将再次募资。\n\n这些项目带给世界的福祉，怎么强调都不为过。自2002年成立以来，全球基金和合作伙伴在防治艾滋病、结核病和疟疾方面的努力已经挽救了2700万生命。自2000年以来，全球疫苗免疫联盟已为超过6.9亿名儿童提供了基础疫苗，相当于为几乎全欧洲人口进行了免疫接种。\n\n这些成果令我惊叹，同时也证明了一点：一旦我们认识到最贫困国家人口的健康和福祉事关所有人，并为此采取行动，我们就能够取得巨大的成就。这项工作的成本效益也很高：富裕国家在医疗援助上的支出只占其预算的0.1%左右。\n\n随着富裕国家将政策重心转向国内，并只顾及自身利益，对外援助的重要性将因此降低，这让我忧心忡忡。即便所有人原则上都认同对外援助的重要性，但政治上的两极分化会导致他们由于政治立场的原因而无法采取行动。\n\n这将带来灾难性的后果。目前有超过1700万艾滋病毒感染者从全球基金获得药物。没有全球基金，他们只能面临死亡。\n\n这是我和梅琳达坚持讲述成功故事的原因之一。当每天的新闻标题都被层出不穷的负面事件占据时，我们想不断提醒大家，全球最贫困国家的数亿人民的生活正在改善，这一定程度上归功于在健康领域的明智投资。即使你只关心本国同胞的福祉，这些投资也是善莫大焉，会让每个人都从中受益。\n\n**7. 厕所还是一百年前的老样子**\n\n**比尔：**差不多八年前，我和梅琳达向全球各地的工程师和科学家们提出了重新发明厕所的挑战。全球迄今还有20多亿人用不上卫生的厕所。他们的粪便未经处理就进入环境，每天导致近800名儿童死亡。引进发达国家的卫生设施行不通，因为配套的下水道系统建设成本过高，而且需要大量的水资源。\n\n2018年，我们在北京举办了新世代厕所博览会。我参观了一些创新厕所的原型机，甚至拿了一瓶人类粪便登台演讲。\n\n目前已有多家企业做好了商业生产准备，产品几乎达到所有要求：杀灭病原体、适应城市快速发展的需求、不依赖污水管网，也不需要外部水源和持续供电就能运行。唯一的美中不足就是成本。为此，盖茨基金会投入了更多资金用于进一步研发，让贫困人口也能用得起这些厕所。  \n \n\n未来厕所看起来可能和这个差别不大\n\n但工作原理会非常不同\n\n新世代厕所长什么样？乍看上去，和普通马桶区别不大，不像从科幻小说里走出来的东西。\n\n但真正的妙处在看不见的地方。和现有的厕所系统不同，未来的厕所自成一体，本身就是一个能杀死病原体并将粪污无害化的微型处理设备。很多厕所甚至能把人类粪尿变为有用的副产品，像农业肥料、洗手用水等。 \n\n新世代厕所未必是世上最炫酷的创新，但它能挽救数以百万计的生命。\n\n**梅琳达：**它们还能改善生活质量，特别是对妇女和女童来说。没有厕所的生活谁都不好过，但承受最大痛苦的还是女性。 \n\n比尔和我都见过这样一些女性，她们不敢冒险走夜路上公厕，所以整夜憋尿，以致肾脏受损。还有另外一些女性，她们只能在露天方便，所以终日控制饮食，等到晚上才能在夜幕的掩护下相对私密地释放自己。一些定性的证据表明，当学校没有像样的厕所时，女生更有可能在经期缺课。（如果了解到月经歧视在很多地方还是那么根深蒂固，你就会明白为什么有些人宁愿缺课误工，也不愿为此蒙羞。）\n \n\n如果你和我一样，我猜厕所可能算不上是你最喜爱的话题。但如果你希望女童能够安心上学、妇女更多地参与经济活动并免受暴力侵害，那我们就得主动讨论厕所的问题。\n\n**8. 课本正在变得过时**\n\n**比尔：**我读过很多教材，但作为学习的一种途径，教材的作用有限。即使是最好的课本，也判断不出哪些内容已经被学生理解，哪些内容还需要辅导。课本肯定也没法告诉老师，学生把昨晚布置的阅读掌握到了什么程度。 \n\n但在软件的帮助下，单纯依赖课本学习的模式即将成为过去。假设你在学高中代数，过去你要阅读课本上关于解方程式的章节，但现在你能在网上阅读文本，观看引人入胜的解题演示视频，通过做游戏来强化概念理解，然后在网上做几道习题。最后软件还会针对你没能完全掌握的知识点出几道新的测验题。 \n\n*“简而言之，我们已经具备重新设计高等教育的工具，使之满足当今学生的需求。”*\n\n这些手段是对教师工作的补充，而非代替。教师能够通过信息丰富的报告了解学生读了哪些书、看了哪些视频、做对了和做错了哪些题，以及还有哪些地方需要辅导。第二天上学时，教师已经充分了解学生的学习情况，并有针对性地提出建议，让共同学习的时间产生最大的效果。\n\n在以往的年信中，我介绍过这类软件，当时更多还停留在设想阶段。但现在美国从幼儿园到高中，已有成千上万的课堂采用了这些工具，以Zearn、i-Ready和LearnZillion为代表的数字化课程软件在全美师生中得到了广泛应用。我资助的一款免费数字化课程《大历史》（Big History）在美国三千多所学校中教授，它能通过软件对学生的书面作业给予实时反馈。\n\n接下来呢？和所有软件的开发过程一样：对现有产品收集海量反馈，采集有效数据，并进行改进和优化。目前有越来越多的州和地方政府树立了在当地学校运用数字化课程软件的信心。我希望这一势头能够带动更多的大型教材出版商，它们目前在推出这些工具方面依旧行动迟缓。\n\n至少到目前为止，我还没听到任何人怀念自己又重又贵的课本。\n\n**梅琳达**：除了配合学生的学习进度，在线工具还能催生新的教学方式，根据学生特点因材施教。\n\n步入2019年，典型的大学生不再是过去的样子：大家一起住宿舍，每年找个暖和的地方休春假，然后四年后毕业。目前美国有近半数的大学生年龄在25岁以上；超过一半的大学生有工作；超过四分之一的大学生有孩子。\n\n这些“非传统”的大学生往往缺乏时间和资源，无法有效适应针对广泛需求而设计的、低效僵化的学习环境。这也是五分之二的大学新生很快退学，或者完全辍学的一大原因。\n\n数字化学习工具能够提高大学教育的经济性、便利性和有效性，从而帮助学生克服这些挑战。\n\n一项研究表明，使用开放课件能为学生平均每门课节省66-121美元。（整个学年算下来，最多能省1000美元，这对继续上学还是辍学能起到决定作用。）另外一项研究发现，用数字化工具学习入门课程的学生成绩好于用传统方式学习的学生。当然，这些学生也有更大的灵活性。他们不用在固定时间出现在课堂里，这对于那些需要兼顾工作和赚钱养家的学生来说意义重大。\n\n总体来说，学生能用更少的钱、更方便地学习，并取得更好的学习效果。简而言之，我们已经具备重新设计高等教育的工具，使之满足当今学生的需求。\n\n**9. 在贫困女性手中，手机的作用能发挥到最大**\n \n\n\n\n\n**梅琳达：**在发达国家，手机能让我们本来的生活更加便利：用电邮取代平邮，不用钻研地图也能畅游世界，也不用站在外面冒雨打车。但对于全球最边缘化的女性而言，手机不只是为了让日子更便利，而且能够开启全新的生活。互联互通正是打破边缘化的解决之道。\n\n如果你是一位从未踏入过银行的女性，手机银行能给你带来参与正规经济、实现财务独立的机会。如果你终日忙于洗衣、做饭、带孩子，一旦在家也能联系客户、获得培训并加入专业组织，那么收入就可能得到大幅提高。如果你担心去当地诊所购买避孕药具会蒙受羞辱，电商配送平台能帮你更好地掌控自己的身体和未来。 \n\n换言之，女性不仅可以通过手机获得服务和机遇，还能让社会移风易俗，打破已经固化的性别不平等的权力结构。\n\n关键是，在手机拥有率和移动互联网使用率方面，两性差距仍然很大。一项最近在亚非拉地区开展的调查发现，不论任何年龄、教育、财富和地域，女性的互联网使用率都要比男性低近40%。\n\n差距之所以存在，有多方面的原因。成本高、不识字（包括数字文盲）和社会风俗是三大首要原因。积极开拓这一市场的手机公司因此制定了面向女性客户的经营策略。在肯尼亚和尼日利亚，推动性别平等和发展方面的项目开始重点对妇女开展数字扫盲。我们正在与哈佛大学肯尼迪政府学院合作，开始尝试打破社会禁锢。\n\n每次提到在女性中普及手机的意义，我就想起去年十月在印尼见到的Nikmah女士。她告诉我，多年来她一直靠卖菜来养活她的三个孩子，但总是入不敷出。后来她离开了家暴的丈夫，经济上更是难上加难。\n\n而现在，Nikmah像其他一百多万印尼人一样，通过Go-Jek这款提供打车、送餐等服务的手机应用谋生。这款流行的应用为她带来了稳定的客流和收入，并通过手机银行账户进行收款，让她能完全掌控自己的钱，不用依靠家暴的男人也能养活子女。通过手机，她还与其他女性同行结成网络，发生意外或急病时可以凑钱互助。\n\nNikmah对我说：“生活就像一个轮子，有时你被它碾下去，有时你也能站上来。”对于像她这样长期在底层挣扎打拼的女性来说，移动技术让她们有了新的机会反抗不公、解救自我。我们需要做的是，打破不平等，确保她们有机会获得移动技术，抓住自立自强的机遇。\n\n**最后一个意外（至少我们希望如此）**\n\n最近常有人问我们对未来是否仍然乐观。我们的回答是肯定的。其中一个原因是我们深信创新的力量。但更重要的是，我们亲眼看到，对于我们在年信中谈及的每一个挑战，都有很多人在奉献着自己的智慧、资源甚至生命。\n\n每当我们觉得负面新闻让我们应接不暇时，我们就提醒自己，我们没有权利袖手旁观，坐等世界变好。我们有责任竭尽全力，推动世界向更好的方向发展。\n\n我们发现乐观主义是最嘹亮的号角，召唤我们行动起来；乐观主义还具有放大效应——为美好未来奋斗的乐观主义者越多，我们就有越有理由感到乐观。\n\n\n \n\n![img](https://app.yinxiang.com/shard/s8/res/f699ea9b-8611-4558-ac50-626eff2adc4f.png)\n\n \n\n更多精彩请关注我们的微信公众号：wepingwest\n\n新闻线索请投稿至：[wire@pingwest.com](mailto://wire@pingwest.com)\n\n*27* 点赞\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/4f7e9cfa-39e1-4ede-bbff-c9ada828c710.jpg)\n\n请「登录」后评论\n\n\n\n\n\n联系方式\n\n- 电话\n\n  +86 010-51078005\n\n- 新闻线索及一般垂询：\n\n  [contact@pingwest.com](mailto:contact@pingwest.com)\n\n- 商务/市场合作\n\n  [marketing@pingwest.com](mailto:marketing@pingwest.com)\n\n关于品玩\n\n- [关于我们](https://www.pingwest.com/about)\n- [工作机会](https://www.pingwest.com/recruiting)\n- [合作伙伴](https://www.pingwest.com/partner)\n- [品玩编辑](https://www.pingwest.com/author)\n\n© 2018 PingWest 品玩 All Rights Reserved 北京品西互动科技有限公司 京ICP备14023153号', 0, '比尔·盖茨发布2019新年信：意料之外', '比尔·盖茨发布2019新年信：意料之外', 0, '2019-03-16 16:16:18', 0, 105, NULL);
INSERT INTO `article` VALUES (16, '## Hi，我们再来聊一聊Java的单例吧\n\n腾儿飞 安卓巴士Android开发者门户 \n\n![img](https://app.yinxiang.com/shard/s8/res/e12a1405-9c84-4c71-a8d5-e3ad34ccd992/640.gif)\n\n## 1. 前言\n\n`单例(Singleton)`应该是开发者们最熟悉的设计模式了，并且好像也是最容易实现的——基本上每个开发者都能够随手写出——但是，真的是这样吗？\n作为一个Java开发者，也许你觉得自己对单例模式的了解已经足够多了。我并不想危言耸听说一定还有你不知道的——毕竟我自己的了解也的确有限，但究竟你自己了解的程度到底怎样呢？往下看，我们一起来聊聊看~\n\n## 2. 什么是单例？\n\n`单例对象的类必须保证只有一个实例存在`——这是维基百科上对单例的定义，这也可以作为对意图实现单例模式的代码进行检验的标准。\n\n对单例的实现可以分为两大类——`懒汉式`和`饿汉式`，他们的区别在于：\n`懒汉式`：指全局的单例实例在第一次被使用时构建。\n`饿汉式`：指全局的单例实例在类装载时构建。\n\n从它们的区别也能看出来，日常我们使用的较多的应该是`懒汉式`的单例，毕竟按需加载才能做到资源的最大化利用嘛~\n\n## 3. 懒汉式单例\n\n先来看一下懒汉式单例的实现方式。\n\n## 3.1 简单版本\n\n看最简单的写法Version 1：\n\n```\n// Version 1\npublic class Single1 {\n    private static Single1 instance;\n    public static Single1 getInstance() {\n        if (instance == null) {\n            instance = new Single1();\n        }\n        return instance;\n    }\n}\n```\n\n或者再进一步，把构造器改为私有的，这样能够防止被外部的类调用。\n\n```\n// Version 1.1\npublic class Single1 {\n    private static Single1 instance;\n    private Single1() {}\n    public static Single1 getInstance() {\n        if (instance == null) {\n            instance = new Single1();\n        }\n        return instance;\n    }\n}\n```\n\n我仿佛记得当初学校的教科书就是这么教的？—— 每次获取instance之前先进行判断，如果instance为空就new一个出来，否则就直接返回已存在的instance。\n这种写法在大多数的时候也是没问题的。**问题在于，当多线程工作的时候，如果有多个线程同时运行到if (instance == null)，都判断为null，那么两个线程就各自会创建一个实例——这样一来，就不是单例了**。\n\n## 3.2 synchronized版本\n\n那既然可能会因为多线程导致问题，那么加上一个同步锁吧！\n修改后的代码如下，相对于Version1.1，只是在方法签名上多加了一个`synchronized`：\n\n```\n// Version 2 \npublic class Single2 {\n    private static Single2 instance;\n    private Single2() {}\n    public static synchronized Single2 getInstance() {\n        if (instance == null) {\n            instance = new Single2();\n        }\n        return instance;\n    }\n}\n```\n\nOK，加上`synchronized`关键字之后，getInstance方法就会锁上了。如果有两个线程（T1、T2）同时执行到这个方法时，会有其中一个线程T1获得同步锁，得以继续执行，而另一个线程T2则需要等待，当第T1执行完毕getInstance之后（完成了null判断、对象创建、获得返回值之后），T2线程才会执行执行。——所以这端代码也就避免了Version1中，可能出现因为多线程导致多个实例的情况。\n但是，这种写法也有一个问题：**给gitInstance方法加锁，虽然会避免了可能会出现的多个实例问题，但是会强制除T1之外的所有线程等待，实际上会对程序的执行效率造成负面影响。**\n\n## 3.3 双重检查（Double-Check）版本\n\nVersion2代码相对于Version1d代码的效率问题，其实是为了解决1%几率的问题，而使用了一个100%出现的防护盾。那有一个优化的思路，就是把100%出现的防护盾，也改为1%的几率出现，使之只出现在可能会导致多个实例出现的地方。\n——有没有这样的方法呢？当然是有的，改进后的代码Vsersion3如下：\n\n```\n// Version 3 \npublic class Single3 {\n    private static Single3 instance;\n    private Single3() {}\n    public static Single3 getInstance() {\n        if (instance == null) {\n            synchronized (Single3.class) {\n                if (instance == null) {\n                    instance = new Single3();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n这个版本的代码看起来有点复杂，注意其中有两次`if (instance == null)`的判断，这个叫做『双重检查 Double-Check』。\n\n- 第一个`if (instance == null)`，其实是为了解决Version2中的效率问题，只有instance为null的时候，才进入`synchronized`的代码段——大大减少了几率。\n- 第二个`if (instance == null)`，则是跟Version2一样，是为了防止可能出现多个实例的情况。\n\n—— 这段代码看起来已经完美无瑕了。\n……\n……\n……\n—— 当然，只是『看起来』，还是有小概率出现问题的。\n这弄清楚为什么这里可能出现问题，首先，我们需要弄清楚几个概念：`原子操作`、`指令重排`。\n\n### 知识点：什么是原子操作？\n\n简单来说，`原子操作（atomic）`就是不可分割的操作，在计算机中，就是指不会因为线程调度被打断的操作。\n比如，简单的赋值是一个原子操作：\n\nm = 6; // 这是个原子操作\n\n假如m原先的值为0，那么对于这个操作，要么执行成功m变成了6，要么是没执行m还是0，而不会出现诸如m=3这种中间态——即使是在并发的线程中。\n\n而，声明并赋值就不是一个原子操作：\n\nint n = 6; // 这不是一个原子操作\n\n对于这个语句，至少有两个操作：\n①声明一个变量n\n②给n赋值为6\n——这样就会有一个中间状态：变量n已经被声明了但是还没有被赋值的状态。\n——这样，在多线程中，由于线程执行顺序的不确定性，如果两个线程都使用m，就可能会导致不稳定的结果出现。\n\n### 知识点：什么是指令重排？\n\n简单来说，就是计算机为了提高执行效率，会做的一些优化，在不影响最终结果的情况下，可能会对一些语句的执行顺序进行调整。\n比如，这一段代码：\n\n```\nint a ;   // 语句1 \na = 8 ;   // 语句2\nint b = 9 ;     // 语句3\nint c = a + b ; // 语句4\n```\n\n正常来说，对于顺序结构，执行的顺序是自上到下，也即1234。\n但是，由于`指令重排`的原因，因为不影响最终的结果，所以，实际执行的顺序可能会变成3124或者1324。\n由于语句3和4没有原子性的问题，语句3和语句4也可能会拆分成原子操作，再重排。\n——也就是说，对于非原子性的操作，在不影响最终结果的情况下，其拆分成的原子操作可能会被重新排列执行顺序。\n\nOK，了解了`原子操作`和`指令重排`的概念之后，我们再继续看Version3代码的问题。\n下面这段话直接从陈皓的文章深入浅出单实例SINGLETON设计模式)中复制而来：\n\n主要在于singleton = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。\n\n- 给 singleton 分配内存\n- 调用 Singleton 的构造函数来初始化成员变量，形成实例\n- 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）\n  但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，**这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错**。\n\n再稍微解释一下，就是说，由于有一个**『instance已经不为null但是仍没有完成初始化』**的中间状态，而这个时候，如果有其他线程刚好运行到第一层`if (instance == null)`这里，这里读取到的instance已经不为null了，所以就直接把这个中间状态的instance拿去用了，就会产生问题。\n这里的关键在于——**线程T1对instance的写操作没有完成，线程T2就执行了读操作**。\n\n## 3.4 终极版本：volatile\n\n对于Version3中可能出现的问题（当然这种概率已经非常小了，但毕竟还是有的嘛~），解决方案是：只需要给instance的声明加上`volatile`关键字即可，Version4版本：\n\n```\n// Version 4 \npublic class Single4 {\n    private static volatile Single4 instance;\n    private Single4() {}\n    public static Single4 getInstance() {\n        if (instance == null) {\n            synchronized (Single4.class) {\n                if (instance == null) {\n                    instance = new Single4();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n`volatile`关键字的一个作用是禁止`指令重排`，把instance声明为`volatile`之后，对它的写操作就会有一个`内存屏障`（什么是内存屏障？），这样，在它的赋值完成之前，就不用会调用读操作。\n\n注意：volatile阻止的不*singleton = new Singleton()*这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（`if (instance == null)`）。\n\n——也就彻底防止了Version3中的问题发生。\n——好了，现在彻底没什么问题了吧？\n……\n……\n……\n好了，别紧张，的确没问题了。大名鼎鼎的EventBus中，其入口方法`EventBus.getDefault()`就是用这种方法来实现的。\n……\n……\n……\n不过，非要挑点刺的话还是能挑出来的，就是这个写法有些复杂了，不够优雅、简洁。\n（傲娇脸）( ￣ー￣)\n\n## 4. 饿汉式单例\n\n下面再聊了解一下饿汉式的单例。\n\n如上所说，`饿汉式`单例是指：指全局的单例实例在类装载时构建的实现方式。\n\n由于类装载的过程是由类加载器（ClassLoader）来执行的，这个过程也是由JVM来保证同步的，所以这种方式先天就有一个优势——能够免疫许多由多线程引起的问题。\n\n## 4.1 饿汉式单例的实现方式\n\n`饿汉式`单例的实现如下：\n\n```\n//饿汉式实现\npublic class SingleB {\n    private static final SingleB INSTANCE = new SingleB();\n    private SingleB() {}\n    public static SingleB getInstance() {\n        return INSTANCE;\n    }\n}\n```\n\n对于一个饿汉式单例的写法来说，它基本上是完美的了。\n所以它的缺点也就只是饿汉式单例本身的缺点所在了——由于INSTANCE的初始化是在类加载时进行的，而类的加载是由ClassLoader来做的，所以开发者本来对于它初始化的时机就很难去准确把握：\n\n- 可能由于初始化的太早，造成资源的浪费\n- 如果初始化本身依赖于一些其他数据，那么也就很难保证其他数据会在它初始化之前准备好。\n\n当然，如果所需的单例占用的资源很少，并且也不依赖于其他数据，那么这种实现方式也是很好的。\n\n### 知识点：什么时候是类装载时？\n\n前面提到了单例在**类装载时**被实例化，那究竟什么时候才是『类装载时』呢？\n\n不严格的说，大致有这么几个条件会触发一个类被加载：\n\n- new一个对象时\n- 使用反射创建它的实例时\n- 子类被加载时，如果父类还没被加载，就先加载父类\n- jvm启动时执行的主类会首先被加载\n\n（类在什么时候加载和初始化?）\n\n## 5. 一些其他的实现方式\n\n## 5.1 Effective Java 1 —— 静态内部类\n\n《Effective Java》一书的第一版中推荐了一个中写法：\n\n```\n// Effective Java 第一版推荐写法\npublic class Singleton {\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    private Singleton (){}\n    public static final Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n这种写法非常巧妙：\n\n- 对于内部类SingletonHolder，它是一个饿汉式的单例实现，在SingletonHolder初始化的时候会由ClassLoader来保证同步，使INSTANCE是一个真·单例。\n- 同时，由于SingletonHolder是一个内部类，只在外部类的Singleton的getInstance()中被使用，所以它被加载的时机也就是在getInstance()方法第一次被调用的时候。\n\n——**它利用了ClassLoader来保证了同步，同时又能让开发者控制类加载的时机。从内部看是一个饿汉式的单例，但是从外部看来，又的确是懒汉式的实现**。\n\n简直是神乎其技。\n\n## 5.2 Effective Java 2 —— 枚举\n\n你以为到这就算完了？不，并没有，因为厉害的大神又发现了其他的方法。\n《Effective Java》的作者在这本书的第二版又推荐了另外一种方法，来直接看代码：\n\n```\n// Effective Java 第二版推荐写法\npublic enum SingleInstance {\n    INSTANCE;\n    public void fun1() { \n        // do something\n    }\n}\n\n// 使用\nSingleInstance.INSTANCE.fun1();\n\n```\n\n看到了么？这是一个枚举类型……连class都不用了，极简。\n由于创建枚举实例的过程是线程安全的，所以这种写法也没有同步的问题。\n\n作者对这个方法的评价：\n\n这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这中方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。\n\n枚举单例这种方法问世一些，许多分析文章都称它是实现单例的最完美方法——写法超级简单，而且又能解决大部分的问题。\n不过我个人认为这种方法虽然很优秀，但是它仍然不是完美的——比如，在需要继承的场景，它就不适用了。\n\n## 6. 总结\n\nOK，看到这里，你还会觉得单例模式是最简单的设计模式了么？再回头看一下你之前代码中的单例实现，觉得是无懈可击的么？\n可能我们在实际的开发中，对单例的实现并没有那么严格的要求。比如，我如果能保证所有的getInstance都是在一个线程的话，那其实第一种最简单的教科书方式就够用了。再比如，有时候，我的单例变成了多例也可能对程序没什么太大影响……\n但是，如果我们能了解更多其中的细节，那么如果哪天程序出了些问题，我们起码能多一个排查问题的点。早点解决问题，就能早点回家吃饭……:-D\n\n—— 还有，完美的方案是不存在，任何方式都会有一个『度』的问题。比如，你的觉得代码已经无懈可击了，但是因为你用的是JAVA语言，可能ClassLoader有些BUG啊……你的代码谁运行在JVM上的，可能JVM本身有BUG啊……你的代码运行在手机上，可能手机系统有问题啊……你生活在这个宇宙里，可能宇宙本身有些BUG啊……o(╯□╰)o\n所以，尽力做到能做到的最好就行了。\n\n## 关于作者\n\nhttps://github.com/barryhappy\nhttp://www.barryzhang.com\n\n\n\n\n\n\n\n**大家都在看**\n\n\n\n[Android组件化最佳实践 ARetrofit原理](http://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&mid=2651944344&idx=1&sn=d1838b36190b6cccd22561cd37a42db3&chksm=84fd677cb38aee6a64fd81e0ad81bfbab777a380c347039a4eda2971dc52af7262130f9e9020&scene=21#wechat_redirect)\n\n[一口吃掉 Material Design](http://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&mid=2651944339&idx=1&sn=d04e4ea1d24263896b82dc57fb6fe4cf&chksm=84fd6777b38aee619b0a6e561b2b93500a3854ea07cf942d258221a4ea9efdf80599c6b896b6&scene=21#wechat_redirect)\n\n[Android开发中的面向切面编程AOP](http://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&mid=2651944327&idx=1&sn=3149ba1913de390e04805df4e8afb8f3&chksm=84fd6763b38aee7553aab2c9d2ed51d3bd9d4336da1a12fc70c56b566134f5f7e368851e72f3&scene=21#wechat_redirect)\n\n[搞事情，自定义LayoutInflate实现酷炫引导页](http://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&mid=2651944322&idx=1&sn=0d3cf0c855f51439f2852325ac526c7a&chksm=84fd6766b38aee708c1bf420ac483a8330287fa291e933e59b4d88ec498b602b07a3b0905079&scene=21#wechat_redirect)\n\n\n\n*欢迎前往安卓巴士***博客区***投稿，技术成长于分享*\n\n*期待巴友****留言****，共同探讨学习*\n\n\n\n![img](https://app.yinxiang.com/shard/s8/res/5d2e9937-ef56-4207-a3b5-6c94fd262600/640.gif)\n\n[阅读原文](https://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&mid=2651944352&idx=1&sn=5042ac122337df13d21aa9a08d633075&chksm=84fd6744b38aee52d18b70deb7b7f4b51e8bf0ebf84cc4d9566999ba878412f6b5947f8f6c58&mpshare=1&scene=1&srcid=##)', 0, 'Hi，我们再来聊一聊Java的单例吧', 'Hi，我们再来聊一聊Java的单例吧', 0, '2019-03-16 16:18:36', 0, 106, NULL);
INSERT INTO `article` VALUES (17, '# [ ES6 Promise 用法讲解](https://www.cnblogs.com/whybxy/p/7645578.html)\n\n\n\nPromise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\n\n那就new一个\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n```\nvar p = new Promise(function(resolve, reject){\n    //做一些异步操作\n    setTimeout(function(){\n        console.log(\'执行完成\');\n        resolve(\'随便什么数据\');\n    }, 2000);\n});\n```\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\nPromise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。\n\n \n\n在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。\n\n \n\n运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n```\nfunction runAsync(){\n    var p = new Promise(function(resolve, reject){\n        //做一些异步操作\n        setTimeout(function(){\n            console.log(\'执行完成\');\n            resolve(\'随便什么数据\');\n        }, 2000);\n    });\n    return p;            \n}\nrunAsync()\n```\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(\'随便什么数据\');这是干毛的？\n\n \n\n我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码：\n\n```\nrunAsync().then(function(data){\n    console.log(data);\n    //后面可以用传过来的数据做些其他操作\n    //......\n});\n```\n\n在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。\n\n \n\n这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。\n\n \n\n你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样：\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n```\nfunction runAsync(callback){\n    setTimeout(function(){\n        console.log(\'执行完成\');\n        callback(\'随便什么数据\');\n    }, 2000);\n}\n\nrunAsync(function(data){\n    console.log(data);\n});\n```\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。\n\n \n\n## **链式操作的用法**\n\n所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n```\nrunAsync1()\n.then(function(data){\n    console.log(data);\n    return runAsync2();\n})\n.then(function(data){\n    console.log(data);\n    return runAsync3();\n})\n.then(function(data){\n    console.log(data);\n});\n```\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下：\n\n![img](https://app.yinxiang.com/shard/s8/res/10da2fa2-f13c-4440-ad08-2cbc5382349a/520134-20160311004311507-221152206.png)\n\n猜猜runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？没错，就是下面这样\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n```\nfunction runAsync1(){\n    var p = new Promise(function(resolve, reject){\n        //做一些异步操作\n        setTimeout(function(){\n            console.log(\'异步任务1执行完成\');\n            resolve(\'随便什么数据1\');\n        }, 1000);\n    });\n    return p;            \n}\nfunction runAsync2(){\n    var p = new Promise(function(resolve, reject){\n        //做一些异步操作\n        setTimeout(function(){\n            console.log(\'异步任务2执行完成\');\n            resolve(\'随便什么数据2\');\n        }, 2000);\n    });\n    return p;            \n}\nfunction runAsync3(){\n    var p = new Promise(function(resolve, reject){\n        //做一些异步操作\n        setTimeout(function(){\n            console.log(\'异步任务3执行完成\');\n            resolve(\'随便什么数据3\');\n        }, 2000);\n    });\n    return p;            \n}\n```\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们把上面的代码修改成这样：\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n```\nrunAsync1()\n.then(function(data){\n    console.log(data);\n    return runAsync2();\n})\n.then(function(data){\n    console.log(data);\n    return \'直接返回数据\';  //这里直接返回数据\n})\n.then(function(data){\n    console.log(data);\n});\n```\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n那么输出就变成了这样：\n\n![img](https://app.yinxiang.com/shard/s8/res/628113ef-4d61-459e-82f0-6afbdf3455b7/520134-20160311004444163-67067993.png)\n\n## **reject的用法**\n\n到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n```\nfunction getNumber(){\n    var p = new Promise(function(resolve, reject){\n        //做一些异步操作\n        setTimeout(function(){\n            var num = Math.ceil(Math.random()*10); //生成1-10的随机数\n            if(num<=5){\n                resolve(num);\n            }\n            else{\n                reject(\'数字太大了\');\n            }\n        }, 2000);\n    });\n    return p;            \n}\n\ngetNumber()\n.then(\n    function(data){\n        console.log(\'resolved\');\n        console.log(data);\n    }, \n    function(reason, data){\n        console.log(\'rejected\');\n        console.log(reason);\n    }\n);\n```\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\ngetNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。\n\n \n\n运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：\n\n![img](https://app.yinxiang.com/shard/s8/res/29f123d5-c003-4d71-a791-6ceec0893db9/520134-20160311004607960-1156803894.png)或者![img](https://app.yinxiang.com/shard/s8/res/d248f3b8-cf4d-4c22-8e75-e0da185950ed/520134-20160311004616257-1024778840.png)\n\n## **catch的用法**\n\n我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样：\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n```\ngetNumber()\n.then(function(data){\n    console.log(\'resolved\');\n    console.log(data);\n})\n.catch(function(reason){\n    console.log(\'rejected\');\n    console.log(reason);\n});\n\n```\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n```\ngetNumber()\n.then(function(data){\n    console.log(\'resolved\');\n    console.log(data);\n    console.log(somedata); //此处的somedata未定义\n})\n.catch(function(reason){\n    console.log(\'rejected\');\n    console.log(reason);\n});\n\n```\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：\n\n![img](https://app.yinxiang.com/shard/s8/res/5d1df64a-8938-45aa-b0a1-e6ce7a13c96b/520134-20160311004747147-1508291069.png)\n\n \n\n也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。\n\n## **all的用法**\n\nPromise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)\n\n```\nPromise\n.all([runAsync1(), runAsync2(), runAsync3()])\n.then(function(results){\n    console.log(results);\n});\n\n```\n\n![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：\n\n![img](https://app.yinxiang.com/shard/s8/res/9399516e-b451-4ee4-934d-13ee0c20a81f/520134-20160311004843491-346782307.png)\n\n \n\n有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。\n\n \n\n## **race的用法**\n\nall方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下：\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)\n\n```\nPromise\n.race([runAsync1(), runAsync2(), runAsync3()])\n.then(function(results){\n    console.log(results);\n});\n\n```\n\n![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的：\n\n![img](https://app.yinxiang.com/shard/s8/res/62012a78-2392-4b79-bcb3-7c4bb7d9ceaa/520134-20160311004946022-706413123.png)\n\n \n\n你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。\n\n \n\n这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)\n\n```\n//请求某个图片资源\nfunction requestImg(){\n    var p = new Promise(function(resolve, reject){\n        var img = new Image();\n        img.onload = function(){\n            resolve(img);\n        }\n        img.src = \'xxxxxx\';\n    });\n    return p;\n}\n\n//延时函数，用于给请求计时\nfunction timeout(){\n    var p = new Promise(function(resolve, reject){\n        setTimeout(function(){\n            reject(\'图片请求超时\');\n        }, 5000);\n    });\n    return p;\n}\n\nPromise\n.race([requestImg(), timeout()])\n.then(function(results){\n    console.log(results);\n})\n.catch(function(reason){\n    console.log(reason);\n});\n\n```\n\n![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)\n\n[![img](https://app.yinxiang.com/shard/s8/res/0b2cb702-d081-479e-b061-e4f4387c0674/copycode.gif)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\nrequestImg函数会异步请求一张图片，我把地址写为\"xxxxxx\"，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：\n\n![img](https://app.yinxiang.com/shard/s8/res/9c4ad5c3-14a6-466d-b723-3bc8eed2977f/520134-20160311005040272-341718790.png)\n\n \n\n\n\n分类: [JavaScript](https://www.cnblogs.com/whybxy/category/1025829.html)\n\n\n\n[好文要顶](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#) [关注我](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#) [收藏该文](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#) [![img](https://app.yinxiang.com/shard/s8/res/6901b42e-7926-4df9-8e5c-33e11cea7a51/icon_weibo_24.png)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#) [![img](https://app.yinxiang.com/shard/s8/res/3ebc00dc-b193-4ba6-afb4-cd01fcc1d627/wechat.png)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n![img](https://app.yinxiang.com/shard/s8/res/b3278e9e-fd5e-4277-a187-c6277d2aaf51/20170207115014.png)\n\n[王汉炎](http://home.cnblogs.com/u/whybxy/)\n[关注 - 13](http://home.cnblogs.com/u/whybxy/followees)\n[粉丝 - 19](http://home.cnblogs.com/u/whybxy/followers)\n\n\n\n\n\n[+加关注](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n39\n\n0\n\n\n\n\n\n\n\n[« ](https://www.cnblogs.com/whybxy/p/7605290.html)上一篇：[shareSDK.js web版的使用](https://www.cnblogs.com/whybxy/p/7605290.html)\n[» ](https://www.cnblogs.com/whybxy/p/8458454.html)下一篇：[linux](https://www.cnblogs.com/whybxy/p/8458454.html)\n\nposted @ 2017-10-10 14:49 [王汉炎](https://www.cnblogs.com/whybxy/) 阅读(106999) 评论(12) [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=7645578) [收藏](https://www.cnblogs.com/whybxy/p/7645578.html#)\n\n\n\n\n\n评论列表\n\n\n\n  \n\n\\#1楼\n\n\n\n \n\n2018-04-02 16:44\n\n \n\nhubgit\n\n \n\n \n\nniubility，很详细\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#2楼\n\n\n\n \n\n2018-05-04 16:33\n\n \n\nJoker陈\n\n \n\n \n\n很不错\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#3楼\n\n\n\n \n\n2018-06-01 15:40\n\n \n\n雨的印记丨\n\n \n\n \n\n知道了，谢谢。\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#4楼\n\n\n\n \n\n2018-07-02 10:47\n\n \n\n孟差外\n\n \n\n \n\n学习了，谢谢\n\n[支持(1)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#5楼\n\n\n\n \n\n2018-07-11 10:26\n\n \n\nweb-慰尘\n\n \n\n \n\nall方法的效果实际上是「谁跑的慢，以谁为准执行回调」,但是有个前提，就是结果全是fulfilled状态，假如中间有个结果时rejected状态了，即使其他异步函数没有结果，这时也会调用all方法\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#6楼\n\n\n\n \n\n2018-08-03 13:55\n\n \n\n独孤的根号3\n\n \n\n \n\n有一个地方我是死活想不明白：\n第三段代码\nrunAsync().then(function(data){\n\n这个data到底是在哪定义的？\n我们在promise的定义中，给resolve传递什么，data就是什么？\n那是怎么实现的？\ndata是promise内部定义的变量？？\n我把data换成data1行不行？\n查了半天没查到相关的资料，然后MDN还打不开。。。MSDN倒是可以打开，但是也没解释data是怎么来的。\n求楼主解释，谢谢！\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#7楼\n\n\n\n \n\n2018-08-08 09:04\n\n \n\n魅影独秀\n\n \n\n \n\n我是有段代码不太理解.then(\nfunction(data){\nconsole.log(\'resolved\');\nconsole.log(data);\n}, \nfunction(reason, data){\nconsole.log(\'rejected\');\nconsole.log(reason);\n}\n);\n这样的，当传过来的参数为一个时执行第一个方法，当传过来2个参数执行第二个方法，.catch就是在这个基础上分离出来的吧。\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#8楼\n\n\n\n \n\n2018-09-08 16:46\n\n \n\nwebshhhhh\n\n \n\n \n\n[@](https://www.cnblogs.com/whybxy/p/7645578.html#4034846) 独孤的根号3\nPromise的原型上有一个then方法，可以供Promise的实例来调用，这个then方法有两个实参分别表示，Promise构造函数当中的resolve成功，和reject失败\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#9楼\n\n\n\n \n\n2018-10-09 11:19\n\n \n\n咖飞哥\n\n \n\n \n\n从用法上讲，讲的已经很完善。就差内部原理了。\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#10楼\n\n\n\n \n\n2018-10-30 21:59\n\n \n\n瓮豪\n\n \n\n \n\n[@](https://www.cnblogs.com/whybxy/p/7645578.html#4034846) 独孤的根号3\n我觉得这个data是个形参，怎么定义都行，实参给他传递什么，这个data就能接收什么\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#11楼\n\n\n\n \n\n2018-11-22 09:39\n\n \n\n新酒\n\n \n\n \n\n我在另外一篇博客看过一模一样的。。。博主不标注原文出处吗？？？？\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n  \n\n\\#12楼\n\n\n\n \n\n2019-01-10 09:38\n\n \n\nDreamRedirect\n\n \n\n \n\n[@](https://www.cnblogs.com/whybxy/p/7645578.html#4034846) 独孤的根号3\ndata 就是回调的结果集，即reject()解析之后的结果集\n\n[支持(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[反对(0)](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)\n\n\n\n\n\n\n\n[刷新评论](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)[刷新页面](https://www.cnblogs.com/whybxy/p/7645578.html#)[返回顶部](https://www.cnblogs.com/whybxy/p/7645578.html#top)\n\n注册用户登录后才能发表评论，请 [登录](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#) 或 [注册](https://app.yinxiang.com/Home.action?_sourcePage=yNkSIdgO_4_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=JXnVS8mvjXA3yWPvuidLz-TPR6I9Jhx8&hpts=1552722016744&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=980742324%40qq.com&hptsh=HHT0TkRrD42Lw%2Fc5k0OiIUFuQPM%3D#)，[访问](http://www.cnblogs.com/)网站首页。\n\n\n\n[【推荐】超50万VC++源码: 大型组态工控、电力仿真CAD与GIS源码库！](http://www.ucancode.com/index.htm)\n\n\n\n\n\n**相关博文：**\n· [关于Promise 简单使用理解](https://www.cnblogs.com/inzaghihao/p/7766614.html)\n· [大白话讲解Promise（一）](https://www.cnblogs.com/Andy692126/p/5379035.html)\n· [大白话讲解Promise](https://www.cnblogs.com/AfterStories/articles/5384063.html)\n· [深入理解ES6里的promise](https://www.cnblogs.com/goloving/p/8045131.html)\n· [Es6 Promise 用法详解](https://www.cnblogs.com/guoxianglei/p/7238993.html)\n\n\n\n**最新新闻**：\n· [快手上的“致富经”：新内容的呈现和新关系的构建带来潜在商机](https://news.cnblogs.com/n/618110/)\n· [当出行独角兽Uber开始“觊觎”两轮自动驾驶](https://news.cnblogs.com/n/618112/)\n· [不是百度死了，是PC端内容没了](https://news.cnblogs.com/n/618114/)\n· [英国首富戴森传奇人生：靠颠覆吸尘器造富 欲颠覆电动车](https://news.cnblogs.com/n/618118/)\n· [一边上市，一边跑路：175号文出台，能否驯服P2P猛兽？](https://news.cnblogs.com/n/618115/)\n» [更多新闻...](http://news.cnblogs.com/)', 0, 'ES6 Promise 用法讲解 - 王汉炎 - 博客园', 'ES6 Promise 用法讲解 - 王汉炎 - 博客园', 1, '2019-03-16 17:00:19', 65, 107, NULL);
INSERT INTO `article` VALUES (18, '\n\n\n\n花裤衩\n\n2017年11月29日阅读 47171\n\n\n\n# 手摸手，带你优雅的使用 icon\n\n## 前言\n\n> 本篇文章其实陆陆续续写了快半年，主体部分写好了很久了，但由于种种原因一直没有发布。 首先来说说写这篇文章的主要初衷是：在做前端后台项目的时候经常会用到很多 icon 图标，刚开始还好，但随着项目的不断迭代，每次修改添加图标会变得很麻烦，而且总觉得不够优雅，就开始琢磨着有啥简单方便的工作流呢？\n\n## 演进史\n\n首先我们来说一下前端 icon 的发展史。\n\n**远古时代** 在我刚开始实习时，大部分图标都是用 img 来实现的。渐渐发现一个页面的请求资源中图片 img 占了大部分，所以为了优化有了`image sprite` 就是所谓的雪碧图，就是将多个图片合成一个图片，然后利用 css 的 background-position 定位显示不同的 icon 图标。但这个也有一个很大的痛点，维护困难。每新增一个图标，都需要改动原始图片，还可能不小心出错影响到前面定位好的图片，而且一修改雪碧图，图片缓存就失效了，久而久之你不知道该怎么维护了。\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n8.4 KB\n\n](https://app.yinxiang.com/shard/s8/res/02397d70-7ad3-45b2-9f72-5d311e68e00f/1)\n\n\n\n\n\n**font 库** 后来渐渐地一个项目里几乎不会使用任何本地的图片了，而使用一些 font 库来实现页面图标。常见的如 [Font Awesome](https://link.juejin.im/?target=http%3A%2F%2Ffontawesome.io%2F) ，使用起来也非常的方便，但它有一个致命的缺点就是找起来真的很不方便，每次找一个图标特别的费眼睛，还有就是它的定制性也非常的不友善，它的图标库一共有675个图标，说少也不少，但还是会常常出现找不到你所需要图标的情况。当然对于没有啥特别 ui 追求的初创公司来说还是能忍一忍的。但随着公司的壮大，来了越来越多对前端指手画脚的人，丧心病狂的设计师，他们会说不！这icon这么丑，这简直是在侮辱他们高级设计师的称号啊！不过好在这时候有了[iconfont](https://link.juejin.im/?target=http%3A%2F%2Ficonfont.cn%2F) 。\n\n**iconfont** 一个阿里爸爸做的开源图库，人家还有专门的 [github issue](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fthx%2Ficonfont-plus%2Fissues)(虽然我的一个 issue 半年多了也没回应/(ㄒoㄒ)/~~)，但人家的图标数量还是很惊人的，不仅有几百个公司的开源图标库，还有各式各样的小图标，还支持自定义创建图标库，所以不管你是一家创业公司还是对设计很有要求的公司，它都能很好的帮助你解决管理图标的痛点。你想要的基本都有~\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n828 bytes\n\n](https://app.yinxiang.com/shard/s8/res/bd651d4e-0182-4a86-8f53-58c3ad969e52/1)\n\n\n\n\n\n## iconfont 三种使用姿势\n\n### unicode\n\n最开始我们使用了`unicode`的格式，它主要的特点是 **优势**\n\n- 兼容性最好，支持ie6+\n- 支持按字体的方式去动态调整图标大小，颜色等等\n\n**劣势**\n\n- 不支持多色图标\n- 在不同的设备浏览器字体的渲染会略有差别，在不同的浏览器或系统中对文字的渲染不同，其显示的位置和大小可能会受到font-size、line-height、word-spacing等CSS属性的影响，而且这种影响调整起来较为困难\n\n**使用方法：** 第一步：引入自定义字体 `font-face\n\n```\n @font-face {\n   font-family: \"iconfont\";\n   src: url(\'iconfont.eot\'); /* IE9*/\n   src: url(\'iconfont.eot#iefix\') format(\'embedded-opentype\'), /* IE6-IE8 */\n   url(\'iconfont.woff\') format(\'woff\'), /* chrome, firefox */\n   url(\'iconfont.ttf\') format(\'truetype\'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n   url(\'iconfont.svg#iconfont\') format(\'svg\'); /* iOS 4.1- */\n }\n复制代码\n```\n\n第二步：定义使用iconfont的样式\n\n```\n.iconfont {\n  font-family:\"iconfont\" !important;\n  font-size:16px;\n  font-style:normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n复制代码\n```\n\n第三步：挑选相应图标并获取字体编码，应用于页面\n\n```\n<i class=\"iconfont\">&#xe604;</i>\n复制代码\n```\n\n效果图：\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n4.5 KB\n\n](https://app.yinxiang.com/shard/s8/res/faeb04ca-3248-4de9-b030-21c270998326/1)\n\n\n\n\n\n其实它的原理也很简单，就是通过 `@font-face` 引入自定义字体(其实就是一个字体库)，它里面规定了`&#xe604` 这个对应的形状就长这企鹅样。其实类似于 \'花裤衩\'，在不同字体设定下长得是不同的一样。\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n4.3 KB\n\n](https://app.yinxiang.com/shard/s8/res/2382befa-0cc0-4925-8890-8ae0e6ee0693/1)\n\n\n\n\n\n不过它的缺点也显而易见，`unicode`的书写不直观，语意不明确。光看`&#xe604;`这个`unicode`你完全不知道它代表的是什么意思。这时候就有了 `font-class`。\n\n### font-class\n\n与unicode使用方式相比，具有如下特点：\n\n- 兼容性良好，支持ie8+\n- 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。\n\n**使用方法：** 第一步：拷贝项目下面生成的fontclass代码：\n\n```\n../font_8d5l8fzk5b87iudi.css\n复制代码\n```\n\n第二步：挑选相应图标并获取类名，应用于页面：\n\n```\n<i class=\"iconfont icon-xxx\"></i>\n复制代码\n```\n\n效果图：\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n5.3 KB\n\n](https://app.yinxiang.com/shard/s8/res/a11e74e3-34fe-49b8-837f-74e0dbe4bc65/1)\n\n\n\n\n\n它的主要原理其实是和 `unicode` 一样的，它只是多做了一步，将原先`&#xe604`这种写法换成了`.icon-QQ`，它在每个 class 的 before 属性中写了`unicode`,省去了人为写的麻烦。如 `.icon-QQ:before { content: \"\\e604\"; }`\n\n相对于`unicode` 它的修改更加的方便与直观。但也有一个大坑，之前楼主一个项目中用到了两组`font-class` 由于没有做好命名空间，所有的class都是放在`.iconfont` 命名空间下的，一上线引发了各种雪崩问题，修改了半天，所以使用`font-class`一定要注意命名空间的问题。\n\n### symbol\n\n随着万恶的某某浏览器逐渐淡出历史舞台，svg-icon 使用形式慢慢成为主流和推荐的方法。相关文章可以参考张鑫旭大大的文章[未来必热：SVG Sprite技术介绍](https://link.juejin.im/?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2014%2F07%2Fintroduce-svg-sprite-technology%2F%3Fspm%3Da313x.7781069.1998910419.50)\n\n- 支持多色图标了，不再受单色限制。\n- 支持像字体那样通过font-size,color来调整样式。\n- 支持 ie9+\n- 可利用CSS实现动画。\n- 减少HTTP请求。\n- 矢量，缩放不失真\n- 可以很精细的控制SVG图标的每一部分\n\n**使用方法：** 第一步：拷贝项目下面生成的symbol代码：\n\n```\n引入  ./iconfont.js\n复制代码\n```\n\n第二步：加入通用css代码（引入一次就行）：\n\n```\ncss<style type=\"text/css\">\n    .icon {\n       width: 1em; height: 1em;\n       vertical-align: -0.15em;\n       fill: currentColor;\n       overflow: hidden;\n    }\n</style>\n复制代码\n```\n\n第三步：挑选相应图标并获取类名，应用于页面：\n\n```\nhtml<svg class=\"icon\" aria-hidden=\"true\">\n    <use xlink:href=\"#icon-xxx\"></use>\n</svg>\n复制代码\n```\n\n使用svg-icon的好处是我再也不用发送`woff|eot|ttf|` 这些很多个字体库请求了，我所有的svg都可以内联在html内。\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n61.5 KB\n\n](https://app.yinxiang.com/shard/s8/res/09827389-4c62-4853-81c3-439d6480e692/1)\n\n\n\n还有一个就是 svg 是一个真正的矢量，不管你再怎么的放缩它都不会失真模糊，而且svg可以控制的属性也更加的丰富，也能做出更加生动和复杂的图标。现在ui设计师平时都喜欢使用 sketch 来工作，只要轻松一键就能导出 svg 了，所以 svg 也更受设计师的青睐。\n\nInline SVG vs Icon Fonts \n\n这篇文章详细的比较了\n\n \n\n```\nsvg\n\n```\n\n \n\n和\n\n \n\n```\nicon-font\n\n```\n\n的优劣，大家可以去看看。PS：这里其实还用到了\n\n \n\n```\nSVG Sprite\n\n```\n\n \n\n技术。简单的理解就是类 svg 的似雪碧图，它在一个 svg 之中运用 symbol 标示了一个一个的 svg 图标，这样一个页面中我们遇到同样的 svg 就不用重复再画一个了，直接使用\n\n```\n<use xlink:href=\"#icon-QQ\" x=\"50\" y=\"50\" />\n\n```\n\n \n\n就能使用了，具体的细节可以看这篇文章开头的文章\n\n \n\n未来必热：SVG Sprite技术介绍\n\n，在之后的文章中也会手摸手叫你自己如何制作\n\n \n\n```\nSVG Sprite\n\n```\n\n。\n\n\n\n## 创建 icon-component 组件\n\n我们有了图标，接下来就是如何在自己的项目中优雅的使用它了。 之后的代码都是基于 vue 的实例(ps: react 也很简单，原理都是类似的)\n\n```\nhtml//components/Icon-svg\n<template>\n  <svg class=\"svg-icon\" aria-hidden=\"true\">\n    <use :xlink:href=\"iconName\"></use>\n  </svg>\n</template>\n\n<script>\nexport default {\n  name: \'icon-svg\',\n  props: {\n    iconClass: {\n      type: String,\n      required: true\n    }\n  },\n  computed: {\n    iconName() {\n      return `#icon-${this.iconClass}`\n    }\n  }\n}\n</script>\n\n<style>\n.svg-icon {\n  width: 1em;\n  height: 1em;\n  vertical-align: -0.15em;\n  fill: currentColor;\n  overflow: hidden;\n}\n</style>\n\n\n复制代码\njavascript//引入svg组件\nimport IconSvg from \'@/components/IconSvg\'\n\n//全局注册icon-svg\nVue.component(\'icon-svg\', IconSvg)\n\n//在代码中使用\n<icon-svg icon-class=\"password\" />\n复制代码\n\n```\n\n就这样简单封装了一个 `Icon-svg` 组件 ，我们就可以简单优雅的在自己的vue项目之中使用图标了。\n\n## 进一步改造\n\n但作为一个有逼格的前端开发，怎能就此满足呢!目前还是有一个致命的缺点的，就是现在所有的 `svg-sprite` 都是通过 iconfont 的 `iconfont.js` 生成的。\n\n- 首先它是一段用js来生成svg的代码，所有图标 icon 都很**不直观**。\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n89.3 KB\n\n](https://app.yinxiang.com/shard/s8/res/dab4ab5c-3a84-4249-8be5-895362d2b73f/1)\n\n\n\n你完全不知道哪个图标名对应什么图标，一脸尼克扬问号??? 每次增删改图标只能整体js文件一起替换。\n\n\n\n- 其次它也做不到**按需加载**，不能根据我们使用了那些 svg 动态的生成 `svg-sprite`。\n- **自定义性差**，通常导出的svg包含大量的无用信息，例如编辑器源信息、注释等。通常包含其它一些不会影响渲染结果或可以移除的内容。\n- **添加不友善**，如果我有一些自定义的svg图标，该如何和原有的 `iconfont` 整合到一起呢？目前只能将其也上传到 `iconfont` 和原有的图标放在一个项目库中，之后再重新下载，很繁琐。\n\n### 使用 svg-sprite\n\n接下来我们就要自己来制作 `svg-sprite` 了。这里要使用到 [svg-sprite-loader](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fkisenka%2Fsvg-sprite-loader) 这个神器了， 它是一个 webpack loader ，可以将多个 svg 打包成 `svg-sprite` 。\n\n我们来介绍如何在 `vue-cli` 的基础上进行改造，加入 `svg-sprite-loader`。\n\n我们发现`vue-cli`默认情况下会使用 `url-loader` 对svg进行处理，会将它放在`/img` 目录下，所以这时候我们引入`svg-sprite-loader` 会引发一些冲突。\n\n```\njs//默认`vue-cli` 对svg做的处理，正则匹配后缀名为.svg的文件，匹配成功之后使用 url-loader 进行处理。\n {\n    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n    loader: \'url-loader\',\n    options: {\n      limit: 10000,\n      name: utils.assetsPath(\'img/[name].[hash:7].[ext]\')\n    }\n}\n复制代码\n\n```\n\n解决方案有两种，最简单的就是你可以将 test 的 svg 去掉，这样就不会对svg做处理了，当然这样做是很不友善的。\n\n- 你不能保证你所有的 svg 都是用来当做 icon的，有些真的可能只是用来当做图片资源的。\n- 不能确保你使用的一些第三方类库会使用到 svg。\n\n所以最安全合理的做法是使用 webpack 的 [exclude](https://link.juejin.im/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23rule-exclude) 和 [include](https://link.juejin.im/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23rule-include) ，让`svg-sprite-loader`只处理你指定文件夹下面的 svg，`url-loaer`只处理除此文件夹之外的所以 svg，这样就完美解决了之前冲突的问题。 代码如下\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n9.3 KB\n\n](https://app.yinxiang.com/shard/s8/res/5a973a71-dfbe-402f-9953-c4faffa4c7e6/1)\n\n\n\n\n\n这样配置好了，只要引入svg之后填写类名就可以了\n\n```\njsimport \'@/src/icons/qq.svg; //引入图标\n\n<svg><use xlink:href=\"#qq\" /></svg>  //使用图标\n\n复制代码\n\n```\n\n单这样还是非常的不优雅，如果我项目中有一百个 icon，难不成我要手动一个个引入么！ **偷懒是程序员的第一生产力！！！**\n\n## 自动导入\n\n首先我们创建一个专门放置图标 icon 的文件夹如：`@/src/icons`，将所有 icon 放在这个文件夹下。 之后我们就要使用到 webpack 的 [require.context](https://link.juejin.im/?target=https%3A%2F%2Fwebpack.js.org%2Fguides%2Fdependency-management%2F%23require-context)。很多人对于 `require.context`可能比较陌生，直白的解释就是\n\n> require.context(\"./test\", false, /.test.js$/); 这行代码就会去 test 文件夹（不包含子目录）下面的找所有文件名以 `.test.js` 结尾的文件能被 require 的文件。 更直白的说就是 我们可以通过正则匹配引入相应的文件模块。\n\nrequire.context有三个参数：\n\n- directory：说明需要检索的目录\n- useSubdirectories：是否检索子目录\n- regExp: 匹配文件的正则表达式\n\n了解这些之后，我们就可以这样写来自动引入 `@/src/icons` 下面所有的图标了\n\n```\njsconst requireAll = requireContext => requireContext.keys().map(requireContext)\nconst req = require.context(\'./svg\', false, /\\.svg$/)\nrequireAll(req)\n复制代码\n\n```\n\n之后我们增删改图标直接直接文件夹下对应的图标就好了，什么都不用管，就会自动生成 `svg symbol`了。\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n25.7 KB\n\n](https://app.yinxiang.com/shard/s8/res/c5c0fdf7-132b-47db-86d2-ad17ac281f32/1)\n\n\n\n\n\n## 更进一步优化自己的svg\n\n首先我们来看一下 从 `阿里iconfont` 网站上导出的 svg 长什么样？\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n68.8 KB\n\n](https://app.yinxiang.com/shard/s8/res/be988bf9-2a0b-405f-ae34-7e6329680a17/1)\n\n\n\n\n\n没错虽然 iconfont 网站导出的 svg 内容已经算蛮精简的了，但你会发现其实还是与很多无用的信息，造成了不必要的冗余。就连 iconfont 网站导出的 svg 都这样，更不用说那些更在意 ui漂不漂亮不懂技术的设计师了(可能)导出的svg了。好在 `svg-sprite-loader`也考虑到了这点，它目前只会获取 svg 中 path 的内容，而其它的信息一概不会获取。生成 svg 如下图：\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n24.1 KB\n\n](https://app.yinxiang.com/shard/s8/res/1a09aa67-d69a-4af4-9068-2064cc450299/1)\n\n\n\n\n\n但任何你在 path 中产生的冗余信息它就不会做处理了。如注释什么的\n\n\n\n[![img](https://app.yinxiang.com/images/file-generic.png)1\n40.6 KB\n\n](https://app.yinxiang.com/shard/s8/res/cf709ce0-d1b6-4bc3-9f2a-9bd801500683/1)\n\n\n\n\n\n这时候我们就要使用另一个很好用的东西了-- [svgo](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsvg%2Fsvgo)\n\n> SVG files, especially exported from various editors, usually contain a lot of redundant and useless information such as editor metadata, comments, hidden elements, default or non-optimal values and other stuff that can be safely removed or converted without affecting SVG rendering result.\n\n它支持几十种优化项，非常的强大，8k+的star 也足以说明了问题。\n\n详细的操作可以参照 [官方文档](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsvg%2Fsvgo) [张鑫旭大大的文章](https://link.juejin.im/?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2016%2F02%2Fsvg-compress-tool-svgo-experience%2F)（没错又是这位大大的文章，或许这就是大佬吧！）本文就不展开了。\n\n## 写在最后\n\n上面大概阐述了一下前端项目中 icon 使用的演进史。 总的来说还是那句话，**适合的才是最好的**。就拿之前争论的选择 vue react 还是 angular，个人觉得每个框架都有自己的特点和适用的业务场景，所以所有不结合业务场景的推荐和讨论都是瞎bb。。。如上文其实大概讲了五种前端icon的使用场景，第一种`Font Awesome`不用它并不是因为它不好，而是业务场景不适合，如果你团队没有专门的设计师或者对 icon 的自定义度不高完全可以使用它，[Font Awesome](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FFortAwesome%2FFont-Awesome) github有五万多 star，足见社区对它的认可。还比如说，你们项目对低端浏览器有较高的适配要求，你还强行要用 svg 作为图标 icon，那你真的是存心和自己过不去了。所以所有方案都没有绝对的优与劣之分，适合自己业务场景，解决自己实际痛点，提高自己开发效率的方案就是好的方案。\n\n## 占坑\n\n本文所涉及的技术在 [vue-element-admin](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin) 中可以找到完整的实例。 `vue-element-admin`也发布了新版本和配套的[中文文档](https://link.juejin.im/?target=https%3A%2F%2Fpanjiachen.github.io%2Fvue-element-admin-site%2F%23%2F)(文档真的写的我要吐血了)不管使不使用本项目都推荐一看，应该能对你写vue的项目有所帮助。欢迎使用和提出不足。 楼主个人免费[圈子](https://link.juejin.im/?target=https%3A%2F%2Fjianshiapp.com%2Fcircles%2F1209)。\n\n系列文章：\n\n- [手摸手，带你用vue撸后台 系列一（基础篇）](https://juejin.im/post/59097cd7a22b9d0065fb61d2)\n- [手摸手，带你用vue撸后台 系列二(登录权限篇)](https://juejin.im/post/591aa14f570c35006961acac)\n- [手摸手，带你用vue撸后台 系列三 (实战篇)](https://juejin.im/post/593121aa0ce4630057f70d35)\n- [手摸手，带你用vue撸后台 系列四(vueAdmin 一个极简的后台基础模板)](https://juejin.im/post/595b4d776fb9a06bbe7dba56)\n- [手摸手，带你封装一个vue component](https://link.juejin.im/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000009090836)\n- [手摸手，带你优雅的使用 icon](https://juejin.im/post/59bb864b5188257e7a427c09)\n- [手摸手，带你用合理的姿势使用webpack4（上）](https://juejin.im/post/5b56909a518825195f499806)\n- [手摸手，带你用合理的姿势使用webpack4（下）](https://juejin.im/post/5b5d6d6f6fb9a04fea58aabc)', 0, '手摸手，带你优雅的使用 icon - 掘金', '手摸手，带你优雅的使用 icon - 掘金', 0, '2019-03-16 16:21:36', 2, 108, NULL);
INSERT INTO `article` VALUES (19, '\n出处：https://www.cnblogs.com/ximiaomiao/p/7140456.html\n\n# [Git安装和使用](https://www.cnblogs.com/qijunjun/p/7137207.html)\n\n \n\n \n\n**目的：通过Git管理github托管项目代码**\n\n**一、下载安装Git**\n\n1、下载Git  官方地址为：https://git-scm.com/download/win\n\n![img](https://app.yinxiang.com/shard/s8/res/8b7eab43-4b8e-4d5c-a109-5f141003ab7d/810514-20170708094628081-1720506945.png)\n\n**2、下载完之后，双击安装**\n\n![img](https://app.yinxiang.com/shard/s8/res/6340960d-e785-476d-bd31-b6f0cbbcb834/810514-20170708095223800-1578957376.png)\n\n**3、选择安装目录**\n\n![img](https://app.yinxiang.com/shard/s8/res/9ca220b5-0723-45c3-b1d9-9d13a0e319a0/810514-20170708095553956-959136009.png)\n\n**4、选择组件**\n\n![img](https://app.yinxiang.com/shard/s8/res/4ccc3217-0774-49fd-8902-90cf2915cabb/810514-20170708095746081-2118617935.png)\n\n**5、开始菜单目录名设置**\n\n![img](https://app.yinxiang.com/shard/s8/res/7b039b6a-4f92-401d-9f2e-d138f5ea2c20/810514-20170708100131315-255359377.png)\n\n **6、选择使用命令行环境**\n\n![img](https://app.yinxiang.com/shard/s8/res/e9eebc44-1825-4bd0-8162-54107934ed74/810514-20170708100626534-974313591.png)\n\n**7、以下三步默认，直接点击下一步**\n\n![img](https://app.yinxiang.com/shard/s8/res/69c6da2f-d425-48e4-ad2b-45d80f1c3fa2/810514-20170708100920581-338347945.png)![img](https://app.yinxiang.com/shard/s8/res/1a7fe54f-69fb-4616-89c1-40601e06f5f8/810514-20170708101058815-844780321.png)![img](https://app.yinxiang.com/shard/s8/res/054a0664-74a4-4018-860d-3b3067d28a79/810514-20170708101627534-2061727948.png)\n\n **8、安装完成**\n\n  ![img](https://app.yinxiang.com/shard/s8/res/ef28b479-190c-4ad2-8a56-365f12c52aa1/810514-20170708102108237-112030650.png)\n\n**9、检验是否安装成功**\n\n回到电脑桌面，鼠标右击如果看到有两个git单词则安装成功\n\n![img](https://app.yinxiang.com/shard/s8/res/56102561-8a54-44fe-a88f-620ef655efac/810514-20170708104121206-372739.png)\n\n \n\n**二、Git基本工作流程**\n\n**1、Git工作区域**\n\n　　![img](https://app.yinxiang.com/shard/s8/res/d8456f63-9a18-471e-b290-a07056adf00d/810514-20170708094110753-1112241724.png)\n\n**2、向仓库中添加文件流程**\n\n　　![img](https://app.yinxiang.com/shard/s8/res/b1b33efc-6edd-4100-83b9-330dcdf88ab1/810514-20170708094205206-1157530589.png)\n\n**三、Git初始化及仓库创建和操作**\n\n**1、Git安装之后需要进行一些基本信息设置**\n\n　　a、设置用户名：git  config -- global  user.name  \'你再github上注册的用户名\';\n\n　　b、设置用户邮箱：git  config -- global  user.email  \'注册时候的邮箱\';\n\n注意：该配置会在github主页上显示谁提交了该文件\n\n 　　c、配置ok之后，我们用如下命令来看看是否配置成功\n\n　　git config --list\n\n注意：git  config --global 参数，有了这个参数表示你这台机器上所有的git仓库都会使用这个配置，当然你也可以对某个仓库指定不同的用户名和邮箱\n\n**2、初始化一个新的git仓库**\n\n　　**a、创建文件夹**\n\n　　　　方法一：可以鼠标右击-》点击新建文件夹test1\n\n　　　　方法二：使用git新建：$  mkdir test1\n\n![img](https://app.yinxiang.com/shard/s8/res/8724f714-fb31-4fc6-9363-338fd6e67bf9/810514-20170708112638050-326084249.jpg)\n\n　　**b、在文件内初始化git（创建git仓库）**\n\n　　　　方法一：直接输入 $ cd test1\n\n　　　　方法一：点击test1文件下进去之后-》鼠标右击选择Git Bash Here->输入$ git int\n\n![img](https://app.yinxiang.com/shard/s8/res/9dd42674-95e8-4b68-bf53-d40f444cf706/810514-20170708114125878-1108725678.png)\n\n**3、向仓库中添加文件**　　\n\n　　**方法一**：**用打开编辑器新建index.html文件**\n\n　　**方法二：使用git命令。$  touch \'文件名\'，然后把文件通过$ git add \'文件名\'添加到暂存区，最后提交操作**\n\n![img](https://app.yinxiang.com/shard/s8/res/5a9c8e1d-ddc9-412b-a62b-18d7ce59e935/810514-20170708134021347-1335883438.png)\n\n![img](https://app.yinxiang.com/shard/s8/res/9450720e-73ac-497d-b695-774aa31ca408/810514-20170708115404175-222288025.png)\n\n**4、修改仓库文件**\n\n　　**方法一**：**用编辑器打开index.html进行修改**\n\n　　**方法二：使用git命令。$  vi  \'文件名\'，然后在中间写内容，最后提交操作**\n\n![img](https://app.yinxiang.com/shard/s8/res/8214a2fc-b743-43ec-b7f0-ad5cf1ed201c/810514-20170708131825878-500722088.png)\n\n**5、删除仓库文件**\n\n　　**方法一：在编辑器中直接把要删除的文件删除掉**\n\n　　**方法二：使用git删除：$ git rm \'文件名\'，然后提交操作**\n\n![img](https://app.yinxiang.com/shard/s8/res/78c4e380-00fe-49b5-9461-1779e8300e79/810514-20170708134612112-1310465921.png)\n\n**四、Git管理远程仓库**\n\n**1、使用远程仓库的目的**：**备份、实现代码共享集中化管理**\n\n**Git远程仓库实际上就是保持在服务器上的git仓库文件**\n\n![img](https://app.yinxiang.com/shard/s8/res/e32f39cc-9873-4281-9b17-11fc0ebcb626/810514-20170708162644253-980855574.png)\n\n \n\n![img](https://app.yinxiang.com/shard/s8/res/f2be7cd9-509d-40bd-9494-b1e502108f9a/810514-20170708163027909-638412203.png)\n\n \n\n![img](https://app.yinxiang.com/shard/s8/res/49813783-106c-4285-9b38-82ef9866ec0c/810514-20170708162832175-34452855.png)\n\n \n\n**五、Git克隆操作**\n\n**目的：将远程仓库（github上对应的项目）复制到本地**\n\n**1、代码：**git clone 仓库地址\n\n仓库地址由来如下：\n\n![img](https://app.yinxiang.com/shard/s8/res/19267a68-ea17-4762-ae08-9d9c3a734c55/810514-20170708141329831-334684877.png)\n\n**2、克隆项目**\n\n![img](https://app.yinxiang.com/shard/s8/res/6ee7d4b2-cd53-4bd7-a5b5-1f3023277777/810514-20170708141732503-1665547325.png)\n\n### 3、将本地仓库同步到git远程仓库中：git push\n\n**![img](https://app.yinxiang.com/shard/s8/res/438ede04-a7a0-455f-abfc-a9f95fd735b0/810514-20170708162250097-1091691124.png)**\n\n**期间出现错误的情况有：**　\n\n　**a、出现提交错误**\n\n![img](https://app.yinxiang.com/shard/s8/res/025a7036-2e2f-4f7a-9582-b5d42e0f7150/810514-20170708154119409-1918892813.png)\n\n　　解决：这是通过Git GUI进行提交时发生的错误，由 .git 文件夹中的文件被设为“只读”所致，将 .git 文件夹下的所有文件、文件夹及其子文件的只读属性去掉即可。\n\n ![img](https://app.yinxiang.com/shard/s8/res/26384299-b607-43b1-9468-8761aa5ca5af/810514-20170708154336050-234354762.png)\n\n　**b、如果出现无法同步或没有权限，解决方法如下：**\n\n　　**用户名和密码一定要和github上的一致。**\n\n ![img](https://app.yinxiang.com/shard/s8/res/a3929fdf-54ca-43ca-8d71-c7b96a67be4f/810514-20170708144902690-780832315.png)\n\n### c、如何解决failed to push some refs to git\n\n 在使用git 对源代码进行push到gitHub时可能会出错，信息如下\n\n![img](https://app.yinxiang.com/shard/s8/res/3ff7f5b3-8593-4dc5-9379-18713cc07a0c/810514-20170804161055819-1664666131.png)\n\n**出现错误的主要原因：**github中的README.md文件不在本地代码目录中\n\n **解决办法：**首先使用git pull拉取github上的内容、然后再使用git push即可', 0, 'Git命令行管理代码、安装及使用 - 搬砖滴 - 博客园', 'Git命令行管理代码、安装及使用 - 搬砖滴 - 博客园', 0, '2019-03-16 16:22:19', 0, 109, NULL);
INSERT INTO `article` VALUES (20, '[\n下载 App](https://www.zhihu.com/app?auto_download=true&utm_source=zhihu&utm_campaign=guest_feed&utm_content=guide)[注册或登录](https://www.zhihu.com/signin?next=https://zhuanlan.zhihu.com/p/51374915)\n\n\n\n[![老钱](https://app.yinxiang.com/shard/s8/res/d3220e36-5efa-48af-96b0-948b054c0baf.jpg)](https://www.zhihu.com/people/codehole)\n\n[老钱](https://www.zhihu.com/people/codehole)\n\nGood news everyone!\n\n\n\n\n\n关注\n\n# 老大难的 Java ClassLoader 再不理解就老了\n\n\n\n11 天前 · 来自专栏 [码洞](https://zhuanlan.zhihu.com/codehole)\n\nClassLoader 是 Java 届最为神秘的技术之一，无数人被它伤透了脑筋，摸不清门道究竟在哪里。网上的文章也是一篇又一篇，经过本人的亲自鉴定，绝大部分内容都是在误导别人。本文我带读者彻底吃透 ClassLoader，以后其它的相关文章你们可以不必再细看了。\n\n## **ClassLoader 做什么的？**\n\n顾名思义，它是用来加载 Class 的。它负责将 Class 的字节码形式转换成内存形式的 Class 对象。字节码可以来自于磁盘文件 *.class，也可以是 jar 包里的 *.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组 []byte，它有特定的复杂的内部格式。\n\n\n\n有很多字节码加密技术就是依靠定制 ClassLoader 来实现的。先使用工具对字节码文件进行加密，运行时使用定制的 ClassLoader 先解密文件内容再加载这些解密后的字节码。\n\n每个 Class 对象的内部都有一个 classLoader 字段来标识自己是由哪个 ClassLoader 加载的。ClassLoader 就像一个容器，里面装了很多已经加载的 Class 对象。\n\n```\nclass Class<T> {\n  ...\n  private final ClassLoader classLoader;\n  ...\n}\n```\n\n\n\n## **延迟加载**\n\nJVM 运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用 ClassLoader 来加载这些类。加载完成后就会将 Class 对象存在 ClassLoader 里面，下次就不需要重新加载了。\n\n比如你在调用某个类的静态方法时，首先这个类肯定是需要被加载的，但是并不会触及这个类的实例字段，那么实例字段的类别 Class 就可以暂时不必去加载，但是它可能会加载静态字段相关的类别，因为静态方法会访问静态字段。而实例字段的类别需要等到你实例化对象的时候才可能会加载。\n\n## **各司其职**\n\nJVM 运行实例中会存在多个 ClassLoader，不同的 ClassLoader 会从不同的地方加载字节码文件。它可以从不同的文件目录加载，也可以从不同的 jar 文件中加载，也可以从网络上不同的服务地址来加载。\n\nJVM 中内置了三个重要的 ClassLoader，分别是 BootstrapClassLoader、ExtensionClassLoader 和 AppClassLoader。\n\nBootstrapClassLoader 负责加载 JVM 运行时核心类，这些类位于 JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.xxx.* 都在里面，比如 java.util.*、java.io.*、java.nio.*、java.lang.* 等等。这个 ClassLoader 比较特殊，它是由 C 代码实现的，我们将它称之为「根加载器」。\n\nExtensionClassLoader 负责加载 JVM 扩展类，比如 swing 系列、内置的 js 引擎、xml 解析器 等等，这些库名通常以 javax 开头，它们的 jar 包位于 JAVA_HOME/lib/ext/*.jar 中，有很多 jar 包。\n\nAppClassLoader 才是直接面向我们用户的加载器，它会加载 Classpath 环境变量里定义的路径中的 jar 包和目录。我们自己编写的代码以及使用的第三方 jar 包通常都是由它来加载的。\n\n那些位于网络上静态文件服务器提供的 jar 包和 class文件，jdk 内置了一个 URLClassLoader，用户只需要传递规范的网络路径给构造器，就可以使用 URLClassLoader 来加载远程类库了。URLClassLoader 不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。ExtensionClassLoader 和 AppClassLoader 都是 URLClassLoader 的子类，它们都是从本地文件系统里加载类库。\n\nAppClassLoader 可以由 ClassLoader 类提供的静态方法 getSystemClassLoader() 得到，它就是我们所说的「系统类加载器」，我们用户平时编写的类代码通常都是由它加载的。当我们的 main 方法执行的时候，这第一个用户类的加载器就是 AppClassLoader。\n\n## **ClassLoader 传递性**\n\n程序在运行过程中，遇到了一个未知的类，它会选择哪个 ClassLoader 来加载它呢？虚拟机的策略是使用调用者 Class 对象的 ClassLoader 来加载当前未知的类。何为调用者 Class 对象？就是在遇到这个未知的类时，虚拟机肯定正在运行一个方法调用（静态方法或者实例方法），这个方法挂在哪个类上面，那这个类就是调用者 Class 对象。前面我们提到每个 Class 对象里面都有一个 classLoader 属性记录了当前的类是由谁来加载的。\n\n因为 ClassLoader 的传递性，所有延迟加载的类都会由初始调用 main 方法的这个 ClassLoader 全全负责，它就是 AppClassLoader。\n\n## **双亲委派**\n\n前面我们提到 AppClassLoader 只负责加载 Classpath 下面的类库，如果遇到没有加载的系统类库怎么办，AppClassLoader 必须将系统类库的加载工作交给 BootstrapClassLoader 和 ExtensionClassLoader 来做，这就是我们常说的「双亲委派」。\n\n\n\nAppClassLoader 在加载一个未知的类名时，它并不是立即去搜寻 Classpath，它会首先将这个类名称交给 ExtensionClassLoader 来加载，如果 ExtensionClassLoader 可以加载，那么 AppClassLoader 就不用麻烦了。否则它就会搜索 Classpath 。\n\n而 ExtensionClassLoader 在加载一个未知的类名时，它也并不是立即搜寻 ext 路径，它会首先将类名称交给 BootstrapClassLoader 来加载，如果 BootstrapClassLoader 可以加载，那么 ExtensionClassLoader 也就不用麻烦了。否则它就会搜索 ext 路径下的 jar 包。\n\n这三个 ClassLoader 之间形成了级联的父子关系，每个 ClassLoader 都很懒，尽量把工作交给父亲做，父亲干不了了自己才会干。每个 ClassLoader 对象内部都会有一个 parent 属性指向它的父加载器。\n\n```\nclass ClassLoader {\n  ...\n  private final ClassLoader parent;\n  ...\n}\n```\n\n值得注意的是图中的 ExtensionClassLoader 的 parent 指针画了虚线，这是因为它的 parent 的值是 null，当 parent 字段是 null 时就表示它的父加载器是「根加载器」。如果某个 Class 对象的 classLoader 属性值是 null，那么就表示这个类也是「根加载器」加载的。\n\n## **Class.forName**\n\n当我们在使用 jdbc 驱动时，经常会使用 Class.forName 方法来动态加载驱动类。\n\n```\nClass.forName(\"com.mysql.cj.jdbc.Driver\");\n```\n\n其原理是 mysql 驱动的 Driver 类里有一个静态代码块，它会在 Driver 类被加载的时候执行。这个静态代码块会将 mysql 驱动实例注册到全局的 jdbc 驱动管理器里。\n\n```\nclass Driver {\n  static {\n    try {\n       java.sql.DriverManager.registerDriver(new Driver());\n    } catch (SQLException E) {\n       throw new RuntimeException(\"Can\'t register driver!\");\n    }\n  }\n  ...\n}\n```\n\nforName 方法同样也是使用调用者 Class 对象的 ClassLoader 来加载目标类。不过 forName 还提供了多参数版本，可以指定使用哪个 ClassLoader 来加载\n\n```\nClass<?> forName(String name, boolean initialize, ClassLoader cl)\n```\n\n通过这种形式的 forName 方法可以突破内置加载器的限制，通过使用自定类加载器允许我们自由加载其它任意来源的类库。根据 ClassLoader 的传递性，目标类库传递引用到的其它类库也将会使用自定义加载器加载。\n\n## **自定义加载器**\n\nClassLoader 里面有三个重要的方法 loadClass()、findClass() 和 defineClass()。\n\nloadClass() 方法是加载目标类的入口，它首先会查找当前 ClassLoader 以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 findClass() 让自定义加载器自己来加载目标类。ClassLoader 的 findClass() 方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用 defineClass() 方法将字节码转换成 Class 对象。下面我使用伪代码表示一下基本过程\n\n```\nclass ClassLoader {\n\n  // 加载入口，定义了双亲委派规则\n  Class loadClass(String name) {\n    // 是否已经加载了\n    Class t = this.findFromLoaded(name);\n    if(t == null) {\n      // 交给双亲\n      t = this.parent.loadClass(name)\n    }\n    if(t == null) {\n      // 双亲都不行，只能靠自己了\n      t = this.findClass(name);\n    }\n    return t;\n  }\n\n  // 交给子类自己去实现\n  Class findClass(String name) {\n    throw ClassNotFoundException();\n  }\n\n  // 组装Class对象\n  Class defineClass(byte[] code, String name) {\n    return buildClassFromCode(code, name);\n  }\n}\n\nclass CustomClassLoader extends ClassLoader {\n\n  Class findClass(String name) {\n    // 寻找字节码\n    byte[] code = findCodeFromSomewhere(name);\n    // 组装Class对象\n    return this.defineClass(code, name);\n  }\n}\n```\n\n自定义类加载器不易破坏双亲委派规则，不要轻易覆盖 loadClass 方法。否则可能会导致自定义加载器无法加载内置的核心类库。在使用自定义加载器时，要明确好它的父加载器是谁，将父加载器通过子类的构造器传入。如果父类加载器是 null，那就表示父加载器是「根加载器」。\n\n```\n// ClassLoader 构造器\nprotected ClassLoader(String name, ClassLoader parent);\n```\n\n双亲委派规则可能会变成三亲委派，四亲委派，取决于你使用的父加载器是谁，它会一直递归委派到根加载器。\n\n## **Class.forName vs ClassLoader.loadClass**\n\n这两个方法都可以用来加载目标类，它们之间有一个小小的区别，那就是 Class.forName() 方法可以获取原生类型的 Class，而 ClassLoader.loadClass() 则会报错。\n\n```\nClass<?> x = Class.forName(\"[I\");\nSystem.out.println(x);\n\nx = ClassLoader.getSystemClassLoader().loadClass(\"[I\");\nSystem.out.println(x);\n\n---------------------\nclass [I\n\nException in thread \"main\" java.lang.ClassNotFoundException: [I\n...\n```\n\n## **钻石依赖**\n\n项目管理上有一个著名的概念叫着「钻石依赖」，是指软件依赖导致同一个软件包的两个版本需要共存而不能冲突。\n\n\n\n\n\n我们平时使用的 maven 是这样解决钻石依赖的，它会从多个冲突的版本中选择一个来使用，如果不同的版本之间兼容性很糟糕，那么程序将无法正常编译运行。Maven 这种形式叫「扁平化」依赖管理。\n\n\n\n使用 ClassLoader 可以解决钻石依赖问题。不同版本的软件包使用不同的 ClassLoader 来加载，**位于不同 ClassLoader 中名称一样的类实际上是不同的类**。下面让我们使用 URLClassLoader 来尝试一个简单的例子，它默认的父加载器是 AppClassLoader\n\n```\n$ cat ~/source/jcl/v1/Dep.java\npublic class Dep {\n    public void print() {\n        System.out.println(\"v1\");\n    }\n}\n\n$ cat ~/source/jcl/v2/Dep.java\npublic class Dep {\n public void print() {\n  System.out.println(\"v1\");\n }\n}\n\n$ cat ~/source/jcl/Test.java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        String v1dir = \"file:///Users/qianwp/source/jcl/v1/\";\n        String v2dir = \"file:///Users/qianwp/source/jcl/v2/\";\n        URLClassLoader v1 = new URLClassLoader(new URL[]{new URL(v1dir)});\n        URLClassLoader v2 = new URLClassLoader(new URL[]{new URL(v2dir)});\n\n        Class<?> depv1Class = v1.loadClass(\"Dep\");\n        Object depv1 = depv1Class.getConstructor().newInstance();\n        depv1Class.getMethod(\"print\").invoke(depv1);\n\n        Class<?> depv2Class = v2.loadClass(\"Dep\");\n        Object depv2 = depv2Class.getConstructor().newInstance();\n        depv2Class.getMethod(\"print\").invoke(depv2);\n\n        System.out.println(depv1Class.equals(depv2Class));\n   }\n}\n```\n\n在运行之前，我们需要对依赖的类库进行编译\n\n```\n$ cd ~/source/jcl/v1\n$ javac Dep.java\n$ cd ~/source/jcl/v2\n$ javac Dep.java\n$ cd ~/source/jcl\n$ javac Test.java\n$ java Test\nv1\nv2\nfalse\n```\n\n在这个例子中如果两个 URLClassLoader 指向的路径是一样的，下面这个表达式还是 false，因为即使是同样的字节码用不同的 ClassLoader 加载出来的类都不能算同一个类\n\n```\ndepv1Class.equals(depv2Class)\n```\n\n我们还可以让两个不同版本的 Dep 类实现同一个接口，这样可以避免使用反射的方式来调用 Dep 类里面的方法。\n\n```\nClass<?> depv1Class = v1.loadClass(\"Dep\");\nIPrint depv1 = (IPrint)depv1Class.getConstructor().newInstance();\ndepv1.print()\n```\n\nClassLoader 固然可以解决依赖冲突问题，不过它也限制了不同软件包的操作界面必须使用反射或接口的方式进行动态调用。Maven 没有这种限制，它依赖于虚拟机的默认懒惰加载策略，运行过程中如果没有显示使用定制的 ClassLoader，那么从头到尾都是在使用 AppClassLoader，而不同版本的同名类必须使用不同的 ClassLoader 加载，所以 Maven 不能完美解决钻石依赖。\n如果你想知道有没有开源的包管理工具可以解决钻石依赖的，我推荐你了解一下 sofa-ark，它是蚂蚁金服开源的轻量级类隔离框架。\n\n## **分工与合作**\n\n这里我们重新理解一下 ClassLoader 的意义，它相当于类的命名空间，起到了类隔离的作用。位于同一个 ClassLoader 里面的类名是唯一的，不同的 ClassLoader 可以持有同名的类。ClassLoader 是类名称的容器，是类的沙箱。\n\n\n\n\n\n不同的 ClassLoader 之间也会有合作，它们之间的合作是通过 parent 属性和双亲委派机制来完成的。parent 具有更高的加载优先级。除此之外，parent 还表达了一种共享关系，当多个子 ClassLoader 共享同一个 parent 时，那么这个 parent 里面包含的类可以认为是所有子 ClassLoader 共享的。这也是为什么 BootstrapClassLoader 被所有的类加载器视为祖先加载器，JVM 核心类库自然应该被共享。\n\n\n\n## **Thread.contextClassLoader**\n\n如果你稍微阅读过 Thread 的源代码，你会在它的实例字段中发现有一个字段非常特别\n\n```\nclass Thread {\n  ...\n  private ClassLoader contextClassLoader;\n\n  public ClassLoader getContextClassLoader() {\n    return contextClassLoader;\n  }\n\n  public void setContextClassLoader(ClassLoader cl) {\n    this.contextClassLoader = cl;\n  }\n  ...\n}\n```\n\ncontextClassLoader「线程上下文类加载器」，这究竟是什么东西？\n\n首先 contextClassLoader 是那种需要显示使用的类加载器，如果你没有显示使用它，也就永远不会在任何地方用到它。你可以使用下面这种方式来显示使用它\n\n```\nThread.currentThread().getContextClassLoader().loadClass(name);\n```\n\n这意味着如果你使用 forName(string name) 方法加载目标类，它不会自动使用 contextClassLoader。那些因为代码上的依赖关系而懒惰加载的类也不会自动使用 contextClassLoader来加载。\n\n其次线程的 contextClassLoader 是从父线程那里继承过来的，所谓父线程就是创建了当前线程的线程。程序启动时的 main 线程的 contextClassLoader 就是 AppClassLoader。这意味着如果没有人工去设置，那么所有的线程的 contextClassLoader 都是 AppClassLoader。\n\n那这个 contextClassLoader 究竟是做什么用的？我们要使用前面提到了类加载器分工与合作的原理来解释它的用途。\n\n它可以做到跨线程共享类，只要它们共享同一个 contextClassLoader。父子线程之间会自动传递 contextClassLoader，所以共享起来将是自动化的。\n\n如果不同的线程使用不同的 contextClassLoader，那么不同的线程使用的类就可以隔离开来。\n\n如果我们对业务进行划分，不同的业务使用不同的线程池，线程池内部共享同一个 contextClassLoader，线程池之间使用不同的 contextClassLoader，就可以很好的起到隔离保护的作用，避免类版本冲突。\n\n如果我们不去定制 contextClassLoader，那么所有的线程将会默认使用 AppClassLoader，所有的类都将会是共享的。\n\n线程的 contextClassLoader 使用场合比较罕见，如果上面的逻辑晦涩难懂也不必过于计较。\n\nJDK9 增加了模块功能之后对类加载器的结构设计做了一定程度的修改，不过类加载器的原理还是类似的，作为类的容器，它起到类隔离的作用，同时还需要依靠双亲委派机制来建立不同的类加载器之间的合作关系。\n\n\n\n\n\n\n\n编辑于 2019-01-05\n\n[Java](https://www.zhihu.com/topic/19561132)\n\n[Java 编程](https://www.zhihu.com/topic/19582744)\n\n[Java类加载机制](https://www.zhihu.com/topic/20229458)\n\n### 文章被以下专栏收录\n\n[![码洞](https://app.yinxiang.com/shard/s8/res/a1b7553b-4ee4-4e13-99db-d9ffcfac91c0.jpg)](https://zhuanlan.zhihu.com/codehole)\n\n## [码洞](https://zhuanlan.zhihu.com/codehole)\n\nGood news everyone!\n\n关注专栏\n\n[![Beautiful Java](https://app.yinxiang.com/shard/s8/res/5129e8e0-21b1-4056-b647-694c10a0bf68.jpg)](https://zhuanlan.zhihu.com/beautifuljava)\n\n## [Beautiful Java](https://zhuanlan.zhihu.com/beautifuljava)\n\n一个分享Java知识干货的专栏，内容涵盖Java SE、Spring、JVM调优等领域的知识。同时这也是一本帮助你写出优雅的Java代码，拥有美丽的编程心情的Java修炼手册。\n\n关注专栏\n\n[![进击的Java新人](https://app.yinxiang.com/shard/s8/res/c5f16750-fc18-4618-b3dc-a4aa35049fd7.jpg)](https://zhuanlan.zhihu.com/hinus)\n\n## [进击的Java新人](https://zhuanlan.zhihu.com/hinus)\n\n关注专栏\n\n### 推荐阅读\n\n天下无难试之HashMap面试刁难大全\n\n老钱\n\n![天下无难试之HashMap面试刁难大全](https://app.yinxiang.com/shard/s8/res/e6dca4ba-65b4-467e-a6c7-92f55d8798c9.jpg)\n\n详细讲解JAVA中的IO流\n\n文章出处：详细讲解JAVA中的IO流 - 丿黑色丶幽默丨灬 - 博客园 一、流的概念 流(stream)的概念源于UNIX中管道(pipe)的概念。在UNIX中，管道是一条不间断的字节流，用来实现程序或进程间的通…\n\n小草配绿叶\n\n打通 Java 任督二脉 —— 并发数据结构的基石\n\n老钱\n\n![打通 Java 任督二脉 —— 并发数据结构的基石](https://app.yinxiang.com/shard/s8/res/9e863e4c-6439-4bd8-863a-5c758ebff494.jpg)\n\nIntelliJ IDEA 最常用配置，应用、永久激活\n\n慕课网 · 发表于猿论\n\n![IntelliJ IDEA 最常用配置，应用、永久激活](https://app.yinxiang.com/shard/s8/res/47bf38d4-d4d3-481b-9932-adbd9c68136f.jpg)\n\n查看更多\n\n## 51 条评论\n\n写下你的评论…\n\n[![0xCAFFE](https://app.yinxiang.com/shard/s8/res/edd948a3-ae07-48e3-95c7-3ecfcc2a1f28.jpg)](https://www.zhihu.com/people/shi-yuan-67-16)\n\n[0xCAFFE](https://www.zhihu.com/people/shi-yuan-67-16)\n\n1 个月前\n\n好文！！\n\n\n\n\n\n3\n\n\n\n\n\n回复\n\n\n\n\n\n举报\n\n[![倪泽](https://app.yinxiang.com/shard/s8/res/b34bfed5-843e-4011-a86a-964ac9aab301.jpg)](https://www.zhihu.com/people/ni-ze)\n\n[倪泽](https://www.zhihu.com/people/ni-ze)\n\n1 个月前\n\n好有深度，赞美！\n\n\n\n\n\n赞\n\n\n\n\n\n回复\n\n\n\n\n\n举报\n\n\n\n[![丁一](https://app.yinxiang.com/shard/s8/res/f6fb5ae5-3c3c-408d-9b3a-f298cac9b1ad.jpg)](https://www.zhihu.com/people/ding-shi-sheng-49)\n\n[丁一](https://www.zhihu.com/people/ding-shi-sheng-49)\n\n1 个月前\n\n这个有用\n\n\n\n\n\n赞\n\n\n\n\n\n回复\n\n\n\n\n\n举报\n\n\n\n[![张兴锐](https://app.yinxiang.com/shard/s8/res/97d2d5d1-9502-4465-bd2a-e4c1e45302b0.jpg)](https://www.zhihu.com/people/zhang-xing-rui-73)\n\n[张兴锐](https://www.zhihu.com/people/zhang-xing-rui-73)\n\n1 个月前\n\n不错\n\n\n\n\n\n赞\n\n\n\n\n\n回复\n\n\n\n\n\n举报\n\n\n\n[![地狱少女火炮兰](https://app.yinxiang.com/shard/s8/res/a373e6db-596e-4b08-b99e-87529fab2d47.jpg)](https://www.zhihu.com/people/my-dear-suzumiya-san)\n\n[地狱少女火炮兰](https://www.zhihu.com/people/my-dear-suzumiya-san)\n\n\n\n\n\n\n\n51 条评论\n\n\n\n\n\n', 0, '老大难的 Java ClassLoader 再不理解就老了 - 知乎', '老大难的 Java ClassLoader 再不理解就老了 - 知乎', 0, '2019-03-16 16:24:24', 4, 110, NULL);
INSERT INTO `article` VALUES (21, '![返回主页](https://app.yinxiang.com/shard/s8/res/6df1a477-a804-4c38-b302-27b017ba002b.gif)\n\n# [老船长n_n](https://www.cnblogs.com/herozhi/)\n\n##  \n\n- [博客园](https://www.cnblogs.com/)\n- [首页](https://www.cnblogs.com/herozhi/)\n- \n- [联系](https://msg.cnblogs.com/send/%E5%81%9A%E4%B8%AA%E9%9A%90%E5%A3%AB)\n- \n- [管理](https://i.cnblogs.com/)\n\n随笔 - 28  文章 - 0  评论 - 3\n\n# [十大经典算法总结](https://www.cnblogs.com/herozhi/p/5880939.html)\n\n\n\nDamonare\n\n20小时前\n\n十大经典算法总结（JavaScript描述）\n\n## 前言\n\n**读者自行尝试可以想看源码戳这，博主在github建了个库，欢迎star.读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~**\n\n**个人博客：Damonare的个人博客** **原文地址：十大经典算法总结**\n\n> - 这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript.... 当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如 今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，JavaScript可谓风头无两，已经坐上了头把交椅。\n> - 在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对， 满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试 的时候，算法方面考的其实不难（十大排序算法或是和十大排序算法同等难度的），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。\n> - 算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。 ![大大](https://app.yinxiang.com/shard/s8/res/44b3f659-2bef-46da-bb70-70788afe2ef0.gif)\n\n## 正文\n\n### 排序算法说明\n\n**（1）排序的定义：对一序列对象根据某个关键字进行排序；**\n\n输入：n个数：a1,a2,a3,...,an 输出：n个数的排列:a1\',a2\',a3\',...,an\'，使得a1\'<=a2\'<=a3\'<=...<=an\'。\n\n再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。\n\n**（3）对于评述算法优劣术语的说明**\n\n**稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；\n\n**内排序**：所有排序操作都在内存中完成； **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；\n\n**时间复杂度**: 一个算法执行所耗费的时间。 **空间复杂度**: 运行完一个程序所需内存的大小。\n\n关于时间空间复杂度的更多了解请戳[这里](http://blog.csdn.net/booirror/article/details/7707551/)，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。\n\n**（4）排序算法图片总结(图片来源于网络):**\n\n排序对比：\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/4bf35d57-ebdb-4237-a8e0-7c651f45aae0.png)\n\n**图片名词解释：** n: 数据规模 k:“桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存\n\n排序分类：\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/a33bf5a7-bb03-45bd-bd3d-d515a4b1b5d0.jpg)\n\n### 1.冒泡排序（Bubble Sort）\n\n> 好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。\n\n#### (1)算法描述\n\n> 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n#### (2)算法描述和实现\n\n具体算法描述如下：\n\n- <1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n- <2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n- <3>.针对所有的元素重复以上的步骤，除了最后一个；\n- <4>.重复步骤1~3，直到排序完成。\n\n**JavaScript代码实现：**\n\n```\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j+1]) {        //相邻元素两两对比\n                var temp = arr[j+1];        //元素交换\n                arr[j+1] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n> **改进冒泡排序：** 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。\n\n改进后算法如下:\n\n```\nfunction bubbleSort2(arr) {\n    console.time(\'改进后冒泡排序耗时\');\n    var i = arr.length-1;  //初始时,最后位置保持不变\n    while ( i> 0) {\n        var pos= 0; //每趟开始时,无记录交换\n        for (var j= 0; j< i; j++)\n            if (arr[j]> arr[j+1]) {\n                pos= j; //记录交换的位置\n                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;\n            }\n        i= pos; //为下一趟排序作准备\n     }\n     console.timeEnd(\'改进后冒泡排序耗时\');\n     return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n> 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。\n\n改进后的算法实现为:\n\n```\nfunction bubbleSort3(arr3) {\n    var low = 0;\n    var high= arr.length-1; //设置变量的初始值\n    var tmp,j;\n    console.time(\'2.改进后冒泡排序耗时\');\n    while (low < high) {\n        for (j= low; j< high; ++j) //正向冒泡,找到最大者\n            if (arr[j]> arr[j+1]) {\n                tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;\n            }\n        --high;                 //修改high值, 前移一位\n        for (j=high; j>low; --j) //反向冒泡,找到最小者\n            if (arr[j]\n三种方法耗时对比：\n```\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/2b9a38b6-fc42-43e0-939e-d1ee018369a3.png)\n\n> 由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~\n\n**冒泡排序动图演示:**\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/652c9261-7b1a-4862-921d-eb6549b61b9d.gif)\n\n**(3)算法分析**\n\n- 最佳情况：T(n) = O(n)\n\n> 当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢....）\n\n- 最差情况：T(n) = O(n2)\n\n> 当输入的数据是反序时(卧槽，我直接反序不就完了....)\n\n- 平均情况：T(n) = O(n2)\n\n### 2.选择排序（Selection Sort）\n\n> 表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时 间复杂度.....所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的 最多的排序方法了吧。\n\n#### (1)算法简介\n\n> 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n#### (2)算法描述和实现\n\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n\n- <1>.初始状态：无序区为R[1..n]，有序区为空；\n- <2>.第i趟排序(i=1,2,3...n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序 从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n- <3>.n-1趟结束，数组有序化了。\n\n**Javascript代码实现:**\n\n```\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    console.time(\'选择排序耗时\');\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     //寻找最小的数\n                minIndex = j;                 //将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    console.timeEnd(\'选择排序耗时\');\n    return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n**选择排序动图演示：**\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/7fc11323-f253-4e51-9737-c236ac442748.gif)\n\n#### (3)算法分析\n\n- 最佳情况：T(n) = O(n2)\n- 最差情况：T(n) = O(n2)\n- 平均情况：T(n) = O(n2)\n\n## 3.插入排序（Insertion Sort）\n\n> 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了.....\n\n#### (1)算法简介\n\n> 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向 前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要 反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n#### (2)算法描述和实现\n\n一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：\n\n- <1>.从第一个元素开始，该元素可以认为已经被排序；\n- <2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；\n- <3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；\n- <4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n- <5>.将新元素插入到该位置后；\n- <6>.重复步骤2~5。\n\n**Javascript代码实现:**\n\n```\nfunction insertionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === \'Array\') {\n        console.time(\'插入排序耗时：\');\n        for (var i = 1; i < array.length; i++) {\n            var key = array[i];\n            var j = i - 1;\n            while (j >= 0 && array[j] > key) {\n                array[j + 1] = array[j];\n                j--;\n            }\n            array[j + 1] = key;\n        }\n        console.timeEnd(\'插入排序耗时：\');\n        return array;\n    } else {\n        return \'array is not an Array!\';\n    }\n}\n```\n\n> **改进插入排序：** 查找插入位置时使用二分查找的方式\n\n```\nfunction binaryInsertionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === \'Array\') {\n        console.time(\'二分插入排序耗时：\');\n\n        for (var i = 1; i < array.length; i++) {\n            var key = array[i], left = 0, right = i - 1;\n            while (left <= right) {\n                var middle = parseInt((left + right) / 2);\n                if (key < array[middle]) {\n                    right = middle - 1;\n                } else {\n                    left = middle + 1;\n                }\n            }\n            for (var j = i - 1; j >= left; j--) {\n                array[j + 1] = array[j];\n            }\n            array[left] = key;\n        }\n        console.timeEnd(\'二分插入排序耗时：\');\n\n        return array;\n    } else {\n        return \'array is not an Array!\';\n    }\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n> 改进前后对比：\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/1bd44802-c072-4083-a221-a9b24b08526f.png)\n\n**插入排序动图演示:**\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/692942ca-d923-4902-a448-955586b65b51.gif)\n\n#### (3)算法分析\n\n- 最佳情况：输入数组按升序排列。T(n) = O(n)\n- 最坏情况：输入数组按降序排列。T(n) = O(n2)\n- 平均情况：T(n) = O(n2)\n\n### 4.希尔排序（Shell Sort）\n\n> 1959年Shell发明； 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序\n\n#### (1)算法简介\n\n> 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。\n\n#### (2)算法描述和实现\n\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\n\n- <1>. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n- <2>.按增量序列个数k，对序列进行k 趟排序；\n- <3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n**Javascript代码实现：**\n\n```\nfunction shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    console.time(\'希尔排序耗时:\');\n    while(gap < len/5) {          //动态定义间隔序列\n        gap =gap*5+1;\n    }\n    for (gap; gap > 0; gap = Math.floor(gap/5)) {\n        for (var i = gap; i < len; i++) {\n            temp = arr[i];\n            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {\n                arr[j+gap] = arr[j];\n            }\n            arr[j+gap] = temp;\n        }\n    }\n    console.timeEnd(\'希尔排序耗时:\');\n    return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n**希尔排序图示（图片来源网络）：**\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/644cb22e-1164-4a1e-b532-366a108eeca8.jpg)\n\n#### （3）算法分析\n\n- 最佳情况：T(n) = O(nlog2 n)\n- 最坏情况：T(n) = O(nlog2 n)\n- 平均情况：T(n) =O(nlog n)\n\n### 5.归并排序（Merge Sort）\n\n> 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。\n\n#### (1)算法简介\n\n> 　归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段 间有序。若将两个有序表合并成一个有序表，称为2-路归并。\n\n#### (2)算法描述和实现\n\n具体算法描述如下：\n\n- <1>.把长度为n的输入序列分成两个长度为n/2的子序列；\n- <2>.对这两个子序列分别采用归并排序；\n- <3>.将两个排序好的子序列合并成一个最终的排序序列。\n\n**Javscript代码实现:**\n\n```\nfunction mergeSort(arr) {  //采用自上而下的递归方法\n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n    console.time(\'归并排序耗时\');\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n    console.timeEnd(\'归并排序耗时\');\n    return result;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(mergeSort(arr));\n```\n\n**归并排序动图演示:**\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/b849b1c2-9169-4e0b-b4dc-6133df7eb063.gif)\n\n#### (3)算法分析\n\n- 最佳情况：T(n) = O(n)\n- 最差情况：T(n) = O(nlogn)\n- 平均情况：T(n) = O(nlogn)\n\n### 6.快速排序（Quick Sort）\n\n> 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。\n\n#### (1)算法简介\n\n> 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n\n#### (2)算法描述和实现\n\n快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n\n- <1>.从数列中挑出一个元素，称为 \"基准\"（pivot）；\n- <2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- <3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n**Javascript代码实现：**\n\n```\n/*方法说明：快速排序\n@param  array 待排序数组*/\n//方法一\nfunction quickSort(array, left, right) {\n    console.time(\'1.快速排序耗时\');\n    if (Object.prototype.toString.call(array).slice(8, -1) === \'Array\' && typeof left === \'number\' && typeof right === \'number\') {\n        if (left < right) {\n            var x = array[right], i = left - 1, temp;\n            for (var j = left; j <= right; j++) {\n                if (array[j] <= x) {\n                    i++;\n                    temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n            quickSort(array, left, i - 1);\n            quickSort(array, i + 1, right);\n        }\n        console.timeEnd(\'1.快速排序耗时\');\n        return array;\n    } else {\n        return \'array is not an Array or left or right is not a number!\';\n    }\n}\n\n//方法二\nvar quickSort2 = function(arr) {\n    console.time(\'2.快速排序耗时\');\n　　if (arr.length <= 1) { return arr; }\n　　var pivotIndex = Math.floor(arr.length / 2);\n　　var pivot = arr.splice(pivotIndex, 1)[0];\n　　var left = [];\n　　var right = [];\n　　for (var i = 0; i < arr.length; i++){\n　　　　if (arr[i] < pivot) {\n　　　　　　left.push(arr[i]);\n　　　　} else {\n　　　　　　right.push(arr[i]);\n　　　　}\n　　}\nconsole.timeEnd(\'2.快速排序耗时\');\n　　return quickSort2(left).concat([pivot], quickSort2(right));\n};\n\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\nconsole.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\n```\n\n**快速排序动图演示：**\n\n![快速排序](https://app.yinxiang.com/shard/s8/res/a65aa75f-fa0e-443c-a400-921e4e5ad163.gif)\n\n#### (3)算法分析\n\n- 最佳情况：T(n) = O(nlogn)\n- 最差情况：T(n) = O(n2)\n- 平均情况：T(n) = O(nlogn)\n\n### 7.堆排序（Heap Sort）\n\n> 堆排序可以说是一种利用堆的概念来排序的选择排序。\n\n#### (1)算法简介\n\n> 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n\n#### (2)算法描述和实现\n\n具体算法描述如下：\n\n- <1>.将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；\n- <2>.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]<=R[n]；\n- <3>.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后 再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元 素个数为n-1，则整个排序过程完成。\n\n**Javascript代码实现：**\n\n```\n/*方法说明：堆排序\n@param  array 待排序数组*/\nfunction heapSort(array) {\n    console.time(\'堆排序耗时\');\n    if (Object.prototype.toString.call(array).slice(8, -1) === \'Array\') {\n        //建堆\n        var heapSize = array.length, temp;\n        for (var i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {\n            heapify(array, i, heapSize);\n        }\n\n        //堆排序\n        for (var j = heapSize - 1; j >= 1; j--) {\n            temp = array[0];\n            array[0] = array[j];\n            array[j] = temp;\n            heapify(array, 0, --heapSize);\n        }\n        console.timeEnd(\'堆排序耗时\');\n        return array;\n    } else {\n        return \'array is not an Array!\';\n    }\n}\n/*方法说明：维护堆的性质\n@param  arr 数组\n@param  x   数组下标\n@param  len 堆大小*/\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === \'Array\' && typeof x === \'number\') {\n        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;\n        if (l < len && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < len && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return \'arr is not an Array or x is not a number!\';\n    }\n}\nvar arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];\nconsole.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]\n\n```\n\n**堆排序动图演示：**\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/beb7a2d5-4fdf-4d5f-8158-0b24bacf2345.gif)\n\n#### (3)算法分析\n\n- 最佳情况：T(n) = O(nlogn)\n- 最差情况：T(n) = O(nlogn)\n- 平均情况：T(n) = O(nlogn)\n\n### 8.计数排序（Counting Sort）\n\n> 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n\n#### (1)算法简介\n\n> 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。\n\n#### (2)算法描述和实现\n\n具体算法描述如下：\n\n- <1>. 找出待排序的数组中最大和最小的元素；\n- <2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\n- <3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\n- <4>. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\n\n**Javascript代码实现：**\n\n```\nfunction countingSort(array) {\n    var len = array.length,\n        B = [],\n        C = [],\n        min = max = array[0];\n    console.time(\'计数排序耗时\');\n    for (var i = 0; i < len; i++) {\n        min = min <= array[i] ? min : array[i];\n        max = max >= array[i] ? max : array[i];\n        C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;\n    }\n    for (var j = min; j < max; j++) {\n        C[j + 1] = (C[j + 1] || 0) + (C[j] || 0);\n    }\n    for (var k = len - 1; k >= 0; k--) {\n        B[C[array[k]] - 1] = array[k];\n        C[array[k]]--;\n    }\n    console.timeEnd(\'计数排序耗时\');\n    return B;\n}\nvar arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];\nconsole.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]\n\n```\n\n**JavaScript动图演示：**、\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/cd38556f-285f-4a56-b92c-64dc4d15602e.gif)\n\n#### (3)算法分析\n\n> 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小 值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。\n\n- 最佳情况：T(n) = O(n+k)\n- 最差情况：T(n) = O(n+k)\n- 平均情况：T(n) = O(n+k)\n\n### 9.桶排序（Bucket Sort）\n\n> 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n\n#### (1)算法简介\n\n> 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排\n\n#### (2)算法描述和实现\n\n具体算法描述如下：\n\n- <1>.设置一个定量的数组当作空桶；\n- <2>.遍历输入数据，并且把数据一个一个放到对应的桶里去；\n- <3>.对每个不是空的桶进行排序；\n- <4>.从不是空的桶里把排好序的数据拼接起来。\n\n**Javascript代码实现:**\n\n```\n/*方法说明：桶排序\n@param  array 数组\n@param  num   桶的数量*/\nfunction bucketSort(array, num) {\n    if (array.length <= 1) {\n        return array;\n    }\n    var len = array.length, buckets = [], result = [], min = max = array[0], regex = \'/^[1-9]+[0-9]*$/\', space, n = 0;\n    num = num || ((num > 1 && regex.test(num)) ? num : 10);\n    console.time(\'桶排序耗时\');\n    for (var i = 1; i < len; i++) {\n        min = min <= array[i] ? min : array[i];\n        max = max >= array[i] ? max : array[i];\n    }\n    space = (max - min + 1) / num;\n    for (var j = 0; j < len; j++) {\n        var index = Math.floor((array[j] - min) / space);\n        if (buckets[index]) {   //  非空桶，插入排序\n            var k = buckets[index].length - 1;\n            while (k >= 0 && buckets[index][k] > array[j]) {\n                buckets[index][k + 1] = buckets[index][k];\n                k--;\n            }\n            buckets[index][k + 1] = array[j];\n        } else {    //空桶，初始化\n            buckets[index] = [];\n            buckets[index].push(array[j]);\n        }\n    }\n    while (n < num) {\n        result = result.concat(buckets[n]);\n        n++;\n    }\n    console.timeEnd(\'桶排序耗时\');\n    return result;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\n```\n\n**桶排序图示（图片来源网络）：**\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/790c4da6-aeb7-4a4d-be33-cff348c571ca.jpg)\n\n关于桶排序[更多](http://www.cnblogs.com/lonelyxmas/p/3561938.html)\n\n#### (3)算法分析\n\n> 　桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\n\n- 最佳情况：T(n) = O(n+k)\n- 最差情况：T(n) = O(n+k)\n- 平均情况：T(n) = O(n2)\n\n### 10.基数排序（Radix Sort）\n\n> 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；\n\n#### (1)算法简介\n\n> 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再 按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。\n\n#### (2)算法描述和实现\n\n具体算法描述如下：\n\n- <1>.取得数组中的最大数，并取得位数；\n- <2>.arr为原始数组，从最低位开始取每个位组成radix数组；\n- <3>.对radix进行计数排序（利用计数排序适用于小范围数的特点）；\n\n**Javascript代码实现：**\n\n```\n/**\n * 基数排序适用于：\n *  (1)数据范围较小，建议在小于1000\n *  (2)每个数值都要大于等于0\n * @author xiazdong\n * @param  arr 待排序数组\n * @param  maxDigit 最大位数\n */\n//LSD Radix Sort\n\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    var counter = [];\n    console.time(\'基数排序耗时\');\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]== null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    console.timeEnd(\'基数排序耗时\');\n    return arr;\n}\nvar arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];\nconsole.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\n```\n\n**基数排序LSD动图演示：**\n\n![这里写图片描述](https://app.yinxiang.com/shard/s8/res/ae75f013-c4a8-4156-b1e6-362434b8e5e4.gif)\n\n#### (3)算法分析\n\n- 最佳情况：T(n) = O(n * k)\n- 最差情况：T(n) = O(n * k)\n- 平均情况：T(n) = O(n * k)\n\n基数排序有两种方法：\n\n- MSD 从高位开始进行排序\n- LSD 从低位开始进行排序\n\n**基数排序 vs 计数排序 vs 桶排序**\n\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n\n1. 基数排序：根据键值的每位数字来分配桶\n2. 计数排序：每个桶只存储单一键值\n3. 桶排序：每个桶存储一定范围的数值\n\n## 后记\n\n> 十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指定。\n\n\n\n分类: [前端](https://www.cnblogs.com/herozhi/category/918926.html)\n\n\n\n好文要顶 关注我 收藏该文 ![img](https://app.yinxiang.com/shard/s8/res/3e4892ba-3f4a-4166-bf07-d00d75c3312f.png) ![img](https://app.yinxiang.com/shard/s8/res/61dc1caa-7fbf-47e7-91f0-e15ce4d79d7b.png)\n\n![img](https://app.yinxiang.com/shard/s8/res/cf53a8c4-d8a9-4bdc-8e2d-49b9aa5cd60c.png)\n\n[做个隐士](http://home.cnblogs.com/u/herozhi/)\n[关注 - 2](http://home.cnblogs.com/u/herozhi/followees)\n[粉丝 - 4](http://home.cnblogs.com/u/herozhi/followers)\n\n\n\n\n\n+加关注\n\n3\n\n0\n\n\n\n\n\n\n\n[« ](https://www.cnblogs.com/herozhi/p/5856406.html)上一篇：[如何查看npm配置？](https://www.cnblogs.com/herozhi/p/5856406.html)\n[» ](https://www.cnblogs.com/herozhi/p/5909281.html)下一篇：[Javascript基础篇小结](https://www.cnblogs.com/herozhi/p/5909281.html)\n\nposted @ 2016-09-18 11:21 [做个隐士](https://www.cnblogs.com/herozhi/) 阅读(10819) 评论(1) [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=5880939) [收藏](https://www.cnblogs.com/herozhi/p/5880939.html#)\n\n\n\n\n\n评论列表\n\n\n\n  \n\n\\#1楼\n\n\n\n \n\n2018-10-31 16:45\n\n \n\n张不帅\n\n \n\n \n\n总结的非常好\n\n支持(0)反对(0)\n\n\n\n\n\n\n\n刷新评论[刷新页面](https://www.cnblogs.com/herozhi/p/5880939.html#)[返回顶部](https://www.cnblogs.com/herozhi/p/5880939.html#top)\n\n注册用户登录后才能发表评论，请 登录 或 注册，[访问](http://www.cnblogs.com/)网站首页。\n\n\n\n[【推荐】超50万VC++源码: 大型组态工控、电力仿真CAD与GIS源码库！](http://www.ucancode.com/index.htm)\n\n\n\n\n\n**相关博文：**\n· [数据挖掘十大经典算法](https://www.cnblogs.com/mfrbuaa/p/4371465.html)\n· [十大经典数据挖掘算法](https://www.cnblogs.com/hrhguanli/p/4595303.html)\n· [十大经典算法排序总结对比](https://www.cnblogs.com/panda-ling/p/6705193.html)\n· [十大经典排序算法总结](https://www.cnblogs.com/czy960731/p/8660662.html)\n· [动态展示十大经典算法](https://www.cnblogs.com/suke99/p/5183603.html)\n\n\n\n**最新新闻**：\n· [苹果“崴脚”，供应商“骨折”](https://news.cnblogs.com/n/617350/)\n· [贩卖焦虑终难持续，微博想帮用户“高级吃瓜”才是知识付费的正确姿势](https://news.cnblogs.com/n/617347/)\n· [SpaceX裁员细节曝光：员工通过邮件得知自己未来命运](https://news.cnblogs.com/n/617337/)\n· [Facebook将测试用Stories来分享事件功能](https://news.cnblogs.com/n/617338/)\n· [巴伦周刊建议苹果收购任天堂 后者股价大涨](https://news.cnblogs.com/n/617344/)\n» [更多新闻...](http://news.cnblogs.com/)\n\n\n\n### 公告\n\n昵称：\n\n做个隐士\n\n园龄：\n\n3年4个月\n\n粉丝：\n\n4\n\n关注：\n\n2\n\n+加关注\n\n| <2019年1月> |      |      |      |      |      |      |\n| :---------- | :--- | :--- | :--- | :--- | :--- | :--- |\n| 日          | 一   | 二   | 三   | 四   | 五   | 六   |\n| 30          | 31   | 1    | 2    | 3    | 4    | 5    |\n| 6           | 7    | 8    | 9    | 10   | 11   | 12   |\n| 13          | 14   | 15   | 16   | 17   | 18   | 19   |\n| 20          | 21   | 22   | 23   | 24   | 25   | 26   |\n| 27          | 28   | 29   | 30   | 31   | 1    | 2    |\n| 3           | 4    | 5    | 6    | 7    | 8    | 9    |\n\n### 搜索\n\n \n\n \n\n### 常用链接\n\n- [我的随笔](https://www.cnblogs.com/herozhi/p/)\n- [我的评论](https://www.cnblogs.com/herozhi/MyComments.html)\n- [我的参与](https://www.cnblogs.com/herozhi/OtherPosts.html)\n- [最新评论](https://www.cnblogs.com/herozhi/RecentComments.html)\n- [我的标签](https://www.cnblogs.com/herozhi/tag/)\n\n### 我的标签\n\n- [css](https://www.cnblogs.com/herozhi/tag/css/)(1)\n- [css3](https://www.cnblogs.com/herozhi/tag/css3/)(1)\n- [html](https://www.cnblogs.com/herozhi/tag/html/)(1)\n\n### 随笔分类\n\n- [茶(2)](https://www.cnblogs.com/herozhi/category/918925.html)\n- [前端(26)](https://www.cnblogs.com/herozhi/category/918926.html)\n\n### 随笔档案\n\n- [2017年2月 (1)](https://www.cnblogs.com/herozhi/archive/2017/02.html)\n- [2016年12月 (7)](https://www.cnblogs.com/herozhi/archive/2016/12.html)\n- [2016年11月 (1)](https://www.cnblogs.com/herozhi/archive/2016/11.html)\n- [2016年10月 (2)](https://www.cnblogs.com/herozhi/archive/2016/10.html)\n- [2016年9月 (4)](https://www.cnblogs.com/herozhi/archive/2016/09.html)\n- [2016年8月 (5)](https://www.cnblogs.com/herozhi/archive/2016/08.html)\n- [2016年7月 (3)](https://www.cnblogs.com/herozhi/archive/2016/07.html)\n- [2016年6月 (2)](https://www.cnblogs.com/herozhi/archive/2016/06.html)\n- [2016年5月 (1)](https://www.cnblogs.com/herozhi/archive/2016/05.html)\n- [2016年4月 (2)](https://www.cnblogs.com/herozhi/archive/2016/04.html)\n\n### 最新评论\n\n- [1. Re:十大经典算法总结](https://www.cnblogs.com/herozhi/p/5880939.html#4102851)\n- 总结的非常好\n- --张不帅\n- [2. Re:vue+webpack一些知识](https://www.cnblogs.com/herozhi/p/6210326.html#3949960)\n- 推荐一个vue工程化实践教程：\n- --ezpod\n- [3. Re:如何在Github Pages搭建自己写的页面？](https://www.cnblogs.com/herozhi/p/6143912.html#3879427)\n- 教程简单明了，在此谢过博主了！最近看到码云也在推广pages的有奖征集活动，所以也准备学习做自己的Pages个性主页，楼主如果有现成的Pages模板，只要同步到码云上就可以参加活动，一起加油哦！\n- --零度咖啡猫\n\n### 阅读排行榜\n\n- [1. 十大经典算法总结(10810)](https://www.cnblogs.com/herozhi/p/5880939.html)\n- [2. 如何查看npm配置？(9713)](https://www.cnblogs.com/herozhi/p/5856406.html)\n- [3. 如何在Github Pages搭建自己写的页面？(2557)](https://www.cnblogs.com/herozhi/p/6143912.html)\n- [4. vue+webpack一些知识(1724)](https://www.cnblogs.com/herozhi/p/6210326.html)\n- [5. 使用window.postMessage实现跨域通信(777)](https://www.cnblogs.com/herozhi/p/5756748.html)\n\n### 评论排行榜\n\n- [1. vue+webpack一些知识(1)](https://www.cnblogs.com/herozhi/p/6210326.html)\n- [2. 如何在Github Pages搭建自己写的页面？(1)](https://www.cnblogs.com/herozhi/p/6143912.html)\n- [3. 十大经典算法总结(1)](https://www.cnblogs.com/herozhi/p/5880939.html)\n\n### 推荐排行榜\n\n- [1. 十大经典算法总结(3)](https://www.cnblogs.com/herozhi/p/5880939.html)\n\n\n\n\n\nCopyright ©2019 做个隐士', 0, '十大经典算法总结 - 做个隐士 - 博客园', '十大经典算法总结 - 做个隐士 - 博客园', 1, '2019-03-16 16:59:15', 8, 111, NULL);

-- ----------------------------
-- Table structure for article_tag
-- ----------------------------
DROP TABLE IF EXISTS `article_tag`;
CREATE TABLE `article_tag`  (
  `article_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  INDEX `FKesqp7s9jj2wumlnhssbme5ule`(`tag_id`) USING BTREE,
  INDEX `FKenqeees0y8hkm7x1p1ittuuye`(`article_id`) USING BTREE,
  CONSTRAINT `FKenqeees0y8hkm7x1p1ittuuye` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKesqp7s9jj2wumlnhssbme5ule` FOREIGN KEY (`tag_id`) REFERENCES `tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article_tag
-- ----------------------------
INSERT INTO `article_tag` VALUES (2, 3);
INSERT INTO `article_tag` VALUES (3, 4);
INSERT INTO `article_tag` VALUES (4, 5);
INSERT INTO `article_tag` VALUES (5, 6);
INSERT INTO `article_tag` VALUES (6, 1);
INSERT INTO `article_tag` VALUES (6, 6);
INSERT INTO `article_tag` VALUES (7, 5);
INSERT INTO `article_tag` VALUES (8, 1);
INSERT INTO `article_tag` VALUES (9, 1);
INSERT INTO `article_tag` VALUES (9, 4);
INSERT INTO `article_tag` VALUES (10, 1);
INSERT INTO `article_tag` VALUES (10, 5);
INSERT INTO `article_tag` VALUES (11, 7);
INSERT INTO `article_tag` VALUES (12, 8);
INSERT INTO `article_tag` VALUES (13, 9);
INSERT INTO `article_tag` VALUES (14, 10);
INSERT INTO `article_tag` VALUES (16, 11);
INSERT INTO `article_tag` VALUES (19, 13);
INSERT INTO `article_tag` VALUES (20, 14);
INSERT INTO `article_tag` VALUES (21, 15);

-- ----------------------------
-- Table structure for article_user
-- ----------------------------
DROP TABLE IF EXISTS `article_user`;
CREATE TABLE `article_user`  (
  `article_id` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  INDEX `FK8xe46t7m6xoph406ppemds7s8`(`user_id`) USING BTREE,
  INDEX `FKso1jvk1hrd536jf99fowobs3n`(`article_id`) USING BTREE,
  CONSTRAINT `FKso1jvk1hrd536jf99fowobs3n` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK8xe46t7m6xoph406ppemds7s8` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article_user
-- ----------------------------
INSERT INTO `article_user` VALUES (17, 110);

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `type` int(11) NOT NULL,
  `upt` datetime NOT NULL,
  `article_id` bigint(20) NULL DEFAULT NULL,
  `creator` bigint(20) NOT NULL,
  `topic_id` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FK5yx0uphgjc6ik6hb82kkw501y`(`article_id`) USING BTREE,
  INDEX `FKfqymi934nige0v1gba0k0cx3g`(`creator`) USING BTREE,
  INDEX `FKo3bvevu9ua4w6f8qu2b177f16`(`topic_id`) USING BTREE,
  CONSTRAINT `FKo3bvevu9ua4w6f8qu2b177f16` FOREIGN KEY (`topic_id`) REFERENCES `topic` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK5yx0uphgjc6ik6hb82kkw501y` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKfqymi934nige0v1gba0k0cx3g` FOREIGN KEY (`creator`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, '你的文章写的很棒', 0, '2019-03-19 13:35:56', 4, 100, NULL);
INSERT INTO `comment` VALUES (2, '我觉得这篇文章写的非常有营养', 0, '2019-03-19 14:03:36', 17, 100, NULL);
INSERT INTO `comment` VALUES (3, '多热烈的海洋，多美好的你', 0, '2019-03-19 14:53:22', 17, 100, NULL);
INSERT INTO `comment` VALUES (4, '多热烈的白羊，多美好的你啊', 0, '2019-03-19 14:53:51', 17, 100, NULL);
INSERT INTO `comment` VALUES (5, '看了这篇文章后我觉得受益匪浅', 0, '2019-03-19 15:00:18', 17, 101, NULL);
INSERT INTO `comment` VALUES (6, '哇，太精彩了', 0, '2019-03-19 15:03:09', 17, 102, NULL);
INSERT INTO `comment` VALUES (7, '好想和作者交朋友', 0, '2019-03-19 15:03:35', 17, 102, NULL);
INSERT INTO `comment` VALUES (8, '如果爱像云，像你飘浮的身影', 0, '2019-03-19 15:04:10', 17, 103, NULL);
INSERT INTO `comment` VALUES (9, '每天多思考一点，生活更多彩一些', 0, '2019-03-19 15:07:59', 17, 105, NULL);
INSERT INTO `comment` VALUES (10, '我想要收藏你的文章', 0, '2019-03-19 15:35:14', 17, 106, NULL);
INSERT INTO `comment` VALUES (11, '梦想不会太遥远', 0, '2019-03-19 15:35:28', 17, 106, NULL);
INSERT INTO `comment` VALUES (12, '多完美的她啊，却是下落不详', 0, '2019-03-19 15:37:31', 17, 106, NULL);
INSERT INTO `comment` VALUES (13, '这欢愉太理想\n要熄灭心跳\n才能拥抱', 0, '2019-03-19 15:38:25', 17, 107, NULL);
INSERT INTO `comment` VALUES (14, '青春一记荒唐，亦然学着疯狂', 0, '2019-03-19 15:39:27', 17, 110, NULL);

-- ----------------------------
-- Table structure for message
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `type` int(11) NOT NULL,
  `upt` datetime NOT NULL,
  `creator` bigint(20) NULL DEFAULT NULL,
  `target` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKsc9iqfqtb1lgidvx67f8gl84d`(`creator`) USING BTREE,
  INDEX `FK15edrihe6axcp55lasraa2o1r`(`target`) USING BTREE,
  CONSTRAINT `FK15edrihe6axcp55lasraa2o1r` FOREIGN KEY (`target`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKsc9iqfqtb1lgidvx67f8gl84d` FOREIGN KEY (`creator`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 21 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of message
-- ----------------------------
INSERT INTO `message` VALUES (1, '郑博 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 14:03:36', 100, 107);
INSERT INTO `message` VALUES (2, '郑博 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 14:53:22', 100, 107);
INSERT INTO `message` VALUES (3, '郑博 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 14:53:51', 100, 107);
INSERT INTO `message` VALUES (4, '夏尼采 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:00:18', 101, 107);
INSERT INTO `message` VALUES (5, '记忆永殇 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:03:09', 102, 107);
INSERT INTO `message` VALUES (6, '记忆永殇 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:03:35', 102, 107);
INSERT INTO `message` VALUES (7, 'chenyunqing 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:04:10', 103, 107);
INSERT INTO `message` VALUES (8, '比尔盖茨 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:07:59', 105, 107);
INSERT INTO `message` VALUES (9, '腾儿飞 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:35:14', 106, 107);
INSERT INTO `message` VALUES (10, '腾儿飞 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:35:28', 106, 107);
INSERT INTO `message` VALUES (11, '腾儿飞 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:37:31', 106, 107);
INSERT INTO `message` VALUES (12, '王汉炎 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:38:25', 107, 107);
INSERT INTO `message` VALUES (13, '老钱 评论了你的文章:《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 1, '2019-03-19 15:39:27', 110, 107);
INSERT INTO `message` VALUES (14, '老钱 收藏了你的文章：《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 0, '2019-03-19 16:36:30', 110, 107);
INSERT INTO `message` VALUES (15, '老钱 收藏了你的文章：《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 0, '2019-03-19 16:40:22', 110, 107);
INSERT INTO `message` VALUES (16, '老钱 收藏了你的文章：《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 0, '2019-03-19 16:42:37', 110, 107);
INSERT INTO `message` VALUES (17, '老钱 收藏了你的文章：《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 0, '2019-03-19 16:43:17', 110, 107);
INSERT INTO `message` VALUES (18, '老钱 收藏了你的文章：《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 0, '2019-03-19 16:43:19', 110, 107);
INSERT INTO `message` VALUES (19, '老钱 收藏了你的文章：《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 0, '2019-03-19 16:43:24', 110, 107);
INSERT INTO `message` VALUES (20, '老钱 收藏了你的文章：《ES6 Promise 用法讲解 - 王汉炎 - 博客园》', 0, '2019-03-19 16:43:55', 110, 107);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `background` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `color` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `creator` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKjub7d6y5o9xvaihc9u2s2d181`(`creator`) USING BTREE,
  CONSTRAINT `FKjub7d6y5o9xvaihc9u2s2d181` FOREIGN KEY (`creator`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, '#ECF5FF', '#669EFF', '知识笔记', 100);
INSERT INTO `tag` VALUES (2, '#CFEFA9', '#A5C621', '程序语言', 100);
INSERT INTO `tag` VALUES (3, '#8408B1', '#EDA5F4', 'Web 语言', 100);
INSERT INTO `tag` VALUES (4, '#C4600F', '#F4DFCB', 'Web 框架', 100);
INSERT INTO `tag` VALUES (5, '#347104', '#D2F1D1', '前端框架', 100);
INSERT INTO `tag` VALUES (6, '#F1078F', '#F9B8D3', '.NET 框架', 100);
INSERT INTO `tag` VALUES (7, '#ECF5FF', '#669EFF', '设计模式', 101);
INSERT INTO `tag` VALUES (8, '#ECF5FF', '#669EFF', '教程', 102);
INSERT INTO `tag` VALUES (9, '#ECF5FF', '#669EFF', 'Echarts', 103);
INSERT INTO `tag` VALUES (10, '#ECF5FF', '#669EFF', 'cors', 104);
INSERT INTO `tag` VALUES (11, '#E6F7CE', '#4AAE07', '设计模式', 106);
INSERT INTO `tag` VALUES (12, '#ECF5FF', '#669EFF', 'JavaScript', 107);
INSERT INTO `tag` VALUES (13, '#ECF5FF', '#669EFF', '软件安装', 109);
INSERT INTO `tag` VALUES (14, '#ECF5FF', '#669EFF', 'Java基础', 110);
INSERT INTO `tag` VALUES (15, '#ECF5FF', '#669EFF', '算法', 111);

-- ----------------------------
-- Table structure for topic
-- ----------------------------
DROP TABLE IF EXISTS `topic`;
CREATE TABLE `topic`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `summary` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `upt` datetime NOT NULL,
  `creator` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FK7u0oinx2926gyl6tnsnhtptw9`(`creator`) USING BTREE,
  CONSTRAINT `FK7u0oinx2926gyl6tnsnhtptw9` FOREIGN KEY (`creator`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of topic
-- ----------------------------
INSERT INTO `topic` VALUES (1, 'Spring Boot', 'Spring Boot 是一个专门为敏捷开发而设计的现代化Java Web框架，它集成了SpringMVC 等常用Web框架，只需程序员在maven文件中引入相关依赖即可自动帮助程序员进行配置，免去了使用以往的框架时每次新建项目都需要重新配置的繁琐步骤，是一个目前非常成熟且流行的Java Web框架，同时也是现在很多公司招聘Java程序员的必备条件。\n\n本话题收录与Spring Boot相关的博文，欢迎大家投稿！', '2019-03-16 15:16:24', 100);
INSERT INTO `topic` VALUES (2, 'Vue', 'Vuejs是由尤雨溪创作的前端单页面框架，由于其入门简单且易学，目前在各大公司都很受欢迎。', '2019-03-16 15:24:16', 100);

-- ----------------------------
-- Table structure for topic_tag
-- ----------------------------
DROP TABLE IF EXISTS `topic_tag`;
CREATE TABLE `topic_tag`  (
  `topic_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  INDEX `FKghqd3bga4hj3pklcwmgw36f9l`(`tag_id`) USING BTREE,
  INDEX `FKqvqmd2eomy749a9uei56n71rd`(`topic_id`) USING BTREE,
  CONSTRAINT `FKqvqmd2eomy749a9uei56n71rd` FOREIGN KEY (`topic_id`) REFERENCES `topic` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKghqd3bga4hj3pklcwmgw36f9l` FOREIGN KEY (`tag_id`) REFERENCES `tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of topic_tag
-- ----------------------------
INSERT INTO `topic_tag` VALUES (1, 4);
INSERT INTO `topic_tag` VALUES (2, 5);

-- ----------------------------
-- Table structure for topic_user
-- ----------------------------
DROP TABLE IF EXISTS `topic_user`;
CREATE TABLE `topic_user`  (
  `topic_id` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  INDEX `FKga75s0q7bp80rcqx7lqvjcm8k`(`user_id`) USING BTREE,
  INDEX `FKdd1vsk5b3sb9i9j7kwhpomhyc`(`topic_id`) USING BTREE,
  CONSTRAINT `FKdd1vsk5b3sb9i9j7kwhpomhyc` FOREIGN KEY (`topic_id`) REFERENCES `topic` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKga75s0q7bp80rcqx7lqvjcm8k` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `college` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `headimg` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `reg` datetime NOT NULL,
  `role` int(11) NOT NULL,
  `tel` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 112 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (100, '信息工程系', 'https://i.loli.net/2019/03/16/5c8c9b1c3e372.jpg', '郑博', 'admin', '2019-03-16 14:29:47', 2, '13034207579');
INSERT INTO `user` VALUES (101, '安卓巴士', 'https://i.loli.net/2019/03/19/5c9042723629b.jpg', '夏尼采', 'admin', '2019-03-16 15:42:58', 1, '13424508908');
INSERT INTO `user` VALUES (102, '简书系', 'https://i.loli.net/2019/03/19/5c90428d9391d.jpg', '记忆永殇', 'admin', '2019-03-16 15:44:32', 0, '14584349250');
INSERT INTO `user` VALUES (103, '思否系', 'https://i.loli.net/2019/03/19/5c9042a355452.jpg', 'chenyunqing', 'admin', '2019-03-16 15:47:15', 1, '13344983601');
INSERT INTO `user` VALUES (104, '无名学院', 'https://i.loli.net/2019/03/19/5c9042b576cd7.jpg', '无名氏', 'admin', '2019-03-16 15:49:53', 0, '15704734183');
INSERT INTO `user` VALUES (105, '微软系', 'https://i.loli.net/2019/03/19/5c9042c872010.jpg', '比尔盖茨', 'admin', '2019-03-16 15:50:28', 2, '15704734184');
INSERT INTO `user` VALUES (106, '微软系', 'https://i.loli.net/2019/03/19/5c9042d7708bb.jpg', '腾儿飞', 'admin', '2019-03-16 15:50:50', 1, '15704734185');
INSERT INTO `user` VALUES (107, '博客园', 'https://i.loli.net/2019/03/19/5c9042ebef612.jpg', '王汉炎', 'admin', '2019-03-16 15:51:48', 0, '15704734186');
INSERT INTO `user` VALUES (108, '掘金', 'https://i.loli.net/2019/03/19/5c9043089d04c.jpg', '花裤衩', 'admin', '2019-03-16 15:52:16', 1, '15704734177');
INSERT INTO `user` VALUES (109, '掘金', 'https://i.loli.net/2019/03/19/5c904317398cb.jpg', '搬砖滴', 'admin', '2019-03-16 15:52:48', 0, '15704734178');
INSERT INTO `user` VALUES (110, '知乎', 'https://i.loli.net/2019/03/19/5c90433e57c9d.jpg', '老钱', 'admin', '2019-03-16 15:53:24', 0, '15704734179');
INSERT INTO `user` VALUES (111, '博客园', 'https://i.loli.net/2019/03/19/5c90434ea7f03.jpg', '做个隐士', 'admin', '2019-03-16 15:54:01', 0, '15704734180');

-- ----------------------------
-- Table structure for user_follow
-- ----------------------------
DROP TABLE IF EXISTS `user_follow`;
CREATE TABLE `user_follow`  (
  `tofws_id` bigint(20) NOT NULL,
  `befws_id` bigint(20) NOT NULL,
  INDEX `FKj1kgm3hc53643w0hu3su4aags`(`befws_id`) USING BTREE,
  INDEX `FKohko3rdyjdcrqqcwww4nwwlqv`(`tofws_id`) USING BTREE,
  CONSTRAINT `FKohko3rdyjdcrqqcwww4nwwlqv` FOREIGN KEY (`tofws_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKj1kgm3hc53643w0hu3su4aags` FOREIGN KEY (`befws_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of user_follow
-- ----------------------------
INSERT INTO `user_follow` VALUES (100, 107);
INSERT INTO `user_follow` VALUES (110, 107);

SET FOREIGN_KEY_CHECKS = 1;
